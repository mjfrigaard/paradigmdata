---
title: "purrr updates (v1.0.0)"
author: "Martin Frigaard"
date: "2023-04-05"
image: "image.png"
toc: true
toc-depth: 5
toc-title: 'Contents'
toc-location: "left"

fig-align: center
code-link: true
fontsize: '11'

callout-icon: false
callout-appearance: default

freeze: true

execute:
  echo: true
  warning: false
  eval: true
---

```{r}
#| label: utils
#| eval: true
#| echo: false
#| include: false
library(kableExtra)
co_box <- function(color, header, contents = "Your text") {
  class <- switch(color,
    b = "note",
    g = "tip",
    r = "important",
    o = "caution",
    stop("Invalid `type`", call. = FALSE)
  )
  switch(color,
    b = cat(paste0(
      "\n",
      ":::: {.callout-", class, " collapse='false'}", "\n\n",
      "## ", header, "\n\n",
      "::: {style='font-size: 0.90em; color: #696969;'}\n\n",
      contents, "\n\n",
      "::: \n\n",
      "::::", "\n"
    )),
    g = cat(paste0(
      "\n",
      ":::: {.callout-", class, " collapse='true'}", "\n\n",
      "## ", header, "\n\n",
      "::: {style='font-size: 0.90em; color: #696969;'}\n\n",
      contents, "\n\n",
      "::: \n\n",
      "::::", "\n"
    )),
    o = cat(paste0(
      "\n",
      ":::: {.callout-", class, " collapse='false'}", "\n\n",
      "## ", header, "\n\n",
      "::: {style='font-size: 0.90em; color: #696969;'}\n\n",
      contents, "\n\n",
      "::: \n\n",
      "::::", "\n"
    )),
    r = cat(paste0(
      "\n",
      ":::: {.callout-", class, " collapse='false'}", "\n\n",
      "## ", header, "\n\n",
      "::: {style='font-size: 0.90em; color: #696969;'}\n\n",
      contents, "\n\n",
      "::: \n\n",
      "::::", "\n"
    )),
    stop("Invalid `type`", call. = FALSE)
  )
}
# make_mixed_list ----
make_mixed_list <- function() {
  list(
    'booleans' = rep(
      x = sample(c(TRUE, FALSE), size = 2, replace = FALSE),
      times = 2
    ),
    'integers' = as.integer(sample(1:10, size = 5, replace = FALSE)),
    'doubles' = round(rnorm(n = 5, mean = 3, sd = 0.2), digits = 3),
    'strings' = sample(x = stringr::words, size = 5, replace = FALSE),
    'dates' = c(lubridate::as_date(lubridate::today() - 10), 
                lubridate::as_date(lubridate::today() - 50),
                lubridate::as_date(lubridate::today() - 100)
      )
  )
}
mixed_list <- make_mixed_list()
# make_my_list -----
make_my_list <- function() {
  require(stringr)
  require(snakecase)
  words <- sample(snakecase::to_random_case(stringr::words),
              size = 5, replace = FALSE)
  sentences <- sample(snakecase::to_random_case(stringr::sentences), 
              size = 3, replace = FALSE)
  letters <- sample(snakecase::to_random_case(LETTERS),
              size = 10, replace = FALSE)
  list(
    'words' = words,
    'sentences' = sentences,
    'letters' = letters
  )
}
my_list <- make_my_list()
```

<!--
https://mjfrigaard.github.io/posts/vanilla-shiny/

https://mjfrigaard.github.io/posts/my-pkg-app/

https://mjfrigaard.github.io/posts/my-golem-app/

https://mjfrigaard.github.io/posts/my-leprechaun-app/

https://mjfrigaard.github.io/posts/my-rhino-app/
-->

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(color = "r", header = "ALERT!", "**This post is currently under development. Thank you for your patience.**")
```


::: {style="font-size: 0.90em;"}
```{r}
#| label: pkgs
#| echo: true
#| message: false 
#| warning: false
# remotes::install_github("tidyverse/purrr", 
#                   force = TRUE, quiet = TRUE)
library(purrr)
library(dplyr)
library(lubridate)
library(stringr)
library(snakecase)
library(sloop)
```
:::

This post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/) ("*a complete and consistent set of tools for working with functions and vectors*"). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I've always found to be a great time for a refresher!

# REFRESHER: Functions and objects 

If you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.

In a functional programming language like R, it's nice when we can have functions perform a lot of the work we'd have to write into a `for` loop. 

## Generic functions

R's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` function is an S3 generic function: 

::: {style="font-size: 0.90em;"}
```{r isS3stdGeneric}
sloop::ftype(plot)
```
:::

Which means `plot()` can be applied to a `ts` (Time-Series) object or a standard `data.frame`:

::: {style="font-size: 0.90em;"}
```{r LakeHuron}
#| label: LakeHuron
#| echo: true
#| eval: true
#| collapse: true
class(datasets::LakeHuron)
class(datasets::chickwts)
```

```{r chickwts}
#| layout-ncol: 2
#| fig-cap: 
#|   - "Time-series plot"
#|   - "Scatter Plot"
plot(datasets::LakeHuron)
plot(datasets::chickwts)
```
:::

`summary()` is also generic--we can apply this function to individual data objects, model outputs, etc.

::: {style="font-size: 0.90em;"}
```{r isS3stdGeneric-summary}
sloop::ftype(summary)
```
:::

`plot()` and `summary()` are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it. 

::: {style="font-size: 0.90em; color: #696969;"}
*Click **Code** below to view an example using `summary()`*
:::

::: {style="font-size: 0.90em;"}
```{r lm}
#| label: lm_generic
#| code-fold: true
#| collapse: true

# get summary of columns ----------------------------------------------------
summary(mtcars$hp)
summary(mtcars$mpg)

# store model output  -------------------------------------------------------
lm_mod <- lm(formula = mpg ~ hp, data = mtcars)
lm_mod

# get summary of model output -----------------------------------------------
summary(lm_mod)

# pass the output from one S3 generic to another S3 generic -----------------
coef(summary(lm_mod))
```
:::

As you can see, generic functions are flexible and efficient because we're not having to define a new function for each object--the output from the function depends (in part) on the structure of the object.

> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition

The relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving common problems programmers encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.

## Iteration problems 

In programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: 

  1. You have a folder full of files you'd like to rename or copy to a new directory   

  2. You'd like to download a collection of files from separate URLS  

  3. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset

  4. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. 

These are all problems I've personally encountered that required a variety of iteration tools to tackle. But I'll start with a simple example because the principles remain the same (regardless of the size/scope of the problem):

  5. I have a list of character strings and I'd like to convert the case of the text

It just so happens I have such a list (`my_list`), with items in various cases. 

::: {style="font-size: 0.90em;"}
```{r my_list}
#| label: my_list
#| collapse: true
my_list
```
:::

If I try to use the `tolower()` on `my_list`, it returns a vector.

::: {style="font-size: 0.90em;"}
```{r}
#| label: tolower_my_list
#| collapse: true
tolower(my_list) |> str()
```
:::

How can I apply the `tolower()` function to each item in `my_list` (and return the original object type)?

# The `for` loop

`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: 

> "*for each `item` in `object`, do `operation`*"

I'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:

-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'

      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`)
    ```{r}
    #| collapse: true
    seq_along(my_list)
    # take single value of 'x'
    seq_along(my_list)[1]
    # use this to get 'items in object'
    my_list[[seq_along(my_list)[1]]]
    ```
    
-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)

    - Test this with a few values if you like
    ```{r}
    tolower(my_list[[2]])
    ```

-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size

    - Creating empty lists  
    ```{r}
    vector(mode = "list", length = 3)
    list(NULL, NULL, NULL)
    ```

Finally, we put it all together in a `for` loop

::: {style="font-size: 1.0em;"}
```{r}
#| label: for_loop
# define capture object
lc_list <- vector(mode = "list", length = 3)
# write sequence
for (x in seq_along(my_list)) {        
  # write operations/capture in object
  lc_list[[x]] <- tolower(my_list[[x]])
  # clean up container
  names(lc_list) <- c("words", "sentences", "letters")
}
lc_list
```
:::

This was a simple example, but it demonstrates the basic components in a `for` loop: 

1. The sequence to index 
    - `for (x in seq_along(my_list))`  
2. The operations to iterate   
    - `tolower(my_list[[x]])`   
3. The object to capture the results  
    - `lc_list <- vector(mode = "list", length = 3)` and  
    - `lc_list[[x]]`
  
# Base R

The family of functions `apply` functions from base R (`apply()`, `tapply()`, `sapply()`, `lapply()`) take advantage of R's functional programming and remove a lot of the 'book keeping' code we have to write in `for` loops. 

The function I want for the example above is `lapply()` (pronounced 'l-apply', and the `l` stands for list). There are only two required arguments: `X` and `FUN`, with `X` being the object we want to iterate over, and `FUN` being the function we want iterated:

```{r}
#| label: lapply
lapply(X = my_list, FUN = tolower)
```

However, the `apply` functions have minor differences in how they are used. 

# `purrr`

If you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)

1. Do it for one element

2. Turn it into a recipe

3. Use `purrr::map()` to do it for all elements

I'll work through these three steps below using `my_list` and `tolower()`

## 1. Do it for one element

The goal with this first step is to get a minimal working example with a single element from the object I want to use (and the function I want to iterate).

::: {style="font-size: 0.90em;"}
```r
# subset an element from the list
_____ <- my_list[[?]]
# apply a function to extracted element
tolower(_____)
```
:::

- `_____ <- my_list[[?]]` = subsetted element (`?`) from a list (`my_list`)

- `tolower(_____)` = apply operation (i.e., function) to apply across extracted element.

In this case, I'll subset `my_list` for a single element (`words`, `sentences`, or `letters`) so I can use it with `tolower()`. I'll start with the `words` vector in `my_list`

::: {style="font-size: 0.90em;"}
```{r}
my_words <- my_list[['words']]
tolower(my_words)
```
:::

Now that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.

## 2. Turn it into a recipe

A standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.

- `.x` =  a list or atomic vector 

- `.f` = the function we want to apply over every element in `.x`

::: {style="font-size: .90em;"}
```r
.x = my_list, .f = tolower
```
:::

## 3. `map()` it across all elements

In `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` 

For example, if I want to convert the case of every element in my_list to lowercase with `tolower`, I would use the following standard `purrr::map()` format:

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_standard
#| results: hold
purrr::map(.x = my_list, .f = tolower)
```
:::

And there you have it--iteration in a single line of code! `purrr::map()` is identical to `lapply()` in this example, but it's important to note that `purrr::map()` always returns a list (regardless of the object supplied to `.x`).

# Updates in version 1.0.0

Now I'll cover some of the updates in purrr 1.0.0 (using the examples above).

## Anonymous functions

As of [R 4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html), new anonymous functions have been added. 

> "*R now provides a shorthand notation for creating functions, e.g. `\(x) x + 1` is parsed as `function(x) x + 1`.*" 

**Anonymous function syntax:**

::: {style="font-size: 0.90em;"}
```r
# written as an anonymous function
\(x) tolower(x)
```
:::

Below is a comparison of R's anonymous (unnamed) function and the updated shorthand syntax:

-   Standard anonymous function  

    ::: {style="font-size: 0.90em;"}
    ```{r}
    (function(x) tolower(x))("pIrAtES Ship")
    ```
    :::

-   The updated anonymous syntax is below:

    ::: {style="font-size: 0.90em;"}
    ```{r}
    (\(x) tolower(x))("pIrAtES Ship")
    ```
    :::

Writing the code above using an anonymous function would look like this:

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_anonymous_fun
#| results: hold
my_list |> purrr::map(\(x) tolower(x))
```
:::

Anonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* 

I'll confirm the outputs from both methods are identical using `waldo::compare()`:

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_test_waldo
#| results: hold
waldo::compare(
  x = purrr::map(.x = my_list, .f = tolower), 
  y = my_list |> purrr::map(\(x) tolower(x)))
```
:::

:::: {.callout-important icon=false}
## Formula syntax 

Prior to `purrr` v1.0.0, I could also use the formula syntax:

**Formula syntax:**

The formula syntax can take some getting used to, but Jenny Bryan offers some great advice on [her tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), 

> "*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*"

::: {style="font-size: 1.0em;"}
```r
# written as normal expression
 ~ tolower(.x)
```
:::

- `~ function()` read as '*map this function*'

- `.x` = `purrr`'s placeholder for one element of our object ("*must use `.x` to refer to the first argument. Only recommended if you require backward compatibility with older versions of R.*")

::::

I can double-check to see that the output from two variations are identical using `waldo::compare()`.

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_anonymous
#| results: hold
waldo::compare(
  x = my_list |> purrr::map(\(x) tolower(x)), 
  y = my_list |> purrr::map(~ tolower(.x)))
```
:::

## `map()` updates 

`map()` is the core function and workhorse of the `purrr` package. However, as noted above, by default `map()` returns a list. Fortunately there are `map_` variations for each vector type. 

I'll demonstrate them below using the `mixed_list` object, which has five vectors. 

::: {style="font-size: 0.90em;"}
```{r mixed_list}
#| label: mixed_list
mixed_list
```
:::

-   `map_lgl()`: returns a logical vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| collapse: true
    mixed_list |> purrr::map_lgl(\(x) is.logical(x))
    ```
    :::

-   `map_int()`: returns an integer vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| collapse: true
    mixed_list |> purrr::map_int(\(x) is.integer(x))
    ```
    :::

-   `map_dbl()`: returns a double vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| collapse: true
    mixed_list |> purrr::map_dbl(\(x) is.double(x))
    ```
    :::

-   `map_chr()`: returns a character vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| message: false
    #| collapse: true
    mixed_list |> purrr::map_chr(\(x) is.character(x))
    ```
    :::
    
When we test for characters in `mixed_list`, we see the following warning:

::: {style="font-size: 0.90em;"}
> `Warning: Automatic coercion from logical to character was deprecated in purrr`
> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`
:::

As we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).

### `map_vec()`

However, the previous `map_raw()` function has been replaced with `map_vec()`, which I demonstrate below with the dates in `mixed_list` (testing for `is.character`):

::: {style="font-size: 0.90em;"}
```{r}
#| warning: true
#| message: true
#| eval: true
mixed_list |> purrr::map_vec(\(x) is.character(x))
```
:::

Notice the difference in output? This is because `map_vec()` "*simplifies to the common type of the output*", which comes in handy for objects like dates: 

::: {style="font-size: 0.90em;"}
```{r}
#| warning: true
#| message: true
#| eval: true
mixed_list |> purrr::map_vec(\(x) lubridate::is.Date(x))
```
:::

<!--
# map for `data.frame` and `tibble`s

::: {style="font-size: 0.90em;"}
```{r}
swdata <- dplyr::select(dplyr::starwars, !where(is.list))
purrr::map_df(.x = swdata, .f = tolower)
```
:::
-->

# Worked Examples

## Copying a directory of files 

> *You have a folder full of files you'd like to rename or copy to a new directory*

## Downloading files 

> *You'd like to download a collection of files from separate URLS*
  
## Import multiple datasets 

> *You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset*

## Export multiple datasets 

> *You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths* 





:::: {.callout-tip icon=false}
## REACP: `purrr` syntax variations

::: {style="font-size: 1.25em;"}
**Standard**
:::

::: {style="font-size: 1.10em;"}
```r
# define .x and .f
purrr::map(.x = my_list, .f = tolower)
```
:::

::: {style="font-size: 1.25em;"}
**Anonymous function**
:::


::: {style="font-size: 1.10em;"}
```r
# anonymous shorthand notation
my_list |> purrr::map(\(x) tolower(x))
```
:::

::: {style="font-size: 1.25em;"}
**Formula**
:::

::: {style="font-size: 1.10em;"}
```r
# written as normal expression
my_list |> purrr::map(~ tolower(.x))
```
:::
::::


For more information check out the [iteration chapter in R for Data Science](https://r4ds.had.co.nz/iteration.html).  