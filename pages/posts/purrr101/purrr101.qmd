---
title: "purrr updates (v1.0.0)"
author: "Martin Frigaard"
date: "2023-04-05"
image: "image.png"
toc: true
toc-depth: 5
toc-title: 'Contents'
toc-location: "left"

fig-align: center
code-link: true
fontsize: '11'

callout-icon: false
callout-appearance: default

freeze: true

execute:
  echo: true
  warning: false
  eval: true
  collapse: true
---

```{r}
#| label: utils
#| eval: true
#| echo: false
#| include: false
source("../_common.R")
library(kableExtra)
mixed_list <- make_mixed_list()
my_list <- make_my_list()
```

<!--
https://mjfrigaard.github.io/posts/vanilla-shiny/

https://mjfrigaard.github.io/posts/my-pkg-app/

https://mjfrigaard.github.io/posts/my-golem-app/

https://mjfrigaard.github.io/posts/my-leprechaun-app/

https://mjfrigaard.github.io/posts/my-rhino-app/
-->

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(color = "r", header = "ALERT!", "**This post is currently under development. Thank you for your patience.**")
```


::: {style="font-size: 0.90em;"}
```{r}
#| label: pkgs
#| echo: true
#| message: false 
#| warning: false
# remotes::install_github("tidyverse/purrr", 
#                   force = TRUE, quiet = TRUE)
library(purrr)
library(dplyr)
library(lubridate)
library(stringr)
library(snakecase)
library(sloop)
library(waldo)
```
:::

This post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I will cover below. But first, I'll dive into some attributes of R's functions and objects that make `purrr` particularly useful, and I'll work through iteration problems I've encountered (and solved with `purrr`).

# **Refresher**: functions and objects 

If you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.

In a functional programming language like R, it's nice when we can have functions perform a lot of the work we'd have to write into a `for` loop. 

## Generic functions & S3 objects

R's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` and `summary()` functions are S3 generic function: 

::: {style="font-size: 0.90em;"}
```{r isS3stdGeneric}
sloop::ftype(plot)
sloop::ftype(summary)
```
:::

Which means `plot()` can be applied to S3 objects, like time-series (`ts`) and rectangular datasets (`data.frame`):

::: {style="font-size: 0.90em;"}
```{r LakeHuron}
#| label: LakeHuron
#| echo: true
#| eval: true
#| collapse: true
sloop::otype(datasets::LakeHuron)
class(datasets::LakeHuron)
sloop::otype(datasets::chickwts)
class(datasets::chickwts)
```

```{r chickwts}
#| label: summary_demo
#| collapse: true
summary(datasets::LakeHuron)
summary(datasets::chickwts)
```

```{r}
#| layout-ncol: 2
#| fig-cap: 
#|   - "Time-series plot"
#|   - "Scatter Plot"
plot(datasets::LakeHuron)
plot(datasets::chickwts)
```
:::

`summary()` is a particularly versatile function, because it can be used on `data.frame`s, a single column in a `data.frame`, model outputs, and more. 

::: {style="font-size: 0.90em; color: #696969;"}
*Click **Code** below to view an example using `summary()`*
:::

::: {style="font-size: 0.90em;"}
```{r lm}
#| label: lm_generic
#| code-fold: true
#| collapse: true

# get summary of columns ----------------------------------------------------
summary(mtcars$hp)
summary(mtcars$mpg)

# store model output  -------------------------------------------------------
lm_mod <- lm(formula = mpg ~ hp, data = mtcars)
lm_mod

# get summary of model output -----------------------------------------------
summary(lm_mod)

# pass the output from one S3 generic to another S3 generic -----------------
coef(summary(lm_mod))
```
:::


## FP + OOP 

`plot()` and `summary()` are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it. 

As you can see, generic functions are flexible and efficient because we're not having to define a new function for each object--the output from the function depends (in part) on the structure of the object.

> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition

The relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving common problems programmers encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.

## Iteration problems 

In programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: 

  1. You have a list of objects and you'd like to apply a function (or a series of functions) over the elements in the list
  
  2. You have a folder full of files you'd like to rename or copy to a new directory   

  3. You'd like to download a collection of files from separate URLS  

  4. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset

  5. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. 

These are all problems I've personally encountered that required a variety of iteration tools to tackle. I'll start with the first example because the principles remain the same (regardless of the size/scope of the problem):


# **The `for` loop**

`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: 

> "*for each `item` in `object`, do `operation`*"

I have a list (`my_list`), with items in various cases:

::: {style="font-size: 0.90em;"}
```{r my_list}
#| label: my_list
#| collapse: true
my_list
```
:::

If I try to use the `tolower()` on `my_list`, it returns a vector.

::: {style="font-size: 0.90em;"}
```{r}
#| label: tolower_my_list
#| collapse: true
tolower(my_list) |> str()
```
:::

How can I apply the `tolower()` function to each item in `my_list`, and return the original object type? I'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:

-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'

      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`) 
      
    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| collapse: true
    seq_along(my_list)
    # take single value of 'x'
    seq_along(my_list)[1]
    # use this to get 'items in object'
    my_list[[seq_along(my_list)[1]]]
    ```
    :::
    
-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)

    - Test this with a few values if you like
    
    ::: {style="font-size: 0.90em;"}
    ```{r}
    tolower(my_list[[2]])
    ```
    :::

-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size

    - Two methods for creating empty lists  
    
    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| label: empty_list
    #| collapse: true
    vector(mode = "list", length = 3)
    list(NULL, NULL, NULL)
    ```
    :::

Finally, we put it all together in a `for` loop

::: {style="font-size: 1.0em;"}
```{r}
#| label: for_loop
# define capture object
lc_list <- vector(mode = "list", length = 3)
# write sequence
for (x in seq_along(my_list)) {        
  # write operations/capture in object
  lc_list[[x]] <- tolower(my_list[[x]])
  # clean up container
  names(lc_list) <- c("words", "sentences", "letters")
}
lc_list
```
:::

This was a simple example, but it demonstrates the basic components in a `for` loop: 

1. The sequence to index 
    - `for (x in seq_along(my_list))`  
2. The operations to iterate   
    - `tolower(my_list[[x]])`   
3. The object to capture the results  
    - `lc_list <- vector(mode = "list", length = 3)` and  
    - `lc_list[[x]]`
  
# **Base R**

base R has the `_apply` family of functions (`apply()`, `lapply()`, `sapply()`, `vapply()`, etc.) that remove a lot of the 'book keeping' code we had to write in the `for` loop.


## `lapply()`


Sticking with the `my_list` and `tolower()` example, the `apply` function I want is `lapply()` (pronounced 'l-apply'), and the `l` stands for list.

`lapply()` has only two required arguments: 

  - `X` the object we want to iterate over 

  - `FUN` being the function we want iterated 

::: {style="font-size: 0.90em;"}
```{r}
#| label: lapply_intro
lapply(X = my_list, FUN = tolower)
```
:::


## `sapply()`

`sapply()` attempts to simplify the result depending on the `X` argument. If `X` is a list containing vectors where every element has the same length (and it's greater than 1), then `sapply()` returns a matrix:

::: {style="font-size: 0.90em;"}
```{r}
#| label: sapply_list
str(my_list[1])
sapply(X = my_list[1], FUN = tolower)
```
:::

If a vector is passed to `X` where every element is length 1, then a vector is returned: 

::: {style="font-size: 0.90em;"}
```{r}
#| label: sapply_vector
str(my_list[[1]])
sapply(X = my_list[[1]], FUN = tolower) 
```
:::

Finally, if `X` is a list where elements have a length greater than 1, then a list is returned (making it identical to `lapply()`

::: {style="font-size: 0.90em;"}
```{r}
waldo::compare(
  x = sapply(X = my_list, FUN = tolower), 
  y = lapply(X = my_list, FUN = tolower)
)
```
:::

This is because `sapply` is a wrapper around `lapply`, but has `simplify` and `USE.NAMES` set to  `FALSE` (see what happens below when I change them to `TRUE`)

::: {style="font-size: 0.90em;"}
```{r}
#| label: sapply_waldo
waldo::compare(
  
  x = lapply(X = my_list[[1]], FUN = tolower), 
  
  y = sapply(X = my_list[[1]], FUN = tolower, 
              simplify = TRUE, USE.NAMES = TRUE)
  
  )
```
:::

## Anonmymous functions 

The `FUN` argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in `my_list`, I could pass an anonymous function the `FUN` (with the index):

::: {style="font-size: 0.90em;"}
```{r}
#| label: lapply_anon_fun
lapply(X = my_list, FUN = function(x) x[[2]])
```
:::

## `vapply()`

Finally `vapply()` is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:

::: {style="font-size: 0.90em;"}
```{r}
#| label: vapply_anon_fun
vapply(X = my_list, 
  FUN = function(x) x[[2]], 
  FUN.VALUE = character(1))
```
:::


The `apply` functions get us much further than writing `for` loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) **write less code.** Unlike generic functions, `apply` functions are designed to work with specific object types, and return values depending on these objects.


One downside of apply functions is they don't play well with `data.frame`s or `tibble`s. However, we can control their return values (and manually supply these to `tibble::tibble()` or `data.frame()`

::: {style="font-size: 0.90em;"}
```{r}
#| label: tibble_from_list
#| code-fold: true
#| eval: false
tibble::tibble(
  words = vapply(X = my_list[[1]][1:3], 
                FUN = `[`, 
                FUN.VALUE = character(1)),
  sentences = vapply(X = my_list[[2]][1:3], 
                    FUN = `[`, 
                    FUN.VALUE = character(1)),
  letters = vapply(X = my_list[[3]][1:3], 
                  FUN = `[`, 
                  FUN.VALUE = character(1)))
```
:::


Another downside of the `apply` functions is they're not very uniform. Each function has slight variations in their arguments and rules for return values. This is where `purrr` comes in...

# **`purrr`**

If you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)

1. Do it for one element

2. Turn it into a recipe

3. Use `purrr::map()` to do it for all elements

I'll work through these three steps below using `my_list` and `tolower()`

## 1. Do it for one element

The goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).

For this example, I need to subset `my_list` for a single element at position `[[1]]`, `[[2]]`, or `[[3]]` (or using one of the vector names). 

I'll then pass this element to `tolower()` and make sure it's the desired behavior:

::: {style="font-size: 0.90em;"}
```r
# subset an element from the list
? <- my_list[[?]]
# apply a function to extracted element
tolower(?)
```
:::

- `? <- my_list[[?]]` = subset element from the list (`my_list`)

- `tolower(?)` = apply operation (i.e., function) to extracted element.

::: {style="font-size: 0.90em;"}
```{r}
my_words <- my_list[['words']]
tolower(my_words)
```
:::

Now that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.

## 2. Turn it into a recipe

A standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.

- `.x` =  a list or atomic vector 

- `.f` = the function we want to apply over every element in `.x`

::: {style="font-size: .90em;"}
```r
.x = my_list, .f = tolower
```
:::

## 3. `map()` it across all elements

In `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` 

If I want to convert the case of every element in `my_list` to lowercase with `tolower()` I would use the following standard `purrr::map()` format:

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_standard
#| results: hold
purrr::map(.x = my_list, .f = tolower)
```
:::

And there you have it! `map()` is the core function and workhorse of the `purrr` package. It's important to note that `purrr::map()` always returns a list, regardless of the object supplied to `.x`. 

# **Version 1.0.0 updates**

Now I'll cover some of the updates in `purrr` 1.0.0. I'll be using `mixed_list`, a list with five different types of vectors. 

::: {style="font-size: 0.90em;"}
```{r mixed_list}
#| label: mixed_list
mixed_list
```
:::

## `map()` updates 

As noted above, by default `purrr::map()` returns a list. If I'd like to return a vector, I can use one of the `map_` variations (there's one for each vector type). 

-   By mapping the `is.<type>()` functions the elements in `mixed_list`, I can test which elements in `mixed_list` return `TRUE`:

    -   `map_lgl()`: returns a logical vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| collapse: false
    mixed_list |> purrr::map_lgl(\(x) is.logical(x))
    ```
    :::

    -   `map_int()`: returns an integer vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| collapse: false
    mixed_list |> purrr::map_int(\(x) is.integer(x))
    ```
    :::

    -   `map_dbl()`: returns a double vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: false
    #| collapse: false
    mixed_list |> purrr::map_dbl(\(x) is.double(x))
    ```
    :::

    -   `map_chr()`: returns a character vector 

    ::: {style="font-size: 0.90em;"}
    ```{r}
    #| warning: true
    #| message: true
    #| collapse: false
    mixed_list |> purrr::map_chr(\(x) is.character(x))
    ```
    :::
    
When we test for characters in `mixed_list`, we see the following warning:

::: {style="font-size: 0.90em;"}
> `Warning: Automatic coercion from logical to character was deprecated in purrr`
> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`
:::

As we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).

### `map_vec()`

<br>

However, the previous `purrr::map_raw()` function has been replaced with `purrr::map_vec()`, which "*simplifies to the common type of the output.*" I'll demonstrate below with the characters in `mixed_list`:

::: {style="font-size: 0.90em;"}
```{r}
#| warning: true
#| message: true
#| eval: true
mixed_list |> purrr::map_vec(\(x) is.character(x))
```
:::

Notice the difference in output?  The results are the same as above, but output is not commented (`##`). The same is true when I test the dates in `mixed_list` using `lubridate::is.Date()`:

::: {style="font-size: 0.90em;"}
```{r}
#| warning: true
#| message: true
#| eval: true
mixed_list |> purrr::map_vec(\(x) lubridate::is.Date(x))
```
:::

## Anonymous functions

R introduced the shorthand anonymous function syntax in version [4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html):

> "*`\(x) x + 1` is parsed as `function(x) x + 1`.*" 

Below is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:

-   Standard anonymous function  

    ::: {style="font-size: 0.90em;"}
    ```{r}
    (function(x) tolower(x))("pIrAtES Ship")
    ```
    :::

-   The updated anonymous syntax is below:

    ::: {style="font-size: 0.90em;"}
    ```{r}
    (\(x) tolower(x))("pIrAtES Ship")
    ```
    :::

Writing the code above using an anonymous function would look like this:

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_anonymous_fun
#| results: hold
my_list |> purrr::map(\(x) tolower(x))
```
:::

Anonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* 

I'll confirm the outputs from both methods are identical using `waldo::compare()`:

::: {style="font-size: 0.90em;"}
```{r}
#| label: my_list_purrr_test_waldo
#| results: hold
waldo::compare(
  x = purrr::map(.x = my_list, .f = tolower), 
  y = my_list |> purrr::map(\(x) tolower(x)))
```
:::

:::: {.callout-important icon=false}
## The formula (`~ .x + 1`)

<br>

::: {style="font-size: 1.10em;"}
Prior to `purrr` v1.0.0, I could also use the formula syntax, but now it's "*only recommended if you require backward compatibility with older versions of R.*" I'll cover the formula syntax briefly because you're likely to encounter it. 
:::

::: {style="font-size: 1.10em;"}
The formula syntax is typically used with pipes, so the contents of `purrr::map()` become the right-hand side of the formula, with the function we want to iterate (`<FUNCTION>`) and a placeholder (`.x`) in the appropriate argument.
:::

::: {style="font-size: 1.20em;"}
```r
<OBJECT> |> purrr::map(~ <FUNCTION>(.x))
```
:::

::: {style="font-size: 1.10em;"}
For the example above, `my_list` is 'piped' to `purrr::map()`, where the formula maps the `tolower()` function (using the `.x` placeholder).
:::

::: {style="font-size: 1.00em;"}
```r
# written as normal expression
 my_list |> purrr::map(~ tolower(.x))
```
:::

::: {style="font-size: 1.10em;"}
Jenny Bryan offers a great description on [her `purrr` tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), 

> "*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*"

I can double-check to see that the output from two variations are identical using `waldo::compare()`.
:::

::: {style="font-size: 1.00em;"}
```{r}
#| label: my_list_purrr_anonymous
#| results: hold
waldo::compare(
  x = my_list |> purrr::map(\(x) tolower(x)), 
  y = my_list |> purrr::map(~ tolower(.x)))
```
:::

::::



<!--
# map for `data.frame` and `tibble`s

::: {style="font-size: 0.90em;"}
```{r}
swdata <- dplyr::select(dplyr::starwars, !where(is.list))
purrr::map_df(.x = swdata, .f = tolower)
```
:::
-->

# Worked Examples

In this section, I'll be working through some of the uses I've for `purrr`'s functions. I've tried to choose tasks that are common across *most* projects so my code can be easily copied and adapted. 

## Downloading files 

> *You'd like to download a collection of files from separate URLS*

I have a collection of 30 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) in a [GitHub repo](https://github.com/mjfrigaard/dds-data). Let's assume I want to download all of these files into my RStudio session (and not clone the repo).

I'll navigate to the raw url for the first data file (`nyt1.csv`), then paste this into a character vector:

::: {style="font-size: 0.90em;"}
```{r}
nyt_url <- "https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv"
```
:::

Knowing that all of the files on GitHub with have a similar `root` or `dir`, I can use `nyt_url` to generate urls for each of the 31 files. 

1. First I get the folder of the files on GitHub with `fs::path_dir()` 
2. I create a vector with the 31 file names  
3. I combine the directory portion of the url with file name in `nyt_file_urls`

::: {style="font-size: 0.90em;"}
```{r}
#| label: nyt_file_urls
#| eval: true
#| collapse: false
# create file urls 
nyt_dir_url <- fs::path_dir(nyt_url)
nyt_dir_url
# add numbers to name
nyt_file_nms <- paste0("nyt", 1:31, ".csv")
# combine
nyt_file_urls <- paste(nyt_dir_url, nyt_file_nms, sep = "/")
head(nyt_file_urls)
```
:::

I'll need another vector of destination file names on my local machine, which I can do by combining the file names (`nyt_file_nms`) with the local destination folder (`dds-nyt`).

::: {style="font-size: 0.90em;"}
```{r nyt_local_pths}
nyt_local_pths <- paste("dds-nyt", nyt_file_nms, sep = "/")
head(nyt_local_pths)
```
:::

After creating the destination folder, I'll use the `download.file()` function to test downloading a single `.csv` files into my local folder (`dds-nyt/`). `download.file()` has a progress bar which tells me if the file downloaded successfully. 

::: {style="font-size: 0.90em;"}
```{r}
#| label: download.file
#| eval: true
#| collapse: false
#| results: asis
# do it for one
fs::dir_create("dds-nyt")
download.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])
```

```bash
trying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'
Content type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)
==================================================
downloaded 4.7 MB
```
:::



The function I'm using to download the files takes two inputs (`url` and `destfile`), which changes the recipe a bit, because I need a `purrr` function with the following:

1. `.x` the input vector of existing url paths 

2. `.y` the output vector of destination file paths 

3. Additional arguments passed from `download.file()` (like `quiet = TRUE`)

In this case, I don't need `purrr` to return value--I just need the `purrr` function to iterate over the items and write them to the new location.

`walk()` is ideal for this circumstance:

> "*`walk()` returns the input `.x` (invisibly)*" and "*The return value of `.f()` is ignored*"

***What does 'return `.x` invisibly' and 'the side-effect of `.f`'***

### Return invisibly 

The previous `purrr` functions I covered varied in the kinds of values they returned (lists vs. vectors), but for some operations I won't need a return value. If I'm ever curious about whether I should be using `map()` or `walk()`, I'll ask myself, *"would it make sense to assign the output from this function to an object?*"

If the answer is no, then I probably need to be thinking `walk()` instead of `map()`

### Side-effects 

In the help documentation `walk()`'s description states, "*calls .f for its side-effect*"

(i.e., there's nothing to assign the output from that function to).

Downloading files performs 

I'll use `walk2()` below and add `.progress = TRUE` to view the `purrr` progress bar (and `quiet = TRUE` to silence the `download.file()` progress bar).  

::: {style="font-size: 0.90em;"}
```{r}
#| label: walk2_download_files
walk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, 
  .progress = TRUE, quiet = TRUE)
```
:::

<br>


```{r}
#| label: purrr-progress
#| echo: false
#| fig-align: center
#| out-width: '100%'
#| fig-dpi: 320
#| fig-asp: 0.618
knitr::include_graphics(path = "purrr-progress.gif")
```

<!--fs::dir_tree("dds-nyt")-->

<br>

I can confirm the download using `fs::dir_tree()`

::: {style="font-size: 0.90em;"}
```{r}
#| label: dir_tree_download_files
fs::dir_tree("dds-nyt")
```
:::


## Copying a directory of files 

> *You have a folder of files you'd like to rename or copy to a new directory*

The collection of 31 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) are now in the `dds-nyt/` folder. 

As with any project, I don't want to alter the raw data, so I'm going to copy these files into `dds-nyt-raw/` and `dds-nyt-processed/`. I also want the processed file names to have a date stamp prefix. 

::: {style="font-size: 0.90em;"}
```{r}
#| label: file_pths
file_pths <- list.files("dds-nyt", full.names = TRUE, pattern = ".csv$")
head(file_pths)
```
:::

I'll start with the raw data folder. I need to create a vector of the new raw file paths and names: `raw_file_pths` (the raw data paths will have the original file names)

::: {style="font-size: 0.90em;"}
```{r}
#| label: raw_file_pths
#| eval: true
#| collapse: true
# do it for one
gsub(pattern = "^dds-nyt",
  replacement = "dds-nyt/raw",
  x = file_pths[1])

# write the recipe
file_pths |> purrr::map_chr(\(x) gsub(x, 
                                pattern = "^dds-nyt", 
                                replacement = "dds-nyt/raw")) |> head()

# map it across all
raw_file_pths <- file_pths |> 
                  purrr::map_chr(\(x) gsub(x, 
                                        pattern = "^dds-nyt", 
                                        replacement = "dds-nyt/raw"))
```
:::

Before copying the files, I need to create the destination folder for the raw data (`dds-nyt/raw`). Then, I'll make sure I can copy the first element from `file_pths` into the path in the first element of `raw_file_pths`:

::: {style="font-size: 0.90em;"}
```{r}
#| label: create_paths
#| eval: true
fs::dir_create("dds-nyt/raw")
# do it for one
fs::file_copy(
  path = file_pths[1], 
  new_path = raw_file_pths[1], 
  overwrite = TRUE)
fs::dir_tree("dds-nyt/raw", type = "any")
```
:::


::: {style="font-size: 0.90em;"}
```{r}
#| label: walk2_file_copy
walk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, 
      .progress = TRUE, overwrite = TRUE)
fs::dir_tree("dds-nyt/raw", type = "any")
```
:::

Now that I've copied the files into their respective folders, I'll need to remove the files from their original location in the parent `dds-nyt` folder.

Fortunately, I have a vector of these files in `file_pths`, and I can test removal with `fs::file_delete()`:

::: {style="font-size: 0.90em;"}
```{r}
#| label: test_file_delete
fs::file_delete(file_pths[1])
```
:::

Great! Now that I know this will work, I'll use `walk()` because I want `.x` returned invisibly and the side-effect of `.f`

::: {style="font-size: 0.90em;"}
```{r}
#| label: error_file_delete
#| error: true
walk(.x = file_pths, .f = fs::file_delete)
```
:::

Why does this throw an error? Well--I've just deleted the first element in `file_pths`, so when `fs::file_delete()` when looking for that file, it found nothing and returned an error. I can protect against this by supplying the output from `list.files()` directly to `walk2()`, but include a `pattern` so it only matches the `.csv` files.

::: {style="font-size: 0.90em;"}
```{r}
walk(# list CURRENT files 
    .x = list.files(
      path = "dds-nyt",
      pattern = ".csv$",
      full.names = TRUE),
    # map function
    .f = fs::file_delete)
```
:::


And confirm the new folder contents and structure

::: {style="font-size: 0.90em;"}
```{r}
fs::dir_tree("dds-nyt", type = "any", recurse = TRUE)
```
:::


## Import multiple datasets 

> *You have several days of data, and each day is contained in separate file. You'd like to read these data into R, and combine them into a single dataset*

Now that I have separate raw and processed folders, I can import the NYT data into R. Below I've imported a single file from the `raw` data folder to examine it's contents:

::: {style="font-size: 0.90em;"}
```{r nyt1}
#| label: import_nyt1.csv
nyt1 <- vroom::vroom(
  "dds-nyt/raw/nyt1.csv", 
  delim = ",", 
  show_col_types = FALSE)
str(nyt1)
```
:::

Each `nyt` file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: `Age`, `Gender` (0 = female, 1 = male), `Impressions` (number impressions), `Clicks` (number clicks), and a binary indicator for signed in or not `Signed_in`. 

I'll add some hypothetical wrangling steps to make this example more realistic.

  1. Create `age_group`, an ordered factor which contains six levels of Age ("<18", "18-24", "25-34", "35-44", "45-54", "55-64", and "65+")

  2. Create `ctr_rate` or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.

  3. Create `female`, a factor version of `Gender`, where when `Gender` = `0`, then `female` = `"yes"`, and when `Gender` = `1`, then `female` = `"no"` 

  4. Create `signed_in`, a factor variable with levels `"no"` and `"yes"` from the `Signed_In` = `0` and `1`

I've bundled all of these steps into a function (`nyt_data_processing()`) that I can pass each dataset through:

::: {style="font-size: 0.90em;"}
```{r nyt_data_processing}
#| label: fun_nyt_data_processing
#| code-fold: true 
nyt_data_processing <- function(nyt_csv) {
  orig_nms <- c("Age", "Gender", "Impressions", "Clicks", "Signed_In")
  nyt_nms <- names(nyt_csv)
  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {
    cli::cli_abort("these data don't have the correct columns!")
  } else {
    nyt_proc <- nyt_csv |> 
      dplyr::mutate(
        # create age_group variable
          age_group = case_when( 
              Age < 18 ~ "<18",
              Age >= 18 & Age < 25 ~ "18-24",
              Age >= 25 & Age < 35 ~ "25-34",
              Age >= 35 & Age < 45 ~ "35-44",
              Age >= 45 & Age < 55 ~ "45-54",
              Age >= 55 & Age < 65 ~ "55-64",
              Age >= 65 ~ "65+"), 
        # factor age_group (ordered)
          age_group = factor(age_group, 
            levels = c("<18", "18-24", "25-34",
              "35-44", "45-54", "55-64", "65+"), 
            ordered = TRUE),
        # create CTR variable
          ctr_rate = round(x = Clicks/Impressions, digits = 3),
        # create new Female variable
          female = case_when( 
              Gender == 0 ~ "yes", 
              Gender == 1 ~ "no",
              TRUE ~ NA_character_),
        # factor female (un-ordered)
          female = factor(female, 
            levels = c("no", "yes")),
          signed_in = case_when( 
              Signed_In == 0 ~ "no", 
              Signed_In == 1 ~ "yes",
              TRUE ~ NA_character_),
        # factor signed_in (un-ordered)
          signed_in = factor(signed_in, 
            levels = c("no", "yes"))) |> 
    # remove Signed_in
    dplyr::select(-c(Signed_In)) |> 
    # format columns
    janitor::clean_names() 
  
  }
  return(nyt_proc)
}
```
:::

I'll do some quick checks to make sure it only works with the raw data columns:

::: {style="font-size: 0.90em;"}
```{r nyt1_proc}
#| label: test_nyt_data_processing
#| error: false
nyt1_proc <- nyt_data_processing(nyt1)
str(nyt1_proc)
```
:::

::: {style="font-size: 0.90em;"}
```{r}
#| label: test_nyt_data_processing_error
#| error: true
nyt_data_processing(nyt1_proc)
```
:::

Now I'm ready to write the import step. First I'll store the raw file paths in `raw_data_pths`, then take a subset to test with (`test_raw_data_pths`).

::: {style="font-size: 0.90em;"}
```{r raw_data_pths}
raw_data_pths <- list.files(path = "dds-nyt/raw", pattern = ".csv$", full.names = TRUE)
test_raw_data_pths <- raw_data_pths[1:2]
test_raw_data_pths
```
:::

We'll test `purrr::map()` and `vroom::vroom()` to import the `.csv` files in `test_raw_data_pths` into a list. I also add `str(list.len = 2)` to limit the output.

::: {style="font-size: 0.90em;"}
```{r}
test_raw_data_pths |> 
  # import
  purrr::map(
    vroom::vroom, 
        delim = ",", show_col_types = FALSE) |> 
  str(list.len = 2)
```
:::

This returns a list, but you may have noticed I don't have a great way for keeping track of the data files in the list--this is where `purrr::set_names()` comes in handy. 

`purrr::set_names()` works a lot like `names()`, but `purrr::set_names()` will automatically set the names of `x` to `as.character(x)` is no names are provided to `nm`. See below:

::: {style="font-size: 0.90em;"}
```{r}
test_raw_data_pths |> purrr::set_names()
```
:::

Now the imported file will have their file path and name associated with the dataset:

::: {style="font-size: 0.90em;"}
```{r}
test_raw_data_pths |> 
  # names 
  purrr::set_names() |> 
  # import  
    purrr::map(
      vroom::vroom, 
          delim = ",", show_col_types = FALSE) |> 
  str(list.len = 2)
```
:::

To add the wrangling function, I can pipe in another call to `purrr::map()`, and add the custom wrangling function. 

::: {style="font-size: 0.90em;"}
```{r}
test_raw_data_pths |> 
  # names 
  purrr::set_names() |> 
  # import 
    purrr::map(
      vroom::vroom, 
          delim = ",", show_col_types = FALSE) |> 
  # wrangle 
  purrr::map(.f = nyt_data_processing) |> 
  str(list.len = 2)
```
:::


For the final step, I'll bind all the data into a `data.frame` with the updated `purrr::list_rbind()` function (set `names_to = "id"`).

::: {style="font-size: 0.90em;"}
```{r}
test_raw_data_pths |> 
  # names 
  purrr::set_names() |> 
  # import 
    purrr::map(
      vroom::vroom, 
          delim = ",", show_col_types = FALSE) |> 
  # wrangle 
  purrr::map(.f = nyt_data_processing) |> 
  # bind
  purrr::list_rbind(names_to = "id") |> 
  str()
```
:::

Now that we have a complete recipe, so all I do is swap out test vector with the full list of file paths and store the result in `nyt_data_proc`. I can also confirm all files were imported and wrangled by checking the `count()` of id.

::: {style="font-size: 0.90em;"}
```{r nyt_data_proc}
nyt_data_proc <- raw_data_pths |> 
  # names 
  purrr::set_names() |> 
  # import 
    purrr::map(
      vroom::vroom, 
          delim = ",", show_col_types = FALSE) |> 
  # wrangle 
  purrr::map(.f = nyt_data_processing) |> 
  # bind
  purrr::list_rbind(names_to = "id") 
```

```{r}
dplyr::glimpse(nyt_data_proc)
```

```{r}
nyt_data_proc |> 
  dplyr::count(id)
```
:::

## Export multiple datasets 

> *You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths*

Now I have a processed dataset, and I want to export this into a `dds-nyt/processed/` folder. 

Creating a vector of processed data file paths is a little more involved because I wanted to add the date prefix, and because I want to add this path as a variable in the `nyt_data_proc` dataset. 

I do this below in `proc_file_pth`:

::: {style="font-size: 0.90em;"}
```{r}
#| label: proc_file_pth
#| eval: true
#| collapse: true
# create file names 
nyt_data_proc_pths <- dplyr::mutate(.data = nyt_data_proc,
        file_nm = tools::file_path_sans_ext(base::basename(id)),
        proc_file_pth = paste0("dds-nyt/processed/", 
                        as.character(Sys.Date()), "-", 
                        file_nm))
nyt_data_proc_pths |> dplyr::count(proc_file_pth)
```
:::

Note that I didn't include the file extension, but that's because I might want to change this when I'm exporting. 

Now that I have my data (`nyt_data_proc_pths`) and processed file paths (`proc_file_pth`), I need create the processed data folder, then group `nyt_data_proc_pths` on the new `proc_file_pth` variable, and then pass the output to the `group_walk()` function from `dplyr`:

::: {style="font-size: 0.90em;"}
```{r}
#| label: group_walk
#| eval: true
#| collapse: true
# create file names 
# create folder 
fs::dir_create("dds-nyt/processed/")
# 
nyt_data_proc_pths |>  
  dplyr::group_by(proc_file_pth) |>   
  dplyr::group_walk( ~vroom::vroom_write(x = .x, 
                          file = paste0(.y$proc_file_pth, ".csv"),
                          delim = ","))
# check
fs::dir_tree("dds-nyt/processed/")
```
:::

I'll import the first file in the new processed data folder and check it against the `nyt1_proc` data to evaluate the differences.  

::: {style="font-size: 0.90em;"}
```{r}
nyt1_proc_check <- vroom::vroom(
  list.files(path = "dds-nyt/processed", 
                    pattern = ".csv$", 
        full.names = TRUE)[[1]], # grab the first file
   delim = ",", show_col_types = FALSE
  )
```
:::

::: {style="font-size: 0.90em;"}
```{r}
waldo::compare(
  x = nyt1_proc,
  y = nyt1_proc_check)
```
:::


```{r}
#| label: master_clean_up_dds_nyt
#| echo: false
fs::dir_delete("dds-nyt/raw")
fs::dir_delete("dds-nyt/processed/")
fs::dir_delete("dds-nyt")
```


:::: {.callout-tip icon=false}
## REACP: `purrr` syntax variations

::: {style="font-size: 1.25em;"}
**Standard**
:::

::: {style="font-size: 1.10em;"}
```r
# define .x and .f
purrr::map(.x = my_list, .f = tolower)
```
:::

::: {style="font-size: 1.25em;"}
**Anonymous function**
:::


::: {style="font-size: 1.10em;"}
```r
# anonymous shorthand notation
my_list |> purrr::map(\(x) tolower(x))
```
:::

::: {style="font-size: 1.25em;"}
**Formula (deprecated)**
:::

::: {style="font-size: 1.10em;"}
```r
# written as normal expression
my_list |> purrr::map(~ tolower(.x))
```
:::
::::


For more information check out the [iteration chapter in R for Data Science](https://r4ds.had.co.nz/iteration.html).  