{
  "hash": "883fd440408c8e2b64c7d59b8bf0a3ce",
  "result": {
    "markdown": "---\ntitle: \"purrr updates (v1.0.0)\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-04-05\"\nimage: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n\nfig-align: center\ncode-link: true\nfontsize: '11'\n\ncallout-icon: false\ncallout-appearance: default\n\nfreeze: true\n\nexecute:\n  echo: true\n  warning: false\n  eval: true\n  collapse: true\n---\n\n\n\n\n<!--\nhttps://mjfrigaard.github.io/posts/vanilla-shiny/\n\nhttps://mjfrigaard.github.io/posts/my-pkg-app/\n\nhttps://mjfrigaard.github.io/posts/my-golem-app/\n\nhttps://mjfrigaard.github.io/posts/my-leprechaun-app/\n\nhttps://mjfrigaard.github.io/posts/my-rhino-app/\n-->\n\n\n\n:::: {.callout-important collapse='false'}\n\n## ALERT!\n\n::: {style='font-size: 0.90em; color: #696969;'}\n\n**This post is currently under development. Thank you for your patience.**\n\n::: \n\n::::\n\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(sloop)\nlibrary(waldo)\n```\n:::\n\n:::\n\nThis post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I will cover below. But first, I'll dive into some attributes of R's functions and objects that make `purrr` particularly useful, and I'll work through iteration problems I've encountered (and solved with `purrr`).\n\n# **Refresher**: functions and objects \n\nIf you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.\n\nIn a functional programming language like R, it's nice when we can have functions perform a lot of the work we'd have to write into a `for` loop. \n\n## Generic functions & S3 objects\n\nR's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` and `summary()` functions are S3 generic function: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::ftype(plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n\n```{.r .cell-code}\nsloop::ftype(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n:::\n\n:::\n\nWhich means `plot()` can be applied to S3 objects, like time-series (`ts`) and rectangular datasets (`data.frame`):\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::otype(datasets::LakeHuron)\n## [1] \"S3\"\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nsloop::otype(datasets::chickwts)\n## [1] \"S3\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(datasets::LakeHuron)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   576.0   578.1   579.1   579.0   579.9   581.9\nsummary(datasets::chickwts)\n##      weight             feed   \n##  Min.   :108.0   casein   :12  \n##  1st Qu.:204.5   horsebean:10  \n##  Median :258.0   linseed  :12  \n##  Mean   :261.3   meatmeal :11  \n##  3rd Qu.:323.5   soybean  :14  \n##  Max.   :423.0   sunflower:12\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(datasets::LakeHuron)\n```\n\n::: {.cell-output-display}\n![Time-series plot](purrr101_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(datasets::chickwts)\n```\n\n::: {.cell-output-display}\n![Scatter Plot](purrr101_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n\n:::\n\n`summary()` is a particularly versatile function, because it can be used on `data.frame`s, a single column in a `data.frame`, model outputs, and more. \n\n::: {style=\"font-size: 0.90em; color: #696969;\"}\n*Click **Code** below to view an example using `summary()`*\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output  -------------------------------------------------------\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept) 30.09886    1.63392  18.421  < 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024,\tAdjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(>|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07\n```\n:::\n\n:::\n\n\n## FP + OOP \n\n`plot()` and `summary()` are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it. \n\nAs you can see, generic functions are flexible and efficient because we're not having to define a new function for each object--the output from the function depends (in part) on the structure of the object.\n\n> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition\n\nThe relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving common problems programmers encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.\n\n## Iteration problems \n\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: \n\n  1. You have a list of objects and you'd like to apply a function (or a series of functions) over the elements in the list\n  \n  2. You have a folder full of files you'd like to rename or copy to a new directory   \n\n  3. You'd like to download a collection of files from separate URLS  \n\n  4. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset\n\n  5. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. \n\nThese are all problems I've personally encountered that required a variety of iteration tools to tackle. I'll start with the first example because the principles remain the same (regardless of the size/scope of the problem):\n\n\n# **The `for` loop**\n\n`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: \n\n> \"*for each `item` in `object`, do `operation`*\"\n\nI have a list (`my_list`), with items in various cases:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list\n## $words\n## [1] \"rING\"      \"REGArD\"    \"neceSSAry\" \"yesterDay\" \"IncOme\"   \n## \n## $sentences\n## [1] \"OnE STeP mOre AnD tHe bOaRD wiLl colLAPSE.\"\n## [2] \"tHE BILL WAs paid eveRy tHird wEeK.\"       \n## [3] \"CodE iS UseD WHEn sECRetS Are SeNT.\"       \n## \n## $letters\n##  [1] \"V\" \"a\" \"m\" \"d\" \"l\" \"R\" \"I\" \"h\" \"J\" \"C\"\n```\n:::\n\n:::\n\nIf I try to use the `tolower()` on `my_list`, it returns a vector.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(my_list) |> str()\n##  chr [1:3] \"c(\\\"ring\\\", \\\"regard\\\", \\\"necessary\\\", \\\"yesterday\\\", \\\"income\\\")\" ...\n```\n:::\n\n:::\n\nHow can I apply the `tolower()` function to each item in `my_list`, and return the original object type? I'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:\n\n-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'\n\n      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`) \n      \n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    seq_along(my_list)\n    ## [1] 1 2 3\n    # take single value of 'x'\n    seq_along(my_list)[1]\n    ## [1] 1\n    # use this to get 'items in object'\n    my_list[[seq_along(my_list)[1]]]\n    ## [1] \"rING\"      \"REGArD\"    \"neceSSAry\" \"yesterDay\" \"IncOme\"\n    ```\n    :::\n\n    :::\n    \n-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)\n\n    - Test this with a few values if you like\n    \n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    tolower(my_list[[2]])\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"one step more and the board will collapse.\"\n    [2] \"the bill was paid every third week.\"       \n    [3] \"code is used when secrets are sent.\"       \n    ```\n    :::\n    :::\n\n    :::\n\n-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size\n\n    - Two methods for creating empty lists  \n    \n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vector(mode = \"list\", length = 3)\n    ## [[1]]\n    ## NULL\n    ## \n    ## [[2]]\n    ## NULL\n    ## \n    ## [[3]]\n    ## NULL\n    list(NULL, NULL, NULL)\n    ## [[1]]\n    ## NULL\n    ## \n    ## [[2]]\n    ## NULL\n    ## \n    ## [[3]]\n    ## NULL\n    ```\n    :::\n\n    :::\n\nFinally, we put it all together in a `for` loop\n\n::: {style=\"font-size: 1.0em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# define capture object\nlc_list <- vector(mode = \"list\", length = 3)\n# write sequence\nfor (x in seq_along(my_list)) {        \n  # write operations/capture in object\n  lc_list[[x]] <- tolower(my_list[[x]])\n  # clean up container\n  names(lc_list) <- c(\"words\", \"sentences\", \"letters\")\n}\nlc_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"ring\"      \"regard\"    \"necessary\" \"yesterday\" \"income\"   \n\n$sentences\n[1] \"one step more and the board will collapse.\"\n[2] \"the bill was paid every third week.\"       \n[3] \"code is used when secrets are sent.\"       \n\n$letters\n [1] \"v\" \"a\" \"m\" \"d\" \"l\" \"r\" \"i\" \"h\" \"j\" \"c\"\n```\n:::\n:::\n\n:::\n\nThis was a simple example, but it demonstrates the basic components in a `for` loop: \n\n1. The sequence to index \n    - `for (x in seq_along(my_list))`  \n2. The operations to iterate   \n    - `tolower(my_list[[x]])`   \n3. The object to capture the results  \n    - `lc_list <- vector(mode = \"list\", length = 3)` and  \n    - `lc_list[[x]]`\n  \n# **Base R**\n\nbase R has the `_apply` family of functions (`apply()`, `lapply()`, `sapply()`, `vapply()`, etc.) that remove a lot of the 'book keeping' code we had to write in the `for` loop.\n\n\n## `lapply()`\n\n\nSticking with the `my_list` and `tolower()` example, the `apply` function I want is `lapply()` (pronounced 'l-apply'), and the `l` stands for list.\n\n`lapply()` has only two required arguments: \n\n  - `X` the object we want to iterate over \n\n  - `FUN` being the function we want iterated \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X = my_list, FUN = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"ring\"      \"regard\"    \"necessary\" \"yesterday\" \"income\"   \n\n$sentences\n[1] \"one step more and the board will collapse.\"\n[2] \"the bill was paid every third week.\"       \n[3] \"code is used when secrets are sent.\"       \n\n$letters\n [1] \"v\" \"a\" \"m\" \"d\" \"l\" \"r\" \"i\" \"h\" \"j\" \"c\"\n```\n:::\n:::\n\n:::\n\n\n## `sapply()`\n\n`sapply()` attempts to simplify the result depending on the `X` argument. If `X` is a list containing vectors where every element has the same length (and it's greater than 1), then `sapply()` returns a matrix:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_list[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ words: chr [1:5] \"rING\" \"REGArD\" \"neceSSAry\" \"yesterDay\" ...\n```\n:::\n\n```{.r .cell-code}\nsapply(X = my_list[1], FUN = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     words      \n[1,] \"ring\"     \n[2,] \"regard\"   \n[3,] \"necessary\"\n[4,] \"yesterday\"\n[5,] \"income\"   \n```\n:::\n:::\n\n:::\n\nIf a vector is passed to `X` where every element is length 1, then a vector is returned: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_list[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:5] \"rING\" \"REGArD\" \"neceSSAry\" \"yesterDay\" \"IncOme\"\n```\n:::\n\n```{.r .cell-code}\nsapply(X = my_list[[1]], FUN = tolower) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       rING      REGArD   neceSSAry   yesterDay      IncOme \n     \"ring\"    \"regard\" \"necessary\" \"yesterday\"    \"income\" \n```\n:::\n:::\n\n:::\n\nFinally, if `X` is a list where elements have a length greater than 1, then a list is returned (making it identical to `lapply()`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\nThis is because `sapply` is a wrapper around `lapply`, but has `simplify` and `USE.NAMES` set to  `FALSE` (see what happens below when I change them to `TRUE`)\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n`old` is a list\n`new` is a character vector ('ring', 'regard', 'necessary', 'yesterday', 'income')\n```\n:::\n:::\n\n:::\n\n## Anonmymous functions \n\nThe `FUN` argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in `my_list`, I could pass an anonymous function the `FUN` (with the index):\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X = my_list, FUN = function(x) x[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"REGArD\"\n\n$sentences\n[1] \"tHE BILL WAs paid eveRy tHird wEeK.\"\n\n$letters\n[1] \"a\"\n```\n:::\n:::\n\n:::\n\n## `vapply()`\n\nFinally `vapply()` is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                words                             sentences \n                             \"REGArD\" \"tHE BILL WAs paid eveRy tHird wEeK.\" \n                              letters \n                                  \"a\" \n```\n:::\n:::\n\n:::\n\n\nThe `apply` functions get us much further than writing `for` loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) **write less code.** Unlike generic functions, `apply` functions are designed to work with specific object types, and return values depending on these objects.\n\n\nOne downside of apply functions is they don't play well with `data.frame`s or `tibble`s. However, we can control their return values (and manually supply these to `tibble::tibble()` or `data.frame()`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n```\n:::\n\n:::\n\n\nAnother downside of the `apply` functions is they're not very uniform. Each function has slight variations in their arguments and rules for return values. This is where `purrr` comes in...\n\n# **`purrr`**\n\nIf you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)\n\n1. Do it for one element\n\n2. Turn it into a recipe\n\n3. Use `purrr::map()` to do it for all elements\n\nI'll work through these three steps below using `my_list` and `tolower()`\n\n## 1. Do it for one element\n\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\n\nFor this example, I need to subset `my_list` for a single element at position `[[1]]`, `[[2]]`, or `[[3]]` (or using one of the vector names). \n\nI'll then pass this element to `tolower()` and make sure it's the desired behavior:\n\n::: {style=\"font-size: 0.90em;\"}\n```r\n# subset an element from the list\n? <- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n```\n:::\n\n- `? <- my_list[[?]]` = subset element from the list (`my_list`)\n\n- `tolower(?)` = apply operation (i.e., function) to extracted element.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- my_list[['words']]\ntolower(my_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ring\"      \"regard\"    \"necessary\" \"yesterday\" \"income\"   \n```\n:::\n:::\n\n:::\n\nNow that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.\n\n## 2. Turn it into a recipe\n\nA standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.\n\n- `.x` =  a list or atomic vector \n\n- `.f` = the function we want to apply over every element in `.x`\n\n::: {style=\"font-size: .90em;\"}\n```r\n.x = my_list, .f = tolower\n```\n:::\n\n## 3. `map()` it across all elements\n\nIn `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` \n\nIf I want to convert the case of every element in `my_list` to lowercase with `tolower()` I would use the following standard `purrr::map()` format:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(.x = my_list, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"ring\"      \"regard\"    \"necessary\" \"yesterday\" \"income\"   \n\n$sentences\n[1] \"one step more and the board will collapse.\"\n[2] \"the bill was paid every third week.\"       \n[3] \"code is used when secrets are sent.\"       \n\n$letters\n [1] \"v\" \"a\" \"m\" \"d\" \"l\" \"r\" \"i\" \"h\" \"j\" \"c\"\n```\n:::\n:::\n\n:::\n\nAnd there you have it! `map()` is the core function and workhorse of the `purrr` package. It's important to note that `purrr::map()` always returns a list, regardless of the object supplied to `.x`. \n\n# **Version 1.0.0 updates**\n\nNow I'll cover some of the updates in `purrr` 1.0.0. I'll be using `mixed_list`, a list with five different types of vectors. \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$booleans\n[1]  TRUE FALSE  TRUE FALSE\n\n$integers\n[1]  1  3  7  8 10\n\n$doubles\n[1] 2.954 3.070 2.885 3.028 2.648\n\n$strings\n[1] \"choice\" \"same\"   \"equal\"  \"sound\"  \"most\"  \n\n$dates\n[1] \"2023-03-28\" \"2023-02-16\" \"2022-12-28\"\n```\n:::\n:::\n\n:::\n\n## `map()` updates \n\nAs noted above, by default `purrr::map()` returns a list. If I'd like to return a vector, I can use one of the `map_` variations (there's one for each vector type). \n\n-   By mapping the `is.<type>()` functions the elements in `mixed_list`, I can test which elements in `mixed_list` return `TRUE`:\n\n    -   `map_lgl()`: returns a logical vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_lgl(\\(x) is.logical(x))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    booleans integers  doubles  strings    dates \n        TRUE    FALSE    FALSE    FALSE    FALSE \n    ```\n    :::\n    :::\n\n    :::\n\n    -   `map_int()`: returns an integer vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_int(\\(x) is.integer(x))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    booleans integers  doubles  strings    dates \n           0        1        0        0        0 \n    ```\n    :::\n    :::\n\n    :::\n\n    -   `map_dbl()`: returns a double vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_dbl(\\(x) is.double(x))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    booleans integers  doubles  strings    dates \n           0        0        1        0        1 \n    ```\n    :::\n    :::\n\n    :::\n\n    -   `map_chr()`: returns a character vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_chr(\\(x) is.character(x))\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    ```\n    Warning: Automatic coercion from logical to character was deprecated in purrr 1.0.0.\n    ℹ Please use an explicit call to `as.character()` within `map_chr()` instead.\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    booleans integers  doubles  strings    dates \n     \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\" \n    ```\n    :::\n    :::\n\n    :::\n    \nWhen we test for characters in `mixed_list`, we see the following warning:\n\n::: {style=\"font-size: 0.90em;\"}\n> `Warning: Automatic coercion from logical to character was deprecated in purrr`\n> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`\n:::\n\nAs we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).\n\n### `map_vec()`\n\n<br>\n\nHowever, the previous `purrr::map_raw()` function has been replaced with `purrr::map_vec()`, which \"*simplifies to the common type of the output.*\" I'll demonstrate below with the characters in `mixed_list`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list |> purrr::map_vec(\\(x) is.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE     TRUE    FALSE \n```\n:::\n:::\n\n:::\n\nNotice the difference in output?  The results are the same as above, but output is not commented (`##`). The same is true when I test the dates in `mixed_list` using `lubridate::is.Date()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list |> purrr::map_vec(\\(x) lubridate::is.Date(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE    FALSE     TRUE \n```\n:::\n:::\n\n:::\n\n## Anonymous functions\n\nR introduced the shorthand anonymous function syntax in version [4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html):\n\n> \"*`\\(x) x + 1` is parsed as `function(x) x + 1`.*\" \n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\n-   Standard anonymous function  \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (function(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"pirates ship\"\n    ```\n    :::\n    :::\n\n    :::\n\n-   The updated anonymous syntax is below:\n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (\\(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"pirates ship\"\n    ```\n    :::\n    :::\n\n    :::\n\nWriting the code above using an anonymous function would look like this:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"ring\"      \"regard\"    \"necessary\" \"yesterday\" \"income\"   \n\n$sentences\n[1] \"one step more and the board will collapse.\"\n[2] \"the bill was paid every third week.\"       \n[3] \"code is used when secrets are sent.\"       \n\n$letters\n [1] \"v\" \"a\" \"m\" \"d\" \"l\" \"r\" \"i\" \"h\" \"j\" \"c\"\n```\n:::\n:::\n\n:::\n\nAnonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* \n\nI'll confirm the outputs from both methods are identical using `waldo::compare()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(\\(x) tolower(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n:::: {.callout-important icon=false}\n## The formula (`~ .x + 1`)\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\nPrior to `purrr` v1.0.0, I could also use the formula syntax, but now it's \"*only recommended if you require backward compatibility with older versions of R.*\" I'll cover the formula syntax briefly because you're likely to encounter it. \n:::\n\n::: {style=\"font-size: 1.10em;\"}\nThe formula syntax is typically used with pipes, so the contents of `purrr::map()` become the right-hand side of the formula, with the function we want to iterate (`<FUNCTION>`) and a placeholder (`.x`) in the appropriate argument.\n:::\n\n::: {style=\"font-size: 1.20em;\"}\n```r\n<OBJECT> |> purrr::map(~ <FUNCTION>(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nFor the example above, `my_list` is 'piped' to `purrr::map()`, where the formula maps the `tolower()` function (using the `.x` placeholder).\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n```r\n# written as normal expression\n my_list |> purrr::map(~ tolower(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nJenny Bryan offers a great description on [her `purrr` tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), \n\n> \"*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*\"\n\nI can double-check to see that the output from two variations are identical using `waldo::compare()`.\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n::::\n\n\n\n<!--\n# map for `data.frame` and `tibble`s\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nswdata <- dplyr::select(dplyr::starwars, !where(is.list))\npurrr::map_df(.x = swdata, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 11\n   name     height mass  hair_color skin_color eye_color birth_year sex   gender\n   <chr>    <chr>  <chr> <chr>      <chr>      <chr>     <chr>      <chr> <chr> \n 1 luke sk… 172    77    blond      fair       blue      19         male  mascu…\n 2 c-3po    167    75    <NA>       gold       yellow    112        none  mascu…\n 3 r2-d2    96     32    <NA>       white, bl… red       33         none  mascu…\n 4 darth v… 202    136   none       white      yellow    41.9       male  mascu…\n 5 leia or… 150    49    brown      light      brown     19         fema… femin…\n 6 owen la… 178    120   brown, gr… light      blue      52         male  mascu…\n 7 beru wh… 165    75    brown      light      blue      47         fema… femin…\n 8 r5-d4    97     32    <NA>       white, red red       <NA>       none  mascu…\n 9 biggs d… 183    84    black      light      brown     24         male  mascu…\n10 obi-wan… 182    77    auburn, w… fair       blue-gray 57         male  mascu…\n# ℹ 77 more rows\n# ℹ 2 more variables: homeworld <chr>, species <chr>\n```\n:::\n:::\n\n:::\n-->\n\n# Worked Examples\n\nIn this section, I'll be working through some of the uses I've for `purrr`'s functions. I've tried to choose tasks that are common across *most* projects so my code can be easily copied and adapted. \n\n## Downloading files \n\n> *You'd like to download a collection of files from separate URLS*\n\nI have a collection of 30 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) in a [GitHub repo](https://github.com/mjfrigaard/dds-data). Let's assume I want to download all of these files into my RStudio session (and not clone the repo).\n\nI'll navigate to the raw url for the first data file (`nyt1.csv`), then paste this into a character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt_url <- \"https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n```\n:::\n\n:::\n\nKnowing that all of the files on GitHub with have a similar `root` or `dir`, I can use `nyt_url` to generate urls for each of the 31 files. \n\n1. First I get the folder of the files on GitHub with `fs::path_dir()` \n2. I create a vector with the 31 file names  \n3. I combine the directory portion of the url with file name in `nyt_file_urls`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# create file urls \nnyt_dir_url <- fs::path_dir(nyt_url)\nnyt_dir_url\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main\"\n```\n:::\n\n```{.r .cell-code}\n# add numbers to name\nnyt_file_nms <- paste0(\"nyt\", 1:31, \".csv\")\n# combine\nnyt_file_urls <- paste(nyt_dir_url, nyt_file_nms, sep = \"/\")\nhead(nyt_file_urls)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n[2] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt2.csv\"\n[3] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt3.csv\"\n[4] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt4.csv\"\n[5] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt5.csv\"\n[6] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt6.csv\"\n```\n:::\n:::\n\n:::\n\nI'll need another vector of destination file names on my local machine, which I can do by combining the file names (`nyt_file_nms`) with the local destination folder (`dds-nyt`).\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt_local_pths <- paste(\"dds-nyt\", nyt_file_nms, sep = \"/\")\nhead(nyt_local_pths)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dds-nyt/nyt1.csv\" \"dds-nyt/nyt2.csv\" \"dds-nyt/nyt3.csv\" \"dds-nyt/nyt4.csv\"\n[5] \"dds-nyt/nyt5.csv\" \"dds-nyt/nyt6.csv\"\n```\n:::\n:::\n\n:::\n\nAfter creating the destination folder, I'll use the `download.file()` function to test downloading a single `.csv` files into my local folder (`dds-nyt/`). `download.file()` has a progress bar which tells me if the file downloaded successfully. \n\n::: {style=\"font-size: 0.90em;\"}\n\n\n```{.r .cell-code}\n# do it for one\nfs::dir_create(\"dds-nyt\")\ndownload.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])\n```\n\n\n```bash\ntrying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'\nContent type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)\n==================================================\ndownloaded 4.7 MB\n```\n:::\n\n\n\nThe function I'm using to download the files takes two inputs (`url` and `destfile`), which changes the recipe a bit, because I need a `purrr` function with the following:\n\n1. `.x` the input vector of existing url paths \n\n2. `.y` the output vector of destination file paths \n\n3. Additional arguments passed from `download.file()` (like `quiet = TRUE`)\n\nIn this case, I don't need `purrr` to return value--I just need the `purrr` function to iterate over the items and write them to the new location.\n\n`walk()` is ideal for this circumstance:\n\n> \"*`walk()` returns the input `.x` (invisibly)*\" and \"*The return value of `.f()` is ignored*\"\n\n***What does 'return `.x` invisibly' and 'the side-effect of `.f`'***\n\n### Return invisibly \n\nThe previous `purrr` functions I covered varied in the kinds of values they returned (lists vs. vectors), but for some operations I won't need a return value. If I'm ever curious about whether I should be using `map()` or `walk()`, I'll ask myself, *\"would it make sense to assign the output from this function to an object?*\"\n\nIf the answer is no, then I probably need to be thinking `walk()` instead of `map()`\n\n### Side-effects \n\nIn the help documentation `walk()`'s description states, \"*calls .f for its side-effect*\"\n\n(i.e., there's nothing to assign the output from that function to).\n\nDownloading files performs \n\nI'll use `walk2()` below and add `.progress = TRUE` to view the `purrr` progress bar (and `quiet = TRUE` to silence the `download.file()` progress bar).  \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, \n  .progress = TRUE, quiet = TRUE)\n```\n:::\n\n:::\n\n<br>\n\n\n\n::: {.cell layout-align=\"center\" fig.dpi='320' fig.asp='0.618'}\n::: {.cell-output-display}\n![](purrr-progress.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n<!--fs::dir_tree(\"dds-nyt\")-->\n\n<br>\n\nI can confirm the download using `fs::dir_tree()`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_tree(\"dds-nyt\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndds-nyt\n├── nyt1.csv\n├── nyt10.csv\n├── nyt11.csv\n├── nyt12.csv\n├── nyt13.csv\n├── nyt14.csv\n├── nyt15.csv\n├── nyt16.csv\n├── nyt17.csv\n├── nyt18.csv\n├── nyt19.csv\n├── nyt2.csv\n├── nyt20.csv\n├── nyt21.csv\n├── nyt22.csv\n├── nyt23.csv\n├── nyt24.csv\n├── nyt25.csv\n├── nyt26.csv\n├── nyt27.csv\n├── nyt28.csv\n├── nyt29.csv\n├── nyt3.csv\n├── nyt30.csv\n├── nyt31.csv\n├── nyt4.csv\n├── nyt5.csv\n├── nyt6.csv\n├── nyt7.csv\n├── nyt8.csv\n└── nyt9.csv\n```\n:::\n:::\n\n:::\n\n\n## Copying a directory of files \n\n> *You have a folder of files you'd like to rename or copy to a new directory*\n\nThe collection of 31 .csv files from [Doing Data Science](https://github.com/oreillymedia/doing_data_science) by Cathy O'Neil and Rachel Schutt (O'Reilly Media) are now in the `dds-nyt/` folder. \n\nAs with any project, I don't want to alter the raw data, so I'm going to copy these files into `dds-nyt-raw/` and `dds-nyt-processed/`. I also want the processed file names to have a date stamp prefix. \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_pths <- list.files(\"dds-nyt\", full.names = TRUE, pattern = \".csv$\")\nhead(file_pths)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dds-nyt/nyt1.csv\"  \"dds-nyt/nyt10.csv\" \"dds-nyt/nyt11.csv\"\n[4] \"dds-nyt/nyt12.csv\" \"dds-nyt/nyt13.csv\" \"dds-nyt/nyt14.csv\"\n```\n:::\n:::\n\n:::\n\nI'll start with the raw data folder. I need to create a vector of the new raw file paths and names: `raw_file_pths` (the raw data paths will have the original file names)\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# do it for one\ngsub(pattern = \"^dds-nyt\",\n  replacement = \"dds-nyt/raw\",\n  x = file_pths[1])\n## [1] \"dds-nyt/raw/nyt1.csv\"\n\n# write the recipe\nfile_pths |> purrr::map_chr(\\(x) gsub(x, \n                                pattern = \"^dds-nyt\", \n                                replacement = \"dds-nyt/raw\")) |> head()\n## [1] \"dds-nyt/raw/nyt1.csv\"  \"dds-nyt/raw/nyt10.csv\" \"dds-nyt/raw/nyt11.csv\"\n## [4] \"dds-nyt/raw/nyt12.csv\" \"dds-nyt/raw/nyt13.csv\" \"dds-nyt/raw/nyt14.csv\"\n\n# map it across all\nraw_file_pths <- file_pths |> \n                  purrr::map_chr(\\(x) gsub(x, \n                                        pattern = \"^dds-nyt\", \n                                        replacement = \"dds-nyt/raw\"))\n```\n:::\n\n:::\n\nBefore copying the files, I need to create the destination folder for the raw data (`dds-nyt/raw`). Then, I'll make sure I can copy the first element from `file_pths` into the path in the first element of `raw_file_pths`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_create(\"dds-nyt/raw\")\n# do it for one\nfs::file_copy(\n  path = file_pths[1], \n  new_path = raw_file_pths[1], \n  overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndds-nyt/raw\n└── nyt1.csv\n```\n:::\n:::\n\n:::\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, \n      .progress = TRUE, overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndds-nyt/raw\n├── nyt1.csv\n├── nyt10.csv\n├── nyt11.csv\n├── nyt12.csv\n├── nyt13.csv\n├── nyt14.csv\n├── nyt15.csv\n├── nyt16.csv\n├── nyt17.csv\n├── nyt18.csv\n├── nyt19.csv\n├── nyt2.csv\n├── nyt20.csv\n├── nyt21.csv\n├── nyt22.csv\n├── nyt23.csv\n├── nyt24.csv\n├── nyt25.csv\n├── nyt26.csv\n├── nyt27.csv\n├── nyt28.csv\n├── nyt29.csv\n├── nyt3.csv\n├── nyt30.csv\n├── nyt31.csv\n├── nyt4.csv\n├── nyt5.csv\n├── nyt6.csv\n├── nyt7.csv\n├── nyt8.csv\n└── nyt9.csv\n```\n:::\n:::\n\n:::\n\nNow that I've copied the files into their respective folders, I'll need to remove the files from their original location in the parent `dds-nyt` folder.\n\nFortunately, I have a vector of these files in `file_pths`, and I can test removal with `fs::file_delete()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::file_delete(file_pths[1])\n```\n:::\n\n:::\n\nGreat! Now that I know this will work, I'll use `walk()` because I want `.x` returned invisibly and the side-effect of `.f`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk(.x = file_pths, .f = fs::file_delete)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `map()`:\nℹ In index: 1.\nCaused by error:\n! [ENOENT] Failed to remove 'dds-nyt/nyt1.csv': no such file or directory\n```\n:::\n:::\n\n:::\n\nWhy does this throw an error? Well--I've just deleted the first element in `file_pths`, so when `fs::file_delete()` when looking for that file, it found nothing and returned an error. I can protect against this by supplying the output from `list.files()` directly to `walk2()`, but include a `pattern` so it only matches the `.csv` files.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk(# list CURRENT files \n    .x = list.files(\n      path = \"dds-nyt\",\n      pattern = \".csv$\",\n      full.names = TRUE),\n    # map function\n    .f = fs::file_delete)\n```\n:::\n\n:::\n\n\nAnd confirm the new folder contents and structure\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_tree(\"dds-nyt\", type = \"any\", recurse = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndds-nyt\n└── raw\n    ├── nyt1.csv\n    ├── nyt10.csv\n    ├── nyt11.csv\n    ├── nyt12.csv\n    ├── nyt13.csv\n    ├── nyt14.csv\n    ├── nyt15.csv\n    ├── nyt16.csv\n    ├── nyt17.csv\n    ├── nyt18.csv\n    ├── nyt19.csv\n    ├── nyt2.csv\n    ├── nyt20.csv\n    ├── nyt21.csv\n    ├── nyt22.csv\n    ├── nyt23.csv\n    ├── nyt24.csv\n    ├── nyt25.csv\n    ├── nyt26.csv\n    ├── nyt27.csv\n    ├── nyt28.csv\n    ├── nyt29.csv\n    ├── nyt3.csv\n    ├── nyt30.csv\n    ├── nyt31.csv\n    ├── nyt4.csv\n    ├── nyt5.csv\n    ├── nyt6.csv\n    ├── nyt7.csv\n    ├── nyt8.csv\n    └── nyt9.csv\n```\n:::\n:::\n\n:::\n\n\n## Import multiple datasets \n\n> *You have several days of data, and each day is contained in separate file. You'd like to read these data into R, and combine them into a single dataset*\n\nNow that I have separate raw and processed folders, I can import the NYT data into R. Below I've imported a single file from the `raw` data folder to examine it's contents:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt1 <- vroom::vroom(\n  \"dds-nyt/raw/nyt1.csv\", \n  delim = \",\", \n  show_col_types = FALSE)\nstr(nyt1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspc_tbl_ [458,441 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n $ Gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n $ Impressions: num [1:458441] 3 3 3 3 11 11 7 5 3 4 ...\n $ Clicks     : num [1:458441] 0 0 0 0 0 1 1 0 0 0 ...\n $ Signed_In  : num [1:458441] 1 1 1 1 1 1 0 1 1 1 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Age = col_double(),\n  ..   Gender = col_double(),\n  ..   Impressions = col_double(),\n  ..   Clicks = col_double(),\n  ..   Signed_In = col_double(),\n  ..   .delim = \",\"\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n:::\n:::\n\n:::\n\nEach `nyt` file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: `Age`, `Gender` (0 = female, 1 = male), `Impressions` (number impressions), `Clicks` (number clicks), and a binary indicator for signed in or not `Signed_in`. \n\nI'll add some hypothetical wrangling steps to make this example more realistic.\n\n  1. Create `age_group`, an ordered factor which contains six levels of Age (\"<18\", \"18-24\", \"25-34\", \"35-44\", \"45-54\", \"55-64\", and \"65+\")\n\n  2. Create `ctr_rate` or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.\n\n  3. Create `female`, a factor version of `Gender`, where when `Gender` = `0`, then `female` = `\"yes\"`, and when `Gender` = `1`, then `female` = `\"no\"` \n\n  4. Create `signed_in`, a factor variable with levels `\"no\"` and `\"yes\"` from the `Signed_In` = `0` and `1`\n\nI've bundled all of these steps into a function (`nyt_data_processing()`) that I can pass each dataset through:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnyt_data_processing <- function(nyt_csv) {\n  orig_nms <- c(\"Age\", \"Gender\", \"Impressions\", \"Clicks\", \"Signed_In\")\n  nyt_nms <- names(nyt_csv)\n  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {\n    cli::cli_abort(\"these data don't have the correct columns!\")\n  } else {\n    nyt_proc <- nyt_csv |> \n      dplyr::mutate(\n        # create age_group variable\n          age_group = case_when( \n              Age < 18 ~ \"<18\",\n              Age >= 18 & Age < 25 ~ \"18-24\",\n              Age >= 25 & Age < 35 ~ \"25-34\",\n              Age >= 35 & Age < 45 ~ \"35-44\",\n              Age >= 45 & Age < 55 ~ \"45-54\",\n              Age >= 55 & Age < 65 ~ \"55-64\",\n              Age >= 65 ~ \"65+\"), \n        # factor age_group (ordered)\n          age_group = factor(age_group, \n            levels = c(\"<18\", \"18-24\", \"25-34\",\n              \"35-44\", \"45-54\", \"55-64\", \"65+\"), \n            ordered = TRUE),\n        # create CTR variable\n          ctr_rate = round(x = Clicks/Impressions, digits = 3),\n        # create new Female variable\n          female = case_when( \n              Gender == 0 ~ \"yes\", \n              Gender == 1 ~ \"no\",\n              TRUE ~ NA_character_),\n        # factor female (un-ordered)\n          female = factor(female, \n            levels = c(\"no\", \"yes\")),\n          signed_in = case_when( \n              Signed_In == 0 ~ \"no\", \n              Signed_In == 1 ~ \"yes\",\n              TRUE ~ NA_character_),\n        # factor signed_in (un-ordered)\n          signed_in = factor(signed_in, \n            levels = c(\"no\", \"yes\"))) |> \n    # remove Signed_in\n    dplyr::select(-c(Signed_In)) |> \n    # format columns\n    janitor::clean_names() \n  \n  }\n  return(nyt_proc)\n}\n```\n:::\n\n:::\n\nI'll do some quick checks to make sure it only works with the raw data columns:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt1_proc <- nyt_data_processing(nyt1)\nstr(nyt1_proc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspc_tbl_ [458,441 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n $ gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n $ impressions: num [1:458441] 3 3 3 3 11 11 7 5 3 4 ...\n $ clicks     : num [1:458441] 0 0 0 0 0 1 1 0 0 0 ...\n $ age_group  : Ord.factor w/ 7 levels \"<18\"<\"18-24\"<..: 4 7 3 5 5 5 1 5 1 5 ...\n $ ctr_rate   : num [1:458441] 0 0 0 0 0 0.091 0.143 0 0 0 ...\n $ female     : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 1 1 2 2 2 2 2 ...\n $ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 2 2 2 2 2 1 2 2 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Age = col_double(),\n  ..   Gender = col_double(),\n  ..   Impressions = col_double(),\n  ..   Clicks = col_double(),\n  ..   Signed_In = col_double(),\n  ..   .delim = \",\"\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n:::\n:::\n\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt_data_processing(nyt1_proc)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `nyt_data_processing()`:\n! these data don't have the correct columns!\n```\n:::\n:::\n\n:::\n\nNow I'm ready to write the import step. First I'll store the raw file paths in `raw_data_pths`, then take a subset to test with (`test_raw_data_pths`).\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_data_pths <- list.files(path = \"dds-nyt/raw\", pattern = \".csv$\", full.names = TRUE)\ntest_raw_data_pths <- raw_data_pths[1:2]\ntest_raw_data_pths\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dds-nyt/raw/nyt1.csv\"  \"dds-nyt/raw/nyt10.csv\"\n```\n:::\n:::\n\n:::\n\nWe'll test `purrr::map()` and `vroom::vroom()` to import the `.csv` files in `test_raw_data_pths` into a list. I also add `str(list.len = 2)` to limit the output.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_raw_data_pths |> \n  # import\n  purrr::map(\n    vroom::vroom, \n        delim = \",\", show_col_types = FALSE) |> \n  str(list.len = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : spc_tbl_ [458,441 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n  ..$ Gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n $ : spc_tbl_ [452,766 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n  ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n```\n:::\n:::\n\n:::\n\nThis returns a list, but you may have noticed I don't have a great way for keeping track of the data files in the list--this is where `purrr::set_names()` comes in handy. \n\n`purrr::set_names()` works a lot like `names()`, but `purrr::set_names()` will automatically set the names of `x` to `as.character(x)` is no names are provided to `nm`. See below:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_raw_data_pths |> purrr::set_names()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   dds-nyt/raw/nyt1.csv   dds-nyt/raw/nyt10.csv \n \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt10.csv\" \n```\n:::\n:::\n\n:::\n\nNow the imported file will have their file path and name associated with the dataset:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import  \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  str(list.len = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ dds-nyt/raw/nyt1.csv : spc_tbl_ [458,441 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n  ..$ Gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n  ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n```\n:::\n:::\n\n:::\n\nTo add the wrangling function, I can pipe in another call to `purrr::map()`, and add the custom wrangling function. \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  str(list.len = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ dds-nyt/raw/nyt1.csv : spc_tbl_ [458,441 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n  ..$ gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n  ..$ gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n```\n:::\n:::\n\n:::\n\n\nFor the final step, I'll bind all the data into a `data.frame` with the updated `purrr::list_rbind()` function (set `names_to = \"id\"`).\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") |> \n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [911,207 × 9] (S3: tbl_df/tbl/data.frame)\n $ id         : chr [1:911207] \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt1.csv\" ...\n $ age        : num [1:911207] 36 73 30 49 47 47 0 46 16 52 ...\n $ gender     : num [1:911207] 0 1 0 1 1 0 0 0 0 0 ...\n $ impressions: num [1:911207] 3 3 3 3 11 11 7 5 3 4 ...\n $ clicks     : num [1:911207] 0 0 0 0 0 1 1 0 0 0 ...\n $ age_group  : Ord.factor w/ 7 levels \"<18\"<\"18-24\"<..: 4 7 3 5 5 5 1 5 1 5 ...\n $ ctr_rate   : num [1:911207] 0 0 0 0 0 0.091 0.143 0 0 0 ...\n $ female     : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 1 1 2 2 2 2 2 ...\n $ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 2 2 2 2 2 1 2 2 2 ...\n```\n:::\n:::\n\n:::\n\nNow that we have a complete recipe, so all I do is swap out test vector with the full list of file paths and store the result in `nyt_data_proc`. I can also confirm all files were imported and wrangled by checking the `count()` of id.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt_data_proc <- raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(nyt_data_proc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 14,905,865\nColumns: 9\n$ id          <chr> \"dds-nyt/raw/nyt1.csv\", \"dds-nyt/raw/nyt1.csv\", \"dds-nyt/r…\n$ age         <dbl> 36, 73, 30, 49, 47, 47, 0, 46, 16, 52, 0, 21, 0, 57, 31, 0…\n$ gender      <dbl> 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0…\n$ impressions <dbl> 3, 3, 3, 3, 11, 11, 7, 5, 3, 4, 8, 3, 4, 6, 5, 6, 3, 5, 4,…\n$ clicks      <dbl> 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ age_group   <ord> 35-44, 65+, 25-34, 45-54, 45-54, 45-54, <18, 45-54, <18, 4…\n$ ctr_rate    <dbl> 0.000, 0.000, 0.000, 0.000, 0.000, 0.091, 0.143, 0.000, 0.…\n$ female      <fct> yes, no, yes, no, no, yes, yes, yes, yes, yes, yes, yes, y…\n$ signed_in   <fct> yes, yes, yes, yes, yes, yes, no, yes, yes, yes, no, yes, …\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt_data_proc |> \n  dplyr::count(id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 31 × 2\n   id                         n\n   <chr>                  <int>\n 1 dds-nyt/raw/nyt1.csv  458441\n 2 dds-nyt/raw/nyt10.csv 452766\n 3 dds-nyt/raw/nyt11.csv 478066\n 4 dds-nyt/raw/nyt12.csv 396308\n 5 dds-nyt/raw/nyt13.csv 786044\n 6 dds-nyt/raw/nyt14.csv 440338\n 7 dds-nyt/raw/nyt15.csv 437567\n 8 dds-nyt/raw/nyt16.csv 448917\n 9 dds-nyt/raw/nyt17.csv 445228\n10 dds-nyt/raw/nyt18.csv 451763\n# ℹ 21 more rows\n```\n:::\n:::\n\n:::\n\n## Export multiple datasets \n\n> *You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths*\n\nNow I have a processed dataset, and I want to export this into a `dds-nyt/processed/` folder. \n\nCreating a vector of processed data file paths is a little more involved because I wanted to add the date prefix, and because I want to add this path as a variable in the `nyt_data_proc` dataset. \n\nI do this below in `proc_file_pth`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# create file names \nnyt_data_proc_pths <- dplyr::mutate(.data = nyt_data_proc,\n        file_nm = tools::file_path_sans_ext(base::basename(id)),\n        proc_file_pth = paste0(\"dds-nyt/processed/\", \n                        as.character(Sys.Date()), \"-\", \n                        file_nm))\nnyt_data_proc_pths |> dplyr::count(proc_file_pth)\n## # A tibble: 31 × 2\n##    proc_file_pth                           n\n##    <chr>                               <int>\n##  1 dds-nyt/processed/2023-04-07-nyt1  458441\n##  2 dds-nyt/processed/2023-04-07-nyt10 452766\n##  3 dds-nyt/processed/2023-04-07-nyt11 478066\n##  4 dds-nyt/processed/2023-04-07-nyt12 396308\n##  5 dds-nyt/processed/2023-04-07-nyt13 786044\n##  6 dds-nyt/processed/2023-04-07-nyt14 440338\n##  7 dds-nyt/processed/2023-04-07-nyt15 437567\n##  8 dds-nyt/processed/2023-04-07-nyt16 448917\n##  9 dds-nyt/processed/2023-04-07-nyt17 445228\n## 10 dds-nyt/processed/2023-04-07-nyt18 451763\n## # ℹ 21 more rows\n```\n:::\n\n:::\n\nNote that I didn't include the file extension, but that's because I might want to change this when I'm exporting. \n\nNow that I have my data (`nyt_data_proc_pths`) and processed file paths (`proc_file_pth`), I need create the processed data folder, then group `nyt_data_proc_pths` on the new `proc_file_pth` variable, and then pass the output to the `group_walk()` function from `dplyr`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# create file names \n# create folder \nfs::dir_create(\"dds-nyt/processed/\")\n# \nnyt_data_proc_pths |>  \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk( ~vroom::vroom_write(x = .x, \n                          file = paste0(.y$proc_file_pth, \".csv\"),\n                          delim = \",\"))\n# check\nfs::dir_tree(\"dds-nyt/processed/\")\n## dds-nyt/processed/\n## ├── 2023-04-07-nyt1.csv\n## ├── 2023-04-07-nyt10.csv\n## ├── 2023-04-07-nyt11.csv\n## ├── 2023-04-07-nyt12.csv\n## ├── 2023-04-07-nyt13.csv\n## ├── 2023-04-07-nyt14.csv\n## ├── 2023-04-07-nyt15.csv\n## ├── 2023-04-07-nyt16.csv\n## ├── 2023-04-07-nyt17.csv\n## ├── 2023-04-07-nyt18.csv\n## ├── 2023-04-07-nyt19.csv\n## ├── 2023-04-07-nyt2.csv\n## ├── 2023-04-07-nyt20.csv\n## ├── 2023-04-07-nyt21.csv\n## ├── 2023-04-07-nyt22.csv\n## ├── 2023-04-07-nyt23.csv\n## ├── 2023-04-07-nyt24.csv\n## ├── 2023-04-07-nyt25.csv\n## ├── 2023-04-07-nyt26.csv\n## ├── 2023-04-07-nyt27.csv\n## ├── 2023-04-07-nyt28.csv\n## ├── 2023-04-07-nyt29.csv\n## ├── 2023-04-07-nyt3.csv\n## ├── 2023-04-07-nyt30.csv\n## ├── 2023-04-07-nyt31.csv\n## ├── 2023-04-07-nyt4.csv\n## ├── 2023-04-07-nyt5.csv\n## ├── 2023-04-07-nyt6.csv\n## ├── 2023-04-07-nyt7.csv\n## ├── 2023-04-07-nyt8.csv\n## └── 2023-04-07-nyt9.csv\n```\n:::\n\n:::\n\nI'll import the first file in the new processed data folder and check it against the `nyt1_proc` data to evaluate the differences.  \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nnyt1_proc_check <- vroom::vroom(\n  list.files(path = \"dds-nyt/processed\", \n                    pattern = \".csv$\", \n        full.names = TRUE)[[1]], # grab the first file\n   delim = \",\", show_col_types = FALSE\n  )\n```\n:::\n\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = nyt1_proc,\n  y = nyt1_proc_check)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n`old` is length 8\n`new` is length 10\n\n    names(old)    | names(new)        \n[1] \"age\"         - \"id\"          [1] \n[2] \"gender\"      - \"age\"         [2] \n[3] \"impressions\" - \"gender\"      [3] \n[4] \"clicks\"      - \"impressions\" [4] \n[5] \"age_group\"   - \"clicks\"      [5] \n[6] \"ctr_rate\"    - \"age_group\"   [6] \n[7] \"female\"      - \"ctr_rate\"    [7] \n[8] \"signed_in\"   - \"female\"      [8] \n                  - \"signed_in\"   [9] \n                  - \"file_nm\"     [10]\n\n`old$age_group` is an S3 object of class <ordered/factor>, an integer vector\n`new$age_group` is a character vector ('35-44', '65+', '25-34', '45-54', '45-54', ...)\n\n`old$female` is an S3 object of class <factor>, an integer vector\n`new$female` is a character vector ('yes', 'no', 'yes', 'no', 'no', ...)\n\n`old$signed_in` is an S3 object of class <factor>, an integer vector\n`new$signed_in` is a character vector ('yes', 'yes', 'yes', 'yes', 'yes', ...)\n\n`old$id` is absent\n`new$id` is a character vector ('dds-nyt/raw/nyt1.csv', 'dds-nyt/raw/nyt1.csv', 'dds-nyt/raw/nyt1.csv', 'dds-nyt/raw/nyt1.csv', 'dds-nyt/raw/nyt1.csv', ...)\n\n`old$file_nm` is absent\n`new$file_nm` is a character vector ('nyt1', 'nyt1', 'nyt1', 'nyt1', 'nyt1', ...)\n```\n:::\n:::\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n:::: {.callout-tip icon=false}\n## REACP: `purrr` syntax variations\n\n::: {style=\"font-size: 1.25em;\"}\n**Standard**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# define .x and .f\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Anonymous function**\n:::\n\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# anonymous shorthand notation\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Formula (deprecated)**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as normal expression\nmy_list |> purrr::map(~ tolower(.x))\n```\n:::\n::::\n\n\nFor more information check out the [iteration chapter in R for Data Science](https://r4ds.had.co.nz/iteration.html).  ",
    "supporting": [
      "purrr101_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}