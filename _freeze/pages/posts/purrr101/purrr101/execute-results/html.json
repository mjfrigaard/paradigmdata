{
  "hash": "b8cbd3cfd48248933ee9460e2c04c69a",
  "result": {
    "markdown": "---\ntitle: \"purrr updates (v1.0.0)\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-04-05\"\nimage: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n\nfig-align: center\ncode-link: true\nfontsize: '11'\n\ncallout-icon: false\ncallout-appearance: default\n\nfreeze: true\n\nexecute:\n  echo: true\n  warning: false\n  eval: true\n---\n\n\n\n\n<!--\nhttps://mjfrigaard.github.io/posts/vanilla-shiny/\n\nhttps://mjfrigaard.github.io/posts/my-pkg-app/\n\nhttps://mjfrigaard.github.io/posts/my-golem-app/\n\nhttps://mjfrigaard.github.io/posts/my-leprechaun-app/\n\nhttps://mjfrigaard.github.io/posts/my-rhino-app/\n-->\n\n\n\n:::: {.callout-important collapse='false'}\n\n## ALERT!\n\n::: {style='font-size: 0.90em; color: #696969;'}\n\n**This post is currently under development. Thank you for your patience.**\n\n::: \n\n::::\n\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(sloop)\n```\n:::\n\n:::\n\nThis post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/) (\"*a complete and consistent set of tools for working with functions and vectors*\"). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I've always found to be a great time for a refresher!\n\n# REFRESHER: Functions and objects \n\nIf you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.\n\nIn a functional programming language like R, it's nice when we can have functions perform a lot of the work we'd have to write into a `for` loop. \n\n## Generic functions\n\nR's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` function is an S3 generic function: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::ftype(plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n:::\n\n:::\n\nWhich means `plot()` can be applied to a `ts` (Time-Series) object or a standard `data.frame`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(datasets::LakeHuron)\n```\n\n::: {.cell-output-display}\n![Time-series plot](purrr101_files/figure-html/chickwts-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(datasets::chickwts)\n```\n\n::: {.cell-output-display}\n![Scatter Plot](purrr101_files/figure-html/chickwts-2.png){width=672}\n:::\n:::\n\n:::\n\n`summary()` is also generic--we can apply this function to individual data objects, model outputs, etc.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::ftype(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n:::\n\n:::\n\n`plot()` and `summary()` are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it. \n\n::: {style=\"font-size: 0.90em; color: #696969;\"}\n*Click **Code** below to view an example using `summary()`*\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output  -------------------------------------------------------\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept) 30.09886    1.63392  18.421  < 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024,\tAdjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(>|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07\n```\n:::\n\n:::\n\nAs you can see, generic functions are flexible and efficient because we're not having to define a new function for each object--the output from the function depends (in part) on the structure of the object.\n\n> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition\n\nThe relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving common problems programmers encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.\n\n## Iteration problems \n\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: \n\n  1. You have a folder full of files you'd like to rename or copy to a new directory   \n\n  2. You'd like to download a collection of files from separate URLS  \n\n  3. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset\n\n  4. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. \n\nThese are all problems I've personally encountered that required a variety of iteration tools to tackle. But I'll start with a simple example because the principles remain the same (regardless of the size/scope of the problem):\n\n  5. I have a list of character strings and I'd like to convert the case of the text\n\nIt just so happens I have such a list (`my_list`), with items in various cases. \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list\n## $words\n## [1] \"obvioUs\" \"waSH\"    \"Side\"    \"Sex\"     \"word\"   \n## \n## $sentences\n## [1] \"ThEy SlIce thE sAUsage tHiN WITh a kNIfE.\"\n## [2] \"Feed tHE WhiTe MOUsE soMe FLoWeR sEedS.\"  \n## [3] \"the sMeLL of burnEd RaGS itCheS my NosE.\" \n## \n## $letters\n##  [1] \"Z\" \"h\" \"j\" \"v\" \"o\" \"p\" \"d\" \"c\" \"x\" \"l\"\n```\n:::\n\n:::\n\nIf I try to use the `tolower()` on `my_list`, it returns a vector.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(my_list) |> str()\n##  chr [1:3] \"c(\\\"obvious\\\", \\\"wash\\\", \\\"side\\\", \\\"sex\\\", \\\"word\\\")\" ...\n```\n:::\n\n:::\n\nHow can I apply the `tolower()` function to each item in `my_list` (and return the original object type)?\n\n# The `for` loop\n\n`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: \n\n> \"*for each `item` in `object`, do `operation`*\"\n\nI'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:\n\n-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'\n\n      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`)\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    seq_along(my_list)\n    ## [1] 1 2 3\n    # take single value of 'x'\n    seq_along(my_list)[1]\n    ## [1] 1\n    # use this to get 'items in object'\n    my_list[[seq_along(my_list)[1]]]\n    ## [1] \"obvioUs\" \"waSH\"    \"Side\"    \"Sex\"     \"word\"\n    ```\n    :::\n\n    \n-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)\n\n    - Test this with a few values if you like\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    tolower(my_list[[2]])\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"they slice the sausage thin with a knife.\"\n    [2] \"feed the white mouse some flower seeds.\"  \n    [3] \"the smell of burned rags itches my nose.\" \n    ```\n    :::\n    :::\n\n\n-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size\n\n    - Creating empty lists  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vector(mode = \"list\", length = 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    NULL\n    \n    [[2]]\n    NULL\n    \n    [[3]]\n    NULL\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    list(NULL, NULL, NULL)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    NULL\n    \n    [[2]]\n    NULL\n    \n    [[3]]\n    NULL\n    ```\n    :::\n    :::\n\n\nFinally, we put it all together in a `for` loop\n\n::: {style=\"font-size: 1.0em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# define capture object\nlc_list <- vector(mode = \"list\", length = 3)\n# write sequence\nfor (x in seq_along(my_list)) {        \n  # write operations/capture in object\n  lc_list[[x]] <- tolower(my_list[[x]])\n  # clean up container\n  names(lc_list) <- c(\"words\", \"sentences\", \"letters\")\n}\nlc_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"obvious\" \"wash\"    \"side\"    \"sex\"     \"word\"   \n\n$sentences\n[1] \"they slice the sausage thin with a knife.\"\n[2] \"feed the white mouse some flower seeds.\"  \n[3] \"the smell of burned rags itches my nose.\" \n\n$letters\n [1] \"z\" \"h\" \"j\" \"v\" \"o\" \"p\" \"d\" \"c\" \"x\" \"l\"\n```\n:::\n:::\n\n:::\n\nThis was a simple example, but it demonstrates the basic components in a `for` loop: \n\n1. The sequence to index \n    - `for (x in seq_along(my_list))`  \n2. The operations to iterate   \n    - `tolower(my_list[[x]])`   \n3. The object to capture the results  \n    - `lc_list <- vector(mode = \"list\", length = 3)` and  \n    - `lc_list[[x]]`\n  \n# Base R\n\nThe family of functions `apply` functions from base R (`apply()`, `tapply()`, `sapply()`, `lapply()`) take advantage of R's functional programming and remove a lot of the 'book keeping' code we have to write in `for` loops. \n\nThe function I want for the example above is `lapply()` (pronounced 'l-apply', and the `l` stands for list). There are only two required arguments: `X` and `FUN`, with `X` being the object we want to iterate over, and `FUN` being the function we want iterated:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X = my_list, FUN = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"obvious\" \"wash\"    \"side\"    \"sex\"     \"word\"   \n\n$sentences\n[1] \"they slice the sausage thin with a knife.\"\n[2] \"feed the white mouse some flower seeds.\"  \n[3] \"the smell of burned rags itches my nose.\" \n\n$letters\n [1] \"z\" \"h\" \"j\" \"v\" \"o\" \"p\" \"d\" \"c\" \"x\" \"l\"\n```\n:::\n:::\n\n\nHowever, the `apply` functions have minor differences in how they are used. \n\n# `purrr`\n\nIf you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)\n\n1. Do it for one element\n\n2. Turn it into a recipe\n\n3. Use `purrr::map()` to do it for all elements\n\nI'll work through these three steps below using `my_list` and `tolower()`\n\n## 1. Do it for one element\n\nThe goal with this first step is to get a minimal working example with a single element from the object I want to use (and the function I want to iterate).\n\n::: {style=\"font-size: 0.90em;\"}\n```r\n# subset an element from the list\n_____ <- my_list[[?]]\n# apply a function to extracted element\ntolower(_____)\n```\n:::\n\n- `_____ <- my_list[[?]]` = subsetted element (`?`) from a list (`my_list`)\n\n- `tolower(_____)` = apply operation (i.e., function) to apply across extracted element.\n\nIn this case, I'll subset `my_list` for a single element (`words`, `sentences`, or `letters`) so I can use it with `tolower()`. I'll start with the `words` vector in `my_list`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- my_list[['words']]\ntolower(my_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"obvious\" \"wash\"    \"side\"    \"sex\"     \"word\"   \n```\n:::\n:::\n\n:::\n\nNow that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.\n\n## 2. Turn it into a recipe\n\nA standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.\n\n- `.x` =  a list or atomic vector \n\n- `.f` = the function we want to apply over every element in `.x`\n\n::: {style=\"font-size: .90em;\"}\n```r\n.x = my_list, .f = tolower\n```\n:::\n\n## 3. `map()` it across all elements\n\nIn `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` \n\nFor example, if I want to convert the case of every element in my_list to lowercase with `tolower`, I would use the following standard `purrr::map()` format:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(.x = my_list, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"obvious\" \"wash\"    \"side\"    \"sex\"     \"word\"   \n\n$sentences\n[1] \"they slice the sausage thin with a knife.\"\n[2] \"feed the white mouse some flower seeds.\"  \n[3] \"the smell of burned rags itches my nose.\" \n\n$letters\n [1] \"z\" \"h\" \"j\" \"v\" \"o\" \"p\" \"d\" \"c\" \"x\" \"l\"\n```\n:::\n:::\n\n:::\n\nAnd there you have it--iteration in a single line of code! `purrr::map()` is identical to `lapply()` in this example, but it's important to note that `purrr::map()` always returns a list (regardless of the object supplied to `.x`).\n\n# Updates in version 1.0.0\n\nNow I'll cover some of the updates in purrr 1.0.0 (using the examples above).\n\n## Anonymous functions\n\nAs of [R 4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html), new anonymous functions have been added. \n\n> \"*R now provides a shorthand notation for creating functions, e.g. `\\(x) x + 1` is parsed as `function(x) x + 1`.*\" \n\n**Anonymous function syntax:**\n\n::: {style=\"font-size: 0.90em;\"}\n```r\n# written as an anonymous function\n\\(x) tolower(x)\n```\n:::\n\nBelow is a comparison of R's anonymous (unnamed) function and the updated shorthand syntax:\n\n-   Standard anonymous function  \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (function(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"pirates ship\"\n    ```\n    :::\n    :::\n\n    :::\n\n-   The updated anonymous syntax is below:\n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (\\(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"pirates ship\"\n    ```\n    :::\n    :::\n\n    :::\n\nWriting the code above using an anonymous function would look like this:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"obvious\" \"wash\"    \"side\"    \"sex\"     \"word\"   \n\n$sentences\n[1] \"they slice the sausage thin with a knife.\"\n[2] \"feed the white mouse some flower seeds.\"  \n[3] \"the smell of burned rags itches my nose.\" \n\n$letters\n [1] \"z\" \"h\" \"j\" \"v\" \"o\" \"p\" \"d\" \"c\" \"x\" \"l\"\n```\n:::\n:::\n\n:::\n\nAnonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* \n\nI'll confirm the outputs from both methods are identical using `waldo::compare()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(\\(x) tolower(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n:::: {.callout-important icon=false}\n## Formula syntax \n\nPrior to `purrr` v1.0.0, I could also use the formula syntax:\n\n**Formula syntax:**\n\nThe formula syntax can take some getting used to, but Jenny Bryan offers some great advice on [her tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), \n\n> \"*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*\"\n\n::: {style=\"font-size: 1.0em;\"}\n```r\n# written as normal expression\n ~ tolower(.x)\n```\n:::\n\n- `~ function()` read as '*map this function*'\n\n- `.x` = `purrr`'s placeholder for one element of our object (\"*must use `.x` to refer to the first argument. Only recommended if you require backward compatibility with older versions of R.*\")\n\n::::\n\nI can double-check to see that the output from two variations are identical using `waldo::compare()`.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n## `map()` updates \n\n`map()` is the core function and workhorse of the `purrr` package. However, as noted above, by default `map()` returns a list. Fortunately there are `map_` variations for each vector type. \n\nI'll demonstrate them below using the `mixed_list` object, which has five vectors. \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$booleans\n[1]  TRUE FALSE  TRUE FALSE\n\n$integers\n[1] 10  1  8  4  7\n\n$doubles\n[1] 2.839 2.942 3.041 3.209 2.882\n\n$strings\n[1] \"programme\" \"ball\"      \"practise\"  \"staff\"     \"forget\"   \n\n$dates\n[1] \"2023-03-26\" \"2023-02-14\" \"2022-12-26\"\n```\n:::\n:::\n\n:::\n\n-   `map_lgl()`: returns a logical vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_lgl(\\(x) is.logical(x))\n    ## booleans integers  doubles  strings    dates \n    ##     TRUE    FALSE    FALSE    FALSE    FALSE\n    ```\n    :::\n\n    :::\n\n-   `map_int()`: returns an integer vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_int(\\(x) is.integer(x))\n    ## booleans integers  doubles  strings    dates \n    ##        0        1        0        0        0\n    ```\n    :::\n\n    :::\n\n-   `map_dbl()`: returns a double vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_dbl(\\(x) is.double(x))\n    ## booleans integers  doubles  strings    dates \n    ##        0        0        1        0        1\n    ```\n    :::\n\n    :::\n\n-   `map_chr()`: returns a character vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_chr(\\(x) is.character(x))\n    ## booleans integers  doubles  strings    dates \n    ##  \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\"\n    ```\n    :::\n\n    :::\n    \nWhen we test for characters in `mixed_list`, we see the following warning:\n\n::: {style=\"font-size: 0.90em;\"}\n> `Warning: Automatic coercion from logical to character was deprecated in purrr`\n> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`\n:::\n\nAs we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).\n\n### `map_vec()`\n\nHowever, the previous `map_raw()` function has been replaced with `map_vec()`, which I demonstrate below with the dates in `mixed_list` (testing for `is.character`):\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list |> purrr::map_vec(\\(x) is.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE     TRUE    FALSE \n```\n:::\n:::\n\n:::\n\nNotice the difference in output? This is because `map_vec()` \"*simplifies to the common type of the output*\", which comes in handy for objects like dates: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list |> purrr::map_vec(\\(x) lubridate::is.Date(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE    FALSE     TRUE \n```\n:::\n:::\n\n:::\n\n<!--\n# map for `data.frame` and `tibble`s\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nswdata <- dplyr::select(dplyr::starwars, !where(is.list))\npurrr::map_df(.x = swdata, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 11\n   name     height mass  hair_color skin_color eye_color birth_year sex   gender\n   <chr>    <chr>  <chr> <chr>      <chr>      <chr>     <chr>      <chr> <chr> \n 1 luke sk… 172    77    blond      fair       blue      19         male  mascu…\n 2 c-3po    167    75    <NA>       gold       yellow    112        none  mascu…\n 3 r2-d2    96     32    <NA>       white, bl… red       33         none  mascu…\n 4 darth v… 202    136   none       white      yellow    41.9       male  mascu…\n 5 leia or… 150    49    brown      light      brown     19         fema… femin…\n 6 owen la… 178    120   brown, gr… light      blue      52         male  mascu…\n 7 beru wh… 165    75    brown      light      blue      47         fema… femin…\n 8 r5-d4    97     32    <NA>       white, red red       <NA>       none  mascu…\n 9 biggs d… 183    84    black      light      brown     24         male  mascu…\n10 obi-wan… 182    77    auburn, w… fair       blue-gray 57         male  mascu…\n# ℹ 77 more rows\n# ℹ 2 more variables: homeworld <chr>, species <chr>\n```\n:::\n:::\n\n:::\n-->\n\n# Worked Examples\n\n## Copying a directory of files \n\n> *You have a folder full of files you'd like to rename or copy to a new directory*\n\n## Downloading files \n\n> *You'd like to download a collection of files from separate URLS*\n  \n## Import multiple datasets \n\n> *You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset*\n\n## Export multiple datasets \n\n> *You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths* \n\n\n\n\n\n:::: {.callout-tip icon=false}\n## REACP: `purrr` syntax variations\n\n::: {style=\"font-size: 1.25em;\"}\n**Standard**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# define .x and .f\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Anonymous function**\n:::\n\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# anonymous shorthand notation\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Formula**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as normal expression\nmy_list |> purrr::map(~ tolower(.x))\n```\n:::\n::::\n\n\nFor more information check out the [iteration chapter in R for Data Science](https://r4ds.had.co.nz/iteration.html).  ",
    "supporting": [
      "purrr101_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}