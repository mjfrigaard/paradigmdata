{
  "hash": "4c70212859c627dd63391f7887e7ffe8",
  "result": {
    "markdown": "---\ntitle: \"purrr updates (v1.0.0)\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-04-05\"\nimage: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n\nfig-align: center\ncode-link: true\nfontsize: '11'\n\ncallout-icon: false\ncallout-appearance: default\n\nfreeze: true\n\nexecute:\n  echo: true\n  warning: false\n  eval: true\n  collapse: true\n---\n\n\n\n\n<!--\nhttps://mjfrigaard.github.io/posts/vanilla-shiny/\n\nhttps://mjfrigaard.github.io/posts/my-pkg-app/\n\nhttps://mjfrigaard.github.io/posts/my-golem-app/\n\nhttps://mjfrigaard.github.io/posts/my-leprechaun-app/\n\nhttps://mjfrigaard.github.io/posts/my-rhino-app/\n-->\n\n\n\n:::: {.callout-important collapse='false'}\n\n## ALERT!\n\n::: {style='font-size: 0.90em; color: #696969;'}\n\n**This post is currently under development. Thank you for your patience.**\n\n::: \n\n::::\n\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(snakecase)\nlibrary(sloop)\nlibrary(waldo)\n```\n:::\n\n:::\n\nThis post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which I will cover below. But first, I'll dive into some attributes of R's functions and objects that make `purrr` particularly useful, and I'll work through iteration problems I've encountered (and solved with `purrr`).\n\n# **Refresher**: functions and objects \n\nIf you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.\n\nIn a functional programming language like R, it's nice when we can have functions perform a lot of the work we'd have to write into a `for` loop. \n\n## Generic functions & S3 objects\n\nR's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` and `summary()` functions are S3 generic function: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::ftype(plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n\n```{.r .cell-code}\nsloop::ftype(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n:::\n\n:::\n\nWhich means `plot()` can be applied to S3 objects, like time-series (`ts`) and rectangular datasets (`data.frame`):\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::otype(datasets::LakeHuron)\n## [1] \"S3\"\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nsloop::otype(datasets::chickwts)\n## [1] \"S3\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(datasets::LakeHuron)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   576.0   578.1   579.1   579.0   579.9   581.9\nsummary(datasets::chickwts)\n##      weight             feed   \n##  Min.   :108.0   casein   :12  \n##  1st Qu.:204.5   horsebean:10  \n##  Median :258.0   linseed  :12  \n##  Mean   :261.3   meatmeal :11  \n##  3rd Qu.:323.5   soybean  :14  \n##  Max.   :423.0   sunflower:12\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(datasets::LakeHuron)\n```\n\n::: {.cell-output-display}\n![Time-series plot](purrr101_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(datasets::chickwts)\n```\n\n::: {.cell-output-display}\n![Scatter Plot](purrr101_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n\n:::\n\n`summary()` is a particularly versatile function, because it can be used on `data.frame`s, a single column in a `data.frame`, model outputs, and more. \n\n::: {style=\"font-size: 0.90em; color: #696969;\"}\n*Click **Code** below to view an example using `summary()`*\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output  -------------------------------------------------------\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept) 30.09886    1.63392  18.421  < 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024,\tAdjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(>|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07\n```\n:::\n\n:::\n\n\n## FP + OOP \n\n`plot()` and `summary()` are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it. \n\nAs you can see, generic functions are flexible and efficient because we're not having to define a new function for each object--the output from the function depends (in part) on the structure of the object.\n\n> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition\n\nThe relationship between functions and objects is what makes `purrr` (and other tools for iteration) extremely helpful for solving common problems programmers encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools.\n\n## Iteration problems \n\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include: \n\n  1. You have a list of objects and you'd like to apply a function (or a series of functions) over the elements in the list\n  \n  2. You have a folder full of files you'd like to rename or copy to a new directory   \n\n  3. You'd like to download a collection of files from separate URLS  \n\n  4. You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset\n\n  5. You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths. \n\nThese are all problems I've personally encountered that required a variety of iteration tools to tackle. I'll start with the first example because the principles remain the same (regardless of the size/scope of the problem):\n\n\n# **The `for` loop**\n\n`for` loops are ubiquitous in programming, and (for the most part) they describe the types of problems they're solving: \n\n> \"*for each `item` in `object`, do `operation`*\"\n\nI have a list (`my_list`), with items in various cases:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list\n## $words\n## [1] \"tHAN\"      \"ORdeR\"     \"encoUragE\" \"lEFt\"      \"actIVe\"   \n## \n## $sentences\n## [1] \"sevEN SeaLS WERE stAMped ON gReat sheEts.\"    \n## [2] \"In soME fORm OR OtheR WE neED FuN.\"           \n## [3] \"THe FIsh TWIStEd aNd TUrnEd On ThE BenT hoOk.\"\n## \n## $letters\n##  [1] \"W\" \"M\" \"P\" \"c\" \"o\" \"x\" \"a\" \"J\" \"R\" \"G\"\n```\n:::\n\n:::\n\nIf I try to use the `tolower()` on `my_list`, it returns a vector.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(my_list) |> str()\n##  chr [1:3] \"c(\\\"than\\\", \\\"order\\\", \\\"encourage\\\", \\\"left\\\", \\\"active\\\")\" ...\n```\n:::\n\n:::\n\nHow can I apply the `tolower()` function to each item in `my_list`, and return the original object type? I'll use `my_list` and `tolower()` to demonstrate how I was taught to write `for` loops:\n\n-   **First**: define the sequence, '*for `[item]` in `[items in object]`*'\n\n      -   In this case, `x` is the abstracted `[item]` taking on the values returned by `seq_along(my_list)` (the `[items in object]`) \n      \n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    seq_along(my_list)\n    ## [1] 1 2 3\n    # take single value of 'x'\n    seq_along(my_list)[1]\n    ## [1] 1\n    # use this to get 'items in object'\n    my_list[[seq_along(my_list)[1]]]\n    ## [1] \"tHAN\"      \"ORdeR\"     \"encoUragE\" \"lEFt\"      \"actIVe\"\n    ```\n    :::\n\n    :::\n    \n-   **Second**: write the operations the for loop will perform per iteration (i.e. the first iteration is `x` = `tolower(my_list[[1]])`; the second iteration is `x` = `tolower(my_list[[2]])`; etc.)\n\n    - Test this with a few values if you like\n    \n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    tolower(my_list[[2]])\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"seven seals were stamped on great sheets.\"    \n    [2] \"in some form or other we need fun.\"           \n    [3] \"the fish twisted and turned on the bent hook.\"\n    ```\n    :::\n    :::\n\n    :::\n\n-   **Third**: define an (optional) object to capture the results of the loop (`lc_list`), and make sure it's the correct size\n\n    - Two methods for creating empty lists  \n    \n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    vector(mode = \"list\", length = 3)\n    ## [[1]]\n    ## NULL\n    ## \n    ## [[2]]\n    ## NULL\n    ## \n    ## [[3]]\n    ## NULL\n    list(NULL, NULL, NULL)\n    ## [[1]]\n    ## NULL\n    ## \n    ## [[2]]\n    ## NULL\n    ## \n    ## [[3]]\n    ## NULL\n    ```\n    :::\n\n    :::\n\nFinally, we put it all together in a `for` loop\n\n::: {style=\"font-size: 1.0em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# define capture object\nlc_list <- vector(mode = \"list\", length = 3)\n# write sequence\nfor (x in seq_along(my_list)) {        \n  # write operations/capture in object\n  lc_list[[x]] <- tolower(my_list[[x]])\n  # clean up container\n  names(lc_list) <- c(\"words\", \"sentences\", \"letters\")\n}\nlc_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"than\"      \"order\"     \"encourage\" \"left\"      \"active\"   \n\n$sentences\n[1] \"seven seals were stamped on great sheets.\"    \n[2] \"in some form or other we need fun.\"           \n[3] \"the fish twisted and turned on the bent hook.\"\n\n$letters\n [1] \"w\" \"m\" \"p\" \"c\" \"o\" \"x\" \"a\" \"j\" \"r\" \"g\"\n```\n:::\n:::\n\n:::\n\nThis was a simple example, but it demonstrates the basic components in a `for` loop: \n\n1. The sequence to index \n    - `for (x in seq_along(my_list))`  \n2. The operations to iterate   \n    - `tolower(my_list[[x]])`   \n3. The object to capture the results  \n    - `lc_list <- vector(mode = \"list\", length = 3)` and  \n    - `lc_list[[x]]`\n  \n# **Base R**\n\nbase R has the `_apply` family of functions (`apply()`, `lapply()`, `sapply()`, `vapply()`, etc.) that remove a lot of the 'book keeping' code we had to write in the `for` loop.\n\n\n## `lapply()`\n\n\nSticking with the `my_list` and `tolower()` example, the `apply` function I want is `lapply()` (pronounced 'l-apply'), and the `l` stands for list.\n\n`lapply()` has only two required arguments: \n\n  - `X` the object we want to iterate over \n\n  - `FUN` being the function we want iterated \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X = my_list, FUN = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"than\"      \"order\"     \"encourage\" \"left\"      \"active\"   \n\n$sentences\n[1] \"seven seals were stamped on great sheets.\"    \n[2] \"in some form or other we need fun.\"           \n[3] \"the fish twisted and turned on the bent hook.\"\n\n$letters\n [1] \"w\" \"m\" \"p\" \"c\" \"o\" \"x\" \"a\" \"j\" \"r\" \"g\"\n```\n:::\n:::\n\n:::\n\n\n## `sapply()`\n\n`sapply()` attempts to simplify the result depending on the `X` argument. If `X` is a list containing vectors where every element has the same length (and it's greater than 1), then `sapply()` returns a matrix:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_list[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ words: chr [1:5] \"tHAN\" \"ORdeR\" \"encoUragE\" \"lEFt\" ...\n```\n:::\n\n```{.r .cell-code}\nsapply(X = my_list[1], FUN = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     words      \n[1,] \"than\"     \n[2,] \"order\"    \n[3,] \"encourage\"\n[4,] \"left\"     \n[5,] \"active\"   \n```\n:::\n:::\n\n:::\n\nIf a vector is passed to `X` where every element is length 1, then a vector is returned: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_list[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:5] \"tHAN\" \"ORdeR\" \"encoUragE\" \"lEFt\" \"actIVe\"\n```\n:::\n\n```{.r .cell-code}\nsapply(X = my_list[[1]], FUN = tolower) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       tHAN       ORdeR   encoUragE        lEFt      actIVe \n     \"than\"     \"order\" \"encourage\"      \"left\"    \"active\" \n```\n:::\n:::\n\n:::\n\nFinally, if `X` is a list where elements have a length greater than 1, then a list is returned (making it identical to `lapply()`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\nThis is because `sapply` is a wrapper around `lapply`, but has `simplify` and `USE.NAMES` set to  `FALSE` (see what happens below when I change them to `TRUE`)\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n`old` is a list\n`new` is a character vector ('than', 'order', 'encourage', 'left', 'active')\n```\n:::\n:::\n\n:::\n\n## Anonmymous functions \n\nThe `FUN` argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in `my_list`, I could pass an anonymous function the `FUN` (with the index):\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(X = my_list, FUN = function(x) x[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"ORdeR\"\n\n$sentences\n[1] \"In soME fORm OR OtheR WE neED FuN.\"\n\n$letters\n[1] \"M\"\n```\n:::\n:::\n\n:::\n\n## `vapply()`\n\nFinally `vapply()` is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                               words                            sentences \n                             \"ORdeR\" \"In soME fORm OR OtheR WE neED FuN.\" \n                             letters \n                                 \"M\" \n```\n:::\n:::\n\n:::\n\n\nThe `apply` functions get us much further than writing `for` loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) **write less code.** Unlike generic functions, `apply` functions are designed to work with specific object types, and return values depending on these objects.\n\n\nOne downside of apply functions is they don't play well with `data.frame`s or `tibble`s. However, we can control their return values (and manually supply these to `tibble::tibble()` or `data.frame()`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n```\n:::\n\n:::\n\n\nAnother downside of the `apply` functions is they're not very uniform. Each function has slight variations in their arguments and rules for return values. This is where `purrr` comes in...\n\n# **`purrr`**\n\nIf you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)\n\n1. Do it for one element\n\n2. Turn it into a recipe\n\n3. Use `purrr::map()` to do it for all elements\n\nI'll work through these three steps below using `my_list` and `tolower()`\n\n## 1. Do it for one element\n\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\n\nFor this example, I need to subset `my_list` for a single element at position `[[1]]`, `[[2]]`, or `[[3]]` (or using one of the vector names). \n\nI'll then pass this element to `tolower()` and make sure it's the desired behavior:\n\n::: {style=\"font-size: 0.90em;\"}\n```r\n# subset an element from the list\n? <- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n```\n:::\n\n- `? <- my_list[[?]]` = subset element from the list (`my_list`)\n\n- `tolower(?)` = apply operation (i.e., function) to extracted element.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- my_list[['words']]\ntolower(my_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"than\"      \"order\"     \"encourage\" \"left\"      \"active\"   \n```\n:::\n:::\n\n:::\n\nNow that I have a working example for one element, in the next step I'll abstract these parts into the function arguments.\n\n## 2. Turn it into a recipe\n\nA standard `purrr` recipe defines `.x` (the object) and `.f` (the function), followed by any additional function arguments.\n\n- `.x` =  a list or atomic vector \n\n- `.f` = the function we want to apply over every element in `.x`\n\n::: {style=\"font-size: .90em;\"}\n```r\n.x = my_list, .f = tolower\n```\n:::\n\n## 3. `map()` it across all elements\n\nIn `purrr::map()`, the `.x` argument is the object (list or atomic vector) I want to iterate over, and `.f` is the function (i.e., operation) I want applied to every element of `.x` \n\nIf I want to convert the case of every element in `my_list` to lowercase with `tolower()` I would use the following standard `purrr::map()` format:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(.x = my_list, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"than\"      \"order\"     \"encourage\" \"left\"      \"active\"   \n\n$sentences\n[1] \"seven seals were stamped on great sheets.\"    \n[2] \"in some form or other we need fun.\"           \n[3] \"the fish twisted and turned on the bent hook.\"\n\n$letters\n [1] \"w\" \"m\" \"p\" \"c\" \"o\" \"x\" \"a\" \"j\" \"r\" \"g\"\n```\n:::\n:::\n\n:::\n\nAnd there you have it! `map()` is the core function and workhorse of the `purrr` package. It's important to note that `purrr::map()` always returns a list, regardless of the object supplied to `.x`. \n\n# **Version 1.0.0 updates**\n\nNow I'll cover some of the updates in `purrr` 1.0.0. I'll be using `mixed_list`, a list with five different types of vectors. \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$booleans\n[1] FALSE  TRUE FALSE  TRUE\n\n$integers\n[1] 5 7 2 9 1\n\n$doubles\n[1] 3.213 2.946 3.166 3.043 2.800\n\n$strings\n[1] \"kill\"   \"behind\" \"wee\"    \"feel\"   \"quite\" \n\n$dates\n[1] \"2023-03-27\" \"2023-02-15\" \"2022-12-27\"\n```\n:::\n:::\n\n:::\n\n## `map()` updates \n\nAs noted above, by default `purrr::map()` returns a list. If I'd like to return a vector, I can use one of the `map_` variations (there's one for each vector type). \n\n-   By mapping the `is.<type>()` functions the elements in `mixed_list`, I can test which elements in `mixed_list` return `TRUE`:\n\n    -   `map_lgl()`: returns a logical vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_lgl(\\(x) is.logical(x))\n    ## booleans integers  doubles  strings    dates \n    ##     TRUE    FALSE    FALSE    FALSE    FALSE\n    ```\n    :::\n\n    :::\n\n    -   `map_int()`: returns an integer vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_int(\\(x) is.integer(x))\n    ## booleans integers  doubles  strings    dates \n    ##        0        1        0        0        0\n    ```\n    :::\n\n    :::\n\n    -   `map_dbl()`: returns a double vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_dbl(\\(x) is.double(x))\n    ## booleans integers  doubles  strings    dates \n    ##        0        0        1        0        1\n    ```\n    :::\n\n    :::\n\n    -   `map_chr()`: returns a character vector \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mixed_list |> purrr::map_chr(\\(x) is.character(x))\n    ## Warning: Automatic coercion from logical to character was deprecated in purrr 1.0.0.\n    ## ℹ Please use an explicit call to `as.character()` within `map_chr()` instead.\n    ## booleans integers  doubles  strings    dates \n    ##  \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\"\n    ```\n    :::\n\n    :::\n    \nWhen we test for characters in `mixed_list`, we see the following warning:\n\n::: {style=\"font-size: 0.90em;\"}\n> `Warning: Automatic coercion from logical to character was deprecated in purrr`\n> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`\n:::\n\nAs we can see from the output above, the logical return values from `is.character()` are coerced to characters (this behavior is now deprecated).\n\n### `map_vec()`\n\n<br>\n\nHowever, the previous `purrr::map_raw()` function has been replaced with `purrr::map_vec()`, which \"*simplifies to the common type of the output.*\" I'll demonstrate below with the characters in `mixed_list`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list |> purrr::map_vec(\\(x) is.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE     TRUE    FALSE \n```\n:::\n:::\n\n:::\n\nNotice the difference in output?  The results are the same as above, but output is not commented (`##`). The same is true when I test the dates in `mixed_list` using `lubridate::is.Date()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list |> purrr::map_vec(\\(x) lubridate::is.Date(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE    FALSE     TRUE \n```\n:::\n:::\n\n:::\n\n## Anonymous functions\n\nR introduced the shorthand anonymous function syntax in version [4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html):\n\n> \"*`\\(x) x + 1` is parsed as `function(x) x + 1`.*\" \n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\n-   Standard anonymous function  \n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (function(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"pirates ship\"\n    ```\n    :::\n    :::\n\n    :::\n\n-   The updated anonymous syntax is below:\n\n    ::: {style=\"font-size: 0.90em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    (\\(x) tolower(x))(\"pIrAtES Ship\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"pirates ship\"\n    ```\n    :::\n    :::\n\n    :::\n\nWriting the code above using an anonymous function would look like this:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"than\"      \"order\"     \"encourage\" \"left\"      \"active\"   \n\n$sentences\n[1] \"seven seals were stamped on great sheets.\"    \n[2] \"in some form or other we need fun.\"           \n[3] \"the fish twisted and turned on the bent hook.\"\n\n$letters\n [1] \"w\" \"m\" \"p\" \"c\" \"o\" \"x\" \"a\" \"j\" \"r\" \"g\"\n```\n:::\n:::\n\n:::\n\nAnonymous functions make it *easier to understand which arguments belong to which function and will tend to yield better error messages.* \n\nI'll confirm the outputs from both methods are identical using `waldo::compare()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(\\(x) tolower(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n:::: {.callout-important icon=false}\n## The formula (`~ .x + 1`)\n\n<br>\n\n::: {style=\"font-size: 1.10em;\"}\nPrior to `purrr` v1.0.0, I could also use the formula syntax, but now it's \"*only recommended if you require backward compatibility with older versions of R.*\" I'll cover the formula syntax briefly because you're likely to encounter it. \n:::\n\n::: {style=\"font-size: 1.10em;\"}\nThe formula syntax is typically used with pipes, so the contents of `purrr::map()` become the right-hand side of the formula, with the function we want to iterate (`<FUNCTION>`) and a placeholder (`.x`) in the appropriate argument.\n:::\n\n::: {style=\"font-size: 1.20em;\"}\n```r\n<OBJECT> |> purrr::map(~ <FUNCTION>(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nFor the example above, `my_list` is 'piped' to `purrr::map()`, where the formula maps the `tolower()` function (using the `.x` placeholder).\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n```r\n# written as normal expression\n my_list |> purrr::map(~ tolower(.x))\n```\n:::\n\n::: {style=\"font-size: 1.10em;\"}\nJenny Bryan offers a great description on [her `purrr` tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), \n\n> \"*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*\"\n\nI can double-check to see that the output from two variations are identical using `waldo::compare()`.\n:::\n\n::: {style=\"font-size: 1.00em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n::::\n\n\n\n<!--\n# map for `data.frame` and `tibble`s\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nswdata <- dplyr::select(dplyr::starwars, !where(is.list))\npurrr::map_df(.x = swdata, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 11\n   name     height mass  hair_color skin_color eye_color birth_year sex   gender\n   <chr>    <chr>  <chr> <chr>      <chr>      <chr>     <chr>      <chr> <chr> \n 1 luke sk… 172    77    blond      fair       blue      19         male  mascu…\n 2 c-3po    167    75    <NA>       gold       yellow    112        none  mascu…\n 3 r2-d2    96     32    <NA>       white, bl… red       33         none  mascu…\n 4 darth v… 202    136   none       white      yellow    41.9       male  mascu…\n 5 leia or… 150    49    brown      light      brown     19         fema… femin…\n 6 owen la… 178    120   brown, gr… light      blue      52         male  mascu…\n 7 beru wh… 165    75    brown      light      blue      47         fema… femin…\n 8 r5-d4    97     32    <NA>       white, red red       <NA>       none  mascu…\n 9 biggs d… 183    84    black      light      brown     24         male  mascu…\n10 obi-wan… 182    77    auburn, w… fair       blue-gray 57         male  mascu…\n# ℹ 77 more rows\n# ℹ 2 more variables: homeworld <chr>, species <chr>\n```\n:::\n:::\n\n:::\n-->\n\n# Worked Examples\n\n## Copying a directory of files \n\n> *You have a folder full of files you'd like to rename or copy to a new directory*\n\n## Downloading files \n\n> *You'd like to download a collection of files from separate URLS*\n  \n## Import multiple datasets \n\n> *You have several years of data, and each year is contained in separate file. You'd like to read these data into R, combine them into a single dataset*\n\n## Export multiple datasets \n\n> *You have a non-rectangular (i.e., list) of datasets you'd like to split into individual `data.frame`s, then export these into separate file paths* \n\n\n\n\n\n:::: {.callout-tip icon=false}\n## REACP: `purrr` syntax variations\n\n::: {style=\"font-size: 1.25em;\"}\n**Standard**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# define .x and .f\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Anonymous function**\n:::\n\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# anonymous shorthand notation\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n\n::: {style=\"font-size: 1.25em;\"}\n**Formula (deprecated)**\n:::\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as normal expression\nmy_list |> purrr::map(~ tolower(.x))\n```\n:::\n::::\n\n\nFor more information check out the [iteration chapter in R for Data Science](https://r4ds.had.co.nz/iteration.html).  ",
    "supporting": [
      "purrr101_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}