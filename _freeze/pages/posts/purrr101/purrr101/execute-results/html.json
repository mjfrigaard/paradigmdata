{
  "hash": "e2e3f348862152fba23196f654259d89",
  "result": {
    "markdown": "---\ntitle: \"purrr updates (v1.0.0)\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-04-05\"\nimage: \"image.png\"\ntoc: true\ntoc-depth: 5\ntoc-title: 'Contents'\ntoc-location: \"left\"\n\nfig-align: center\ncode-link: true\nfontsize: '11'\n\ncallout-icon: false\ncallout-appearance: default\n\nfreeze: true\n\nexecute:\n  echo: true\n  warning: false\n  eval: true\n---\n\n\n\n\n<!--\nhttps://mjfrigaard.github.io/posts/vanilla-shiny/\n\nhttps://mjfrigaard.github.io/posts/my-pkg-app/\n\nhttps://mjfrigaard.github.io/posts/my-golem-app/\n\nhttps://mjfrigaard.github.io/posts/my-leprechaun-app/\n\nhttps://mjfrigaard.github.io/posts/my-rhino-app/\n-->\n\n\n\n:::: {.callout-important collapse='false'}\n\n## ALERT!\n\n::: {style='font-size: 0.90em; color: #696969;'}\n\n**This post is currently under development. Thank you for your patience.**\n\n::: \n\n::::\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"tidyverse/purrr\", \n#                   force = TRUE, quiet = TRUE)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(stringr)\nlibrary(snakecase)\n```\n:::\n\n:::\n\nThis post is going to cover the recent updates to the [`purrr` package](https://purrr.tidyverse.org/) (\"*a complete and consistent set of tools for working with functions and vectors*\"). The release of [version 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/) (and dev version  [v1.0.1](https://github.com/tidyverse/purrr/blob/main/NEWS.md#purrr-101)) had some breaking changes, which makes it's a great time for a refresher!\n\n# RECAP: Functions and objects \n\nIf you're like me, you've never been a big fan of `for` loops. They're an important concept to grasp, but if you've ever had to debug what's happening in multiple nested `for` loops, you've probably found yourself asking if there's a better way to iterate.\n\n> *Functional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades.* - Advanced R, 2nd edition\n\nR's syntax avoids explicit iteration by allowing certain *generic* functions to be used across different types (or objects). For example, the base `plot()` function is an S3 generic function: \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nisS3stdGeneric(plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nplot \nTRUE \n```\n:::\n:::\n\n:::\n\nWhich means `plot()` can be applied to a `ts` (Time-Series) object or a standard `data.frame`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(datasets::LakeHuron)\n```\n\n::: {.cell-output-display}\n![Time-series plot](purrr101_files/figure-html/chickwts-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(datasets::chickwts)\n```\n\n::: {.cell-output-display}\n![Scatter Plot](purrr101_files/figure-html/chickwts-2.png){width=672}\n:::\n:::\n\n:::\n\n`summary()` is similar--we can apply this function to individual data objects, model outputs, etc.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nisS3stdGeneric(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsummary \n   TRUE \n```\n:::\n:::\n\n:::\n\n`plot()` and `summary()` are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it. \n\n::: {style=\"font-size: 0.90em; color: #696969;\"}\n*Click **Code** below to view an example using `summary()`*\n:::\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# get summary of columns\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept) 30.09886    1.63392  18.421  < 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024,\tAdjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# get coefficients of summary of model output\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(>|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07\n```\n:::\n\n:::\n\n`purrr` (and other tools for iteration) are extremely helpful for solving common problems programmers encounter when working with data because they allow us to express iterative behavior with a complete and consistent set of tools. \n\n# Typical iteration problems \n\nIn programming, iteration refers to defining an input and applying an operation over every part of it. An example problem I've encountered that requires iteration was converting all the text in a list of character vectors. \n\nBelow is `my_list`, a list of items in various cases. \n\n\n::: {.cell}\n\n:::\n\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list\n## $words\n## [1] \"soOn\"     \"fiLe\"     \"sALE\"     \"APpaReNt\" \"BeT\"     \n## \n## $sentences\n## [1] \"HE used tHe lATHe tO mAkE brAsS OBjEcTS.\"     \n## [2] \"THe hOGs wEre FED CHOPpeD CorN AND GarbAGe.\"  \n## [3] \"tHe wHArf cOuLD Be SEEN AT The faRtHER SHORe.\"\n## \n## $letters\n##  [1] \"e\" \"N\" \"y\" \"j\" \"F\" \"c\" \"R\" \"K\" \"S\" \"I\"\n```\n:::\n\n:::\n\nIf I try to use the `tolower()` on `my_list`, it returns a vector.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntolower(my_list) |> str()\n##  chr [1:3] \"c(\\\"soon\\\", \\\"file\\\", \\\"sale\\\", \\\"apparent\\\", \\\"bet\\\")\" ...\n```\n:::\n\n:::\n\nHow can I apply the `tolower()` function to each item in `my_list` (and return the original object type)?\n\n## The `purrr` strategy\n\nIf you're new to `purrr`, a great way to start using it's functions is with a recipe covered in [Charlotte Wickham's tutorial](https://posit.co/resources/videos/happy-r-users-purrr-tutorial/)\n\n1. Do it for one element\n\n2. Turn it into a recipe\n\n3. Use `purrr::map()` to do it for all elements\n\nI'll work through these three steps below using `my_list` and `tolower()`\n\n### 1. Do it for one element\n\nThe goal with this first step is to get a minimal working example with an element and the function I want to use.\n\n- `_____ <- my_list[[?]]` = subsetted element from a list  \n\n- `tolower(_____)` = operation to apply\n\nIn this case, I want to subset `my_list` for a single element (`words`, `sentences`, or `letters`) so I can use it with `tolower()`. \n\n:::: {.callout-note icon=false}\n## Do it for one \n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# extract an element from the object\n_____ <- my_list[[?]]\n# apply a function to the element\ntolower(_____)\n```\n:::\n::::\n\nI'll start with the `words` vector in `my_list`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_words <- my_list[['words']]\ntolower(my_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"soon\"     \"file\"     \"sale\"     \"apparent\" \"bet\"     \n```\n:::\n:::\n\n:::\n\nNow that I have a working example for one element, in the next step I'll abstract out the parts that need iteration. \n\n### 2. Turn it into a recipe\n\nA standard `purrr` recipe involves defining `.x` and `.f`, and then supplying any additional function arguments\n\n- `.x` =  a list or atomic vector \n\n- `.f` = the function we want to apply over every element in `.x`\n\nOr I can also use the formula syntax:\n\n- `~ function()` read as '*map this function*'\n\n- `.x` = `purrr`'s placeholder for one element of our object\n\nThe formula syntax can take some getting used to, but Jenny Bryan offers some great advice on [her tutorial](https://jennybc.github.io/purrr-tutorial/ls03_map-function-syntax.html#anonymous_function,_formula), \n\n> \"*[formula syntax] should start with the `~` symbol and then look like a typical top-level expression, as you might write in a script. Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.*\"\n\n\n:::: {.callout-note icon=false}\n## Turn it into a recipe\n\n**Standard syntax:**\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# define .x and .f\n.x = my_list, .f = tolower\n```\n:::\n\n**Formula syntax:**\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as normal expression\n ~ tolower(.x)\n```\n:::\n::::\n\n\n### 3. Use `purrr::map()` to do it for all elements\n\nThe `.x` argument is the list (or atomic vector) I want to iterate over, followed by the formula: \n\n:::: {.callout-note icon=false}\n## Do it for all elements\n\n**Standard syntax:**\n\n::: {style=\"font-size: 1.10em;\"}\n```r\npurrr::map(.x = my_list, .f = tolower)\n```\n:::\n\n**Formula syntax:**\n\n::: {style=\"font-size: 1.10em;\"}\n```r\nmy_list |> purrr::map(~ tolower(.x))\n```\n:::\n::::\n\n\nTo turn our `my_list` example into a recipe, we would use the following standard format:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(.x = my_list, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$words\n[1] \"soon\"     \"file\"     \"sale\"     \"apparent\" \"bet\"     \n\n$sentences\n[1] \"he used the lathe to make brass objects.\"     \n[2] \"the hogs were fed chopped corn and garbage.\"  \n[3] \"the wharf could be seen at the farther shore.\"\n\n$letters\n [1] \"e\" \"n\" \"y\" \"j\" \"f\" \"c\" \"r\" \"k\" \"s\" \"i\"\n```\n:::\n:::\n\n:::\n\nI'll check the output from the formula syntax using `waldo::compare()`:\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n\n# Updates to anonymous functions\n\nAs of [R 4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html), new anonymous functions have been added. A typical anonymous (unnamed) function is below:\n\n-   `(function(x) tolower(x))(\"pIrAtES Ship\")`\n\nThe updated syntax is below:\n\n-   `(\\(x) tolower(x))(\"pIrAtES Ship\")`\n\n> \"*R now provides a shorthand notation for creating functions, e.g. `\\(x) x + 1` is parsed as `function(x) x + 1`.*\"\n\n\n:::: {.callout-note icon=false}\n## Anonymous function syntax\n\n**R anonymous function**\n\n::: {style=\"font-size: 1.10em;\"}\n```r\n# written as an anonymous function\n\\(x) tolower(x)\n```\n\n**Using anonymous function with `purrr`**\n\n```r\nmy_list |> purrr::map(\\(x) tolower(x))\n```\n:::\n::::\n\nI can double-check to see that the output from two variations are identical using `waldo::compare()`.\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n✔ No differences\n```\n:::\n:::\n\n:::\n\n# Updates to `map()`\n\n`map()` is the core function of the `purrr` package. However, by default `map()` returns a list, so there's a `map_` variations for each vector type. I'll demonstrate them below using the `mixed_list` object, which has five vectors. \n\n\n::: {.cell}\n\n:::\n\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$booleans\n[1] FALSE  TRUE FALSE  TRUE\n\n$integers\n[1]  3  1  4  2 10\n\n$doubles\n[1] 3.171 3.067 3.276 3.234 3.219\n\n$strings\n[1] \"die\"   \"suit\"  \"score\" \"order\" \"free\" \n\n$dates\n[1] \"2023-03-25\" \"2023-02-13\" \"2022-12-25\"\n```\n:::\n:::\n\n:::\n\n`map_lgl()`: returns a logical vector \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_lgl(.x = mixed_list, .f = is.logical)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n    TRUE    FALSE    FALSE    FALSE    FALSE \n```\n:::\n:::\n\n:::\n\n`map_int()`: returns an integer vector \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_int(.x = mixed_list, .f = is.integer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n       0        1        0        0        0 \n```\n:::\n:::\n\n:::\n\n`map_dbl()`: returns a double vector \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(.x = mixed_list, .f = is.double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n       0        0        1        0        1 \n```\n:::\n:::\n\n:::\n\n`map_chr()`: returns a character vector \n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_chr(.x = mixed_list, .f = is.character)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\" \n```\n:::\n:::\n\n:::\n\n> `Warning: Automatic coercion from logical to character was deprecated in purrr`\n> `1.0.0. Please use an explicit call to as.character() within map_chr() instead`\n\n\n\n## `map_vec()`\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_vec(.x = mixed_list, .f = lubridate::is.Date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE    FALSE     TRUE \n```\n:::\n:::\n\n:::\n\n# map for `data.frame` and `tibble`s\n\n::: {style=\"font-size: 0.90em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nswdata <- dplyr::select(dplyr::starwars, !where(is.list))\npurrr::map_df(.x = swdata, .f = tolower)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 87 × 11\n   name     height mass  hair_color skin_color eye_color birth_year sex   gender\n   <chr>    <chr>  <chr> <chr>      <chr>      <chr>     <chr>      <chr> <chr> \n 1 luke sk… 172    77    blond      fair       blue      19         male  mascu…\n 2 c-3po    167    75    <NA>       gold       yellow    112        none  mascu…\n 3 r2-d2    96     32    <NA>       white, bl… red       33         none  mascu…\n 4 darth v… 202    136   none       white      yellow    41.9       male  mascu…\n 5 leia or… 150    49    brown      light      brown     19         fema… femin…\n 6 owen la… 178    120   brown, gr… light      blue      52         male  mascu…\n 7 beru wh… 165    75    brown      light      blue      47         fema… femin…\n 8 r5-d4    97     32    <NA>       white, red red       <NA>       none  mascu…\n 9 biggs d… 183    84    black      light      brown     24         male  mascu…\n10 obi-wan… 182    77    auburn, w… fair       blue-gray 57         male  mascu…\n# ℹ 77 more rows\n# ℹ 2 more variables: homeworld <chr>, species <chr>\n```\n:::\n:::\n\n:::\n\n\n`purrr` contains a collection of tools for iteration in R. For a great intro check out the [iteration chapter in R for Data Science](https://r4ds.had.co.nz/iteration.html).  ",
    "supporting": [
      "purrr101_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}