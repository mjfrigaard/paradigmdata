{
  "hash": "a02c8f19558b913f230abcacd7fc60f1",
  "result": {
    "markdown": "---\ntitle: \"Shiny framework comparisons\"\nauthor: \"Martin Frigaard\"\ndate: \"2023-02-03\"\ncategories: [shiny, code, packages]\nimage: \"image.png\"\nfig-align: center\ncode-link: true\nfontsize: '11'\ntoc: true\ntoc-depth: 4\ntoc-title: 'Contents'\ntoc-location: \"left\"\nnumber-sections: true\nfreeze: true\nexecute:\n  echo: true\n  warning: false\n  eval: false\n---\n\n\nI recently read a [Medium article](https://blog.devgenius.io/which-r-shiny-framework-is-the-best-a-comparison-of-vanilla-shiny-golem-rhino-and-leprechaun-c02ad8e2aa8c) that provided excellent guidance when considering four common shiny frameworks. In this post, I'll walk through building apps with each framework and describe some of the common features worth considering when building your shiny app.\n\n> TLDR\n>\n> Developers new shiny can benefit from `golem`'s framework (and helper scripts). If you decide `golem` is too opinionated, `leprechaun` let's you access many of the same features à la carte. `rhino`...\n\n## Framework comparisons {.unnumbered}\n\nThe [original post](https://blog.devgenius.io/which-r-shiny-framework-is-the-best-a-comparison-of-vanilla-shiny-golem-rhino-and-leprechaun-c02ad8e2aa8c) compares 'vanilla shiny' (bare-bones shiny application), [`golem`](https://thinkr-open.github.io/golem/), [`leprechaun`](https://leprechaun.opifex.org/#/), and  [`rhino`](https://appsilon.github.io/rhino/) across a series of dimensions (framework reliability, target type of developer, overall developing experience, etc.).\n\nFor this post I've build the following shiny apps:\n\n1)  `VanillaApp`, a standard shiny app\\\n2)  `myPkgApp`, a shiny app built using `devtools` and `usethis` \\\n3)  `myGolemApp`, a shiny app using the `golem` framework\\\n4)  `myLeprechaunApp`, a shiny app using the `leprechaun` package\\\n5)  `myRhinoApp`, a shiny app using the `rhino` package\n\nThe GitHub repo with all shiny app setups is [here](https://github.com/mjfrigaard/shiny-app-setups).\n\n# A shiny app {#sec-VanillaApp}\n\n> `VanillaApp`: a bare-bones shiny app\n\nA lot of shiny apps being their lives as single `app.R` file, but few stay that way. Nonetheless, it's nice to know you're always only a few lines of R code away from creating a web application.\n\n## Start\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages(\"shiny\")\nlibrary(shiny)\n```\n:::\n\n:::\n\nCreating a new 'vanilla' shiny app from RStudio's **New Project Wizard** gives the following default options:\n\n::: {#fig-vanilla-setup .column}\n![](vanilla-setup.png){height=\"70%\" width=\"70%\" fig-align=\"center\"}\n\nNew **shiny** app\n:::\n\n<br>\n\nWhen we create `VanillaApp`, we see a folder with the following files:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nVanillaApp/\n    ├── VanillaApp.Rproj\n    ├── app.R\n    ├── renv\n    └── renv.lock\n    \n2 directories, 3 files\n```\n:::\n\n:::\n\n<br>\n\n## Build\n\n<br>\n\nThe code for the `VanillaApp` app is in `app.R` (*it comes from the RStudio shiny tutorial, [\"Building web applications with Shiny\"](https://rstudio-education.github.io/shiny-course/)*).\n\n::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n*Click on Code to view code in `app.R`*\n:::\n\n::: {style=\"font-size: 0.80em;\"}\n```{#lst-VanillaApp .r lst-cap=\"Vanilla App\"}\n\n# Define UI ------------\nui <- fluidPage(\n  \n  titlePanel(title = \"movies data app (demo)\"),\n  \n  shiny::sidebarLayout(\n    \n    shiny::sidebarPanel(\n      \n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      \n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      \n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      \n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n      \n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n      \n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      \n      shiny::tags$br(),\n      \n        shiny::tags$blockquote(\n          shiny::tags$em(\n            shiny::tags$h6(\"The code for this application comes from the \",\n            shiny::tags$a(\"Building web applications with Shiny\", \n              href = \"https://rstudio-education.github.io/shiny-course/\"), \n                          \"tutorial\"))),\n      \n      shiny::plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server -------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- shiny::renderPlot({\n    plot <- point_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    )\n    plot +\n      ggplot2::labs(\n        title = input$plot_title,\n        x = stringr::str_replace_all(tools::toTitleCase(input$x), \"_\", \" \"),\n        y = stringr::str_replace_all(tools::toTitleCase(input$y), \"_\", \" \")\n      )\n  })\n}\n\n# Create App ------------------\n\nshiny::shinyApp(ui = ui, server = server)\n\n```\n:::\n\nThis is a fairly simple application, but as we can see, it imports data (`movies.RData`) and a requires a helper function stored in `utils.R`.\n\n::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n*Click on Code to view code in `utils.R`*\n:::\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# pkgs -----\nlibrary(ggplot2)\n\n# point_plot -----\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n  ggplot2::ggplot(\n    data = df,\n    ggplot2::aes(\n      x = .data[[x_var]],\n      y = .data[[y_var]],\n      color = .data[[col_var]]\n    )\n  ) +\n    ggplot2::geom_point(alpha = alpha_var, size = size_var)\n}\n```\n:::\n\n:::\n\nIn my project, I can drop `movies.RData` and `utils.R` and these in the top-level folder.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nVanillaApp/\n        ├── VanillaApp.Rproj\n        ├── app.R\n        ├── movies.RData\n        ├── renv\n        ├── renv.lock\n        └── utils.R\n\n2 directories, 5 files\n```\n:::\n\n:::\n\n## Use \n\nTo use `VanillaApp`, we can click on **Run App** in the `app.R` file, or \n\n<br>\n\n### `renv/`\n\n::: column-margin\n![](renv.png){height=\"75%\" width=\"75%\" fig-align=\"center\"}\n:::\n\n<br>\n\nThe `renv` folder and `renv.lock` file store the R version and package dependencies for my app. This is evident by the `R-4.2` under `renv/library` and `renv/sandbox` in the folder tree above.\n\nTo keep `renv/` updated, when I install a package with `install.packages()`, I also need to make sure to include a call to `renv::snapshot()`.\n\nSee the example with `shiny`, `ggplot2`, `dplyr` and `tools` below:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# install packages \ninstall.packages(c(\"shiny\", \"ggplot2\", \"dplyr\", \"tools\"))\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nInstalling shiny [1.7.4] ...\n\tOK [linked cache]\n# Installing <package> [version] ..\n#  OK [linked cache]\n# Installing <package> [version] ..\n#  OK [linked cache]\n# Installing <package> [version] ..\n#  OK [linked cache]\nInstalling dplyr [1.1.0] ...\n\tOK [linked cache]\n```\n:::\n\n:::\n\n`renv::snapshot()` records the packages it in `renv.lock` file.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# save declared versions of packages \nrenv::snapshot()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n* Lockfile written to '~/projects/VanillaApp/renv.lock'.\n```\n:::\n\n:::\n\n<br>\n\n::: {style=\"font-size: 1.05em; color: #007bff;\"}\n\"*`renv` records the version of R + R packages being used in a project, and provides tools for reinstalling the declared versions of those packages in a project*\"\n:::\n\nRead more about [getting started with `renv`](https://rstudio.github.io/renv/articles/renv.html) and [using `renv` in package development](https://rstudio.github.io/renv/articles/packages.html)\n\n## Recap\n\n`VanillaApp` is now a functioning shiny app, but it's difficult to scale in it's current structure. As the app codebase grows in complexity, the `app.R` (or `ui.R` and `server.R`) might reach thousands of lines of code.\n\n------------------------------------------------------------------------\n\n# R package {#sec-myPkgApp}\n\n> `myPkgApp`: shiny app as an R package:\n\nBuilding a shiny app as a package is [highly recommended](https://mastering-shiny.org/scaling-packaging.html?q=highly%20recommend#scaling-packaging). This might seem like overkill, but when you consider the additional development tools accessible to R packages, the advice makes sense. I'll use the application code from above as an example to demonstrate.\n\n## Start\n\nTo create a shiny app package, I install [`devtools`](https://devtools.r-lib.org/) (which also installs [`usethis`](https://usethis.r-lib.org/)).\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages(\"devtools\")\nlibrary(devtools)\n```\n:::\n\n:::\n\nIf I am creating a package from the console, the function for building a new package is `usethis::create_package()`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::create_package(path = \"myPkgApp\")\n```\n:::\n\n:::\n\nA new RStudio session will open (and the name of the project--i.e., the name of the `.Rproj` file--will be identical to the package name).\n\nIf I am using RStudio's **New Project Wizard** to create a new shiny app package, I'd see the following defaults:\n\n::: {#fig-rpkg-setup .column}\n![](rpkg-setup.png){height=\"70%\" width=\"70%\" fig-align=\"center\"}\n\nDefault `usethis::create_package` project setup\n:::\n\n<br>\n\nThe new package built from the console will have the following folder and files:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyPkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── myPkgApp.Rproj\n  \n1 directory, 3 files\n```\n:::\n\n:::\n\nPackages built from the **New Project Wizard** will have a few additional folders and files:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyPkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   └── hello.R\n  ├── man/\n  │   └── hello.Rd\n  ├── myRPkg.Rproj\n  └── renv/\n      ├── activate.R\n      ├── sandbox/\n      │   └── R-4.2\n      └── settings.dcf\n\n4 directories, 7 files\n```\n:::\n\n:::\n\nThese additional files are:\n\n-   `hello.R` in the `R/` folder\\\n-   `hello.Rd` in the `man/` folder\\\n-   a `renv/` folder for package management\n\n`R/hello.R` and `man/hello.Rd` are boilerplate files and should be deleted, but both package setups have a `DESCRIPTION`, `NAMESPACE`, `R/` folder, and `.Rproj` file. This structure can be thought of as the 'minimal' setup required to access RStudio's **Build** tools.\n\n## Build\n\nThe workflow when developing R packages is [well documented elsewhere](https://r-pkgs.org/whole-game.html) and slightly more involved than working in a single `app.R` file. However, the additional steps force better habits (and prevent having to rebuild your application entirely from scratch).\n\nI'll work through a 'minimum viable product (MVP)' version of the [full package development workflow](https://r-pkgs.org/whole-game.html) using the app code in @lst-VanillaApp\n\n<br>\n\n### `DESCRIPTION`\n\n::: column-margin\n![](desc.png){height=\"75%\" width=\"75%\" fig-align=\"center\"}\n:::\n\nThe `DESCRIPTION` file plays an important role in R packages--that's why creating this file is the first step when [converting an existing app](https://mastering-shiny.org/scaling-packaging.html#converting-an-existing-app) (and in [new `golem` apps](https://thinkr-open.github.io/golem/articles/a_start.html#fill-the-description)).\n\nThe initial `DESCRIPTION` file in `myPkgApp` is below:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nPackage: myPkgApp\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", \n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n```\n:::\n\n:::\n\nThe package name is automatically added, but the remaining fields need to be completed (consult [R packages](https://r-pkgs.org/description.html#the-description-file) for information on filling out the `DESCRIPTION` file).\n\n> ::: {style=\"font-size: 1.15em; color: #007bff;\"}\n> *\"RStudio and `devtools` consider any directory containing `DESCRIPTION` to be a package\"* - [R Packages](https://r-pkgs.org/description.html#the-description-file)\n> :::\n\nThe `DESCRIPTION` file in the `myPkgApp` prompts the RStudio IDE to activate the **Build** tools pane (see below):\n\n::: {#fig-rpkg-ide .column}\n![](rpkg-ide.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nPackage **Build** tools\n:::\n\n### `use_r()`\n\nI'm going to create `myPkgApp` using modules because it helps me mentally separate the app into 'chunks' (additional reasons are covered [here](https://mastering-shiny.org/scaling-modules.html#module-motivation)).\n\nThe original app collects the inputs in the `sideBar()` and creates a plot in the `mainPanel()`. I'll need one module to collect and return the user-inputs (`var_input_mod`) and another module to display the plot (`display_plot_mod`), which relies on a utility function (`plot_points()`).\n\nModules consist of two functions; one in the UI (with a `_ui` suffix), and another in the server (with a `_server` suffix), but I'll combine them in a single file using [`usethis::use_r()`](https://usethis.r-lib.org/reference/use_r.html):\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_r(\"var_input_mod\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n✔ Setting active project to '/Users/mjfrigaard/projects/myPkgApp'\n• Modify 'R/var_input_mod.R'\n• Call `use_test()` to create a matching test file\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_r(\"display_plot_mod\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n• Modify 'R/display_plot_mod.R'\n• Call `use_test()` to create a matching test file\n```\n:::\n\n:::\n\nIncluding `mod` in the name of module scripts and functions makes it easier to separate them from other functions in my package namespace, if I'm using tab-completion, or if I'm searching for a particular file using `Ctrl` + `.`:\n\n::: {#fig-go-to .column}\n![](go-to-file.png){height=\"90%\" width=\"90%\" fig-align=\"center\"}\n\n**Go to File/Function** in RStudio\n:::\n\nI also need to create a script for the utility function (`point_plot()`), which I put in a file with a name similar to the module it belongs to (i.e., `display_plot_utils`).\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_r(\"display_plot_utils\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n• Modify 'R/display_plot_utils.R'\n• Call `use_test()` to create a matching test file\n```\n:::\n\n:::\n\nFinally, I'll place the modules into basic ui and server arguments in a call to `shiny::shinyApp()`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_r(\"moviesApp\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n• Modify 'R/moviesApp.R'\n• Call `use_test()` to create a matching test file\n```\n:::\n\n:::\n\n<br>\n\n#### `roxygen2`\n\nWhen I'm confident my code works (and the app renders), I want to make sure these functions become part of `myPkgApp` by describing each function with [`roxygen2`](https://roxygen2.r-lib.org/) tags. To quickly insert a `roxygen2` skeleton, use the RStudio IDE (or the keyboard shortcut: `Option` + `Shift` + `Command` + `R`)\n\n> ::: {style=\"font-size: 1.15em; color: #007bff;\"}\n> *As well as generating `.Rd` files, `roxygen` will also create a `NAMESPACE` for you, and will manage the `Collate` field in `DESCRIPTION`*\n> :::\n\n::: {#fig-roxygen2-tags .column}\n![](ide-roxygen-skeleton.png){height=\"95%\" width=\"95%\" fig-align=\"center\"}\n\nStandard `roxygen2` skeleton\n:::\n\nThe standard `roxygen2` tags include `@param`, `@return`, `@export`, and `@examples` (see the example for `point_plot()` below):\n\n::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n*Click on Code to view*\n:::\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return plot object\n#' @export point_plot\n#'\n#' @importFrom ggplot2 ggplot aes geom_point\n#'\n#' @examples\n#' require(myPkgApp)\n#' movies <- myPkgApp::movies\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n#' }\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n```\n:::\n\n:::\n\nSee the full code [here](https://github.com/mjfrigaard/shiny-app-setups/blob/main/myPkgApp/R/).\n\n### `load_all()`\n\nAfter documenting everything with `roxygen2`, I want to make sure none of the functions are in my **Environment** (remove with `rm()` if necessary) and load the functions with [`devtools::load_all()`](https://r-pkgs.org/whole-game.html#sec-whole-game-load-all).\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::load_all()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nℹ Loading myPkgApp\n```\n:::\n\n:::\n\n### `document()`\n\nThe [`devtools::document()`](https://r-pkgs.org/whole-game.html#whole-game-document) function will create the `.Rd` files in the `man/` folder.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::document()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\nℹ Updating myPkgApp documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\nℹ Loading myPkgApp\nWriting NAMESPACE\nWriting mod_plot_ui.Rd\nWriting mod_plot_server.Rd\nWriting point_plot.Rd\nWriting mod_var_input_ui.Rd\nWriting mod_var_input_server.Rd\nWriting moviesApp.Rd\n```\n:::\n\n:::\n\n### `install()`\n\nNow I want to make sure I can install the package with [`devtools::install()`](https://r-pkgs.org/whole-game.html#install)\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::install()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n── R CMD build ────────────────────────────────────────────────────────────────\n✔  checking for file ‘/Users/mjfrigaard/projects/myPkgApp/DESCRIPTION’ ...\n─  preparing ‘myPkgApp’: (1.8s)\n✔  checking DESCRIPTION meta-information\n─  checking for LF line-endings in source and make files and shell scripts (520ms)\n─  checking for empty or unneeded directories\n   Omitted ‘LazyData’ from DESCRIPTION\n─  building ‘myPkgApp_0.1.0.tar.gz’\n   \nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD INSTALL \n  --install-tests \n* installing to library ...\n* installing *source* package ‘myPkgApp’ ...\n** using staged installation ...\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (myPkgApp)\n\n   Restarting R session...\n\n* Project '~/projects/myPkgApp' loaded. [renv 0.16.0]\nlibrary(myPkgApp)\n```\n:::\n\n:::\n\nI can also use RStudio's **Build** tools:\n\n::: {#fig-build-install .column}\n![](build-install.png){height=\"90%\" width=\"90%\" fig-align=\"center\"}\n\n**Build** install package\n:::\n\nThe **Install** icon in the **Build** pane is great, because installs the package, restarts the R session, and loads the package all with one click!\n\n::: {#fig-build-restart .column}\n![](build-restart.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\n**Build** restart and load\n:::\n\n::: column-margin\n::: {style=\"font-size: 0.85em; color: #007bff;\"}\nPackage development workflow functions are also available as keyboard shortcuts:\n\n-   **Load** = `Ctrl` + `Shift` + `L`/`Shift` + `Cmd` + `L`\n\n-   **Document** = `Ctrl` + `Shift` + `D`/`Shift` + `Cmd` + `D`\n\n-   **Install & restart** = `Ctrl` + `Shift` + `B`/`Cmd` + `Shift` + `B`\n:::\n:::\n\nThe sequence I've demonstrated above (create `.R` file, write function, document with `roxygen2`, load, document, install) is a 'minimal version' of the [full development workflow](https://r-pkgs.org/whole-game.html). If possible, you should strive to adopt all of the steps. But I've found writing and documenting the modules and utility functions (and getting them working within a call to `shinyApp()`) is an acceptable trade-off to get an initial app up and running.\n\nOnce this 'beta' version of the app is deployed, I will come back to the app to refactor, write tests, and make sure all the items in `devtools::check()` pass.\n\n#### **Recap: the `R/` folder**\n\nStoring the application's code in the `R/` folder and (using RStudio's build tools) keeps files organized, well documented, and self-contained:\n\n-   All the code is stored in the `R/` folder\n\n-   I've separated my code into smaller pieces (modules) that can be tested independently (more on this later)\n\n-   My dependencies are being managed by `roxygen2` and `devtools::document()`, which will update the `NAMESPACE` with any functions tagged with `@import` or `@importFrom`\n\n    -   I can also access functions I've written *outside* by adding `@export`\n\n<br>\n\n::: {#fig-pkg-man .column}\n![](pkg-man.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nFunction documentation in `man/` folder\n:::\n\nNow that I've handled the R version & package management *and* function documentation with the `.Rd` files, `DESCRIPTION` and `NAMESPACE`, I can move onto adding and using **data** in a shiny app package.\n\n<br>\n\n### `use_data_raw()`\n\n[`usethis::use_data()` or `usethis::use_data_raw()`](https://usethis.r-lib.org/reference/use_data.html) make it simple to add data to the application package:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_data_raw(\"movies\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n✔ Creating 'data-raw/'\n✔ Writing 'data-raw/movies.R'\n• Modify 'data-raw/movies.R'\n• Finish the data preparation script in 'data-raw/movies.R'\n• Use `usethis::use_data()` to add prepared data to package\n```\n:::\n\n:::\n\nIn the `data-raw/movies.R` script, I want to import the `movies.RData` file, but where should I import it from? It depends. In R packages, data is stored in either [`data/` or `data-raw/`](https://r-pkgs.org/data.html). To access a copy of the `movies` dataset in `myPkgApp` (i.e., with `myPkgApp::movies`), I can place the `movies.RData` file in `data-raw/` and import it by adding the following to `data-raw/movies.R`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n## code to prepare `movies` dataset goes here\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n```\n:::\n\n:::\n\nNote `data-raw/movies.R` includes a call to `usethis::use_data()`, and when it's executed, I can see a `data/` folder is created and `movies` is saved as `movies.rda`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\n```\n:::\n\n:::\n\nIf I want to test functions in `myPkgApp` using `movies.RData` (or another dataset), those should be placed in `inst/extdata/`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyPkgApp/\n    └──inst/\n         └── extdata/\n                └── movies.RData\n\n2 directories, 1 file\n```\n:::\n\n:::\n\n#### `inst/`\n\nThe neat thing about the `inst/` folder is that after we've loaded and installed our package, we can access the files in `inst/extdata/` with the [`system.file()` function](https://pkgload.r-lib.org/reference/system.file.html):\n\n::: {style=\"font-size: 0.70em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfs::dir_tree( # wrap this in a folder tree\n  system.file(\"extdata\", package = \"myPkgApp\"))\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n/Users/mjfrigaard/Library/Caches/R/renv/library/myPkgApp-1687e31a/R-4.2/x86_64-apple-darwin17.0/myPkgApp/extdata\n                                                  └── movies.RData\n```\n:::\n\n:::\n\nThe `system.file()` function will show me the path to the locally installed version of the package (hence the `/Users/mjfrigaard/Library/` at the beginning of the path). The `inst/exdata/` folder comes in handy for adding example data, but it's also useful for application development (more on that later).\n\n::: column-margin\n::: {style=\"font-size: 0.85em; color: #007bff;\"}\nTake a look at the [`inst/extdata/` folder for `readr`](https://github.com/tidyverse/readr/) and the accompanying [`readr_example()`](https://github.com/tidyverse/readr/blob/5ac729aa9a70fef297a634d2332ff8ff1af874fb/R/example.R) function to understand more about how this works.\n:::\n:::\n\n#### **Recap: App data**\n\nR Packages have a consistent and standardized way of storing data, and have designated locations for internal and external data.\n\n::: {#fig-pkg-data .column}\n![](pkg-data.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nPackage data folders\n:::\n\n### `use_readme_rmd()`\n\nFunction documentation is handled with the `R/` folder and `roxygen2` comments/tags, but I need a `README` and a place for long-form documentation.\n\nI can create a `README` file using [`usethis::use_readme_md()`](https://usethis.r-lib.org/reference/use_readme_rmd.html) or [`usethis::use_readme_rmd()`](https://usethis.r-lib.org/reference/use_readme_rmd.html). I prefer the `.Rmd` file because it comes with executable code chunks.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_readme_rmd()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n✔ Setting active project to '/Users/mjfrigaard/projects/myPkgApp'\n✔ Writing 'README.Rmd'\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n• Modify 'README.Rmd'\n• Update 'README.Rmd' to include installation instructions.\n✔ Writing '.git/hooks/pre-commit'\n```\n:::\n\n:::\n\nWhen I knit `README.Rmd`, it automatically generates the `README.md` for the package.\n\n### `use_vignette()`\n\nFor long-form documentation I can use vignettes. These can be created with [`usethis::use_vignette()`](https://usethis.r-lib.org/reference/use_vignette.html)\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_vignette(\"myPkgApp\")\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Setting VignetteBuilder field in DESCRIPTION to 'knitr'\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Writing 'vignettes/myPkgApp.Rmd'\n• Modify 'vignettes/myPkgApp.Rmd'\n```\n:::\n\n:::\n\nVignettes are written in R Markdown and rendered whenever the package is built/installed.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyPkgApp/\n    └── vignettes/\n            └── myPkgApp.Rmd\n\n1 directory, 1 file\n```\n:::\n\n:::\n\n::: column-margin\n::: {style=\"font-size: 0.85em;  color: #007bff;\"}\nImages in vignettes are kept in `man/figures/`\n:::\n\n::: {style=\"font-size: 0.65em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyPkgApp/\n  ├── vignettes/\n  │       └── myPkgApp.Rmd\n  └── man/\n      └── figures/\n          └── myPkgApp-img-1.png\n```\n:::\n\n:::\n:::\n\nBy combining `rmarkdown` and `knitr`, R packages have a documentation framework that has the added benefit of being somewhat fool-proof: vignettes have to successfully render for the package to be installed.\n\n::: {#fig-build-vignettes .column}\n![](install-vignettes.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nPackage vignettes\n:::\n\n#### **Recap: documentation**\n\nThe vignettes folder will long-form documentation about how the application works, use cases, and features (and `roxygen2` will document each function).\n\n::: {#fig-pkg-docs .column}\n![](pkg-docs.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nDocumentation in `README` and `vignettes/`\n:::\n\n### `use_testthat()`\n\nTesting is an important part of any package, and apps tend to require additional tests (especially when they're moving from 'development' into 'production' environments).\n\nTo apply the testing framework provided by the [`testthat` package.](https://testthat.r-lib.org/) package, I'll use `usethis::use_testthat()`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::use_testthat()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Setting Config/testthat/edition field in DESCRIPTION to '3'\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\n• Call `use_test()` to initialize a basic test file and open it for editing.\n```\n:::\n\n:::\n\nThis creates a new `tests/` folder, with a `testthat/` sub-folder and script.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyPkgApp/\n    └── tests/\n          ├── testthat/\n          └── testthat.R\n        \n2 directories, 1 file\n```\n:::\n\n:::\n\n#### **Recap: testing**\n\nTesting is well described in the [shiny documentation](https://shiny.rstudio.com/articles/testing-overview.html) and in [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html). Generally speaking, unit tests are performed with [`testthat`](https://testthat.r-lib.org/), and module testing can be done with [`shiny::testServer()`](https://shiny.rstudio.com/reference/shiny/1.7.0/testserver). To test the full application (or a specific behavior) use the [`shinytest2`](https://rstudio.github.io/shinytest2/) package.\n\n::: {#fig-pkg-tests .column}\n![](pkg-tests.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nTesting framework from `testthat`\n:::\n\n<br>\n\n## Use \n\n<br>\n\nUsing an app built as a package is similar to using any R function we've loaded from a package.  \n\n\n\n<br>\n\n## Recap\n\n<br>\n\nAfter successfully loading, documenting, and installing the package, I can run the app by loading the `myPkgApp` (with `library(myPkgApp)`) and `moviesApp()`:\n\n::: {#fig-myPkgApp-inst-app .column}\n![](myPkgApp-inst-app.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\n`myPkgApp::moviesApp()`\n:::\n\nI've left out some additional steps covered in R packages (license, Git/GitHub, code coverage, etc.), but I hope I've convinced you that by building a shiny app as an R package give us incremental gains in scalability.\n\n`myPkgApp` contains the code, data, documentation, and computational pan improvement over `VanillaApp`. These steps should be addressed (depending on the user's development environment), but are not required to get the application running.\n\nNext I'll cover setting up a shiny application with `golem`.\n\n# A `golem` app {#sec-myGolemApp}\n\n> `myGolemApp`: a `golem` framework app\n\n## Start\n\nTo create a new `golem` app from the console, enter the following:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"golem\")\nlibrary(golem)\ngolem::create_golem(path = \"myGolemApp\")\n```\n:::\n\n:::\n\nIf creating a `golem` app from RStudio's **New Project Wizard**, the following defaults are available:\n\n::: {#fig-golem-setup .column}\n![](golem-setup.png){height=\"70%\" width=\"70%\" fig-align=\"center\"}\n\nCreating a new `golem` shiny app\n:::\n\nThe folder tree for a new `golem` application is below:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyGolemApp\n    ├── DESCRIPTION\n    ├── NAMESPACE\n    ├── R\n    │   ├── app_config.R\n    │   ├── app_server.R\n    │   ├── app_ui.R\n    │   └── run_app.R\n    ├── dev\n    │   ├── 01_start.R\n    │   ├── 02_dev.R\n    │   ├── 03_deploy.R\n    │   └── run_dev.R\n    ├── inst\n    │   ├── app\n    │   │   └── www\n    │   │       └── favicon.ico\n    │   └── golem-config.yml\n    ├── man\n    │   └── run_app.Rd\n    ├── myGolemApp.Rproj\n    ├── renv\n    │   ├── activate.R\n    │   ├── sandbox\n    │   │   └── R-4.2\n    │   └── settings.dcf\n    └── renv.lock\n\n12 directories, 17 files\n```\n:::\n\n:::\n\n`golem` apps [**are** R packages](https://engineering-shiny.org/golem.html#understanding-golem-app-structure), so many of the the features in `myPkgApp` are available in `myGolemApp` (and lots of extras!).\n\n## Use\n\nIf you typically build shiny apps in a single `app.R` file (or in `ui.R` and `server.R` files), the `golem` framework might seem overwhelming. I'll give a quick overview of some areas I found confusing when I started using `goelm`:\n\n**Running `golem` apps:**\n\n-   `golem` apps are run using the `myGolemApp::run_app()` function (included in the `R/` folder)\n    -   To run a development version of the application, `golem` also comes with a `run_dev()` function\n\n**App files:**\n\n-   [`dev/`](https://github.com/mjfrigaard/shiny-app-setups/tree/main/myGolemApp/dev): the `dev/` folder contains `golem`'s 'guided tour' scritps and `dev/run_dev.R` (for running the 'development version' of the application):\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    myGolemApp/\n          └── dev/\n              ├── 01_start.R\n              ├── 02_dev.R\n              ├── 03_deploy.R\n              └── run_dev.R\n    ```\n    :::\n\n    :::\n\n-   [`inst/`](https://github.com/mjfrigaard/shiny-app-setups/tree/main/myGolemApp/inst): the `inst/` folder holds the `golem-config.yml` and location of any external app files.\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    myGolemApp/\n          └── inst/\n                ├── app/\n                │   └── www\n                │       └── favicon.ico\n                └── golem-config.yml\n    ```\n    :::\n\n    :::\n\n-   [`R/`](https://github.com/mjfrigaard/shiny-app-setups/tree/main/myGolemApp/R): the primary app files for the UI and server are stored in the `R/` folder (`R/app_ui.R`, `R/app_server.R`, `R/run_app.R`), as well as the configuration function (`R/app_config.R`):\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    myGolemApp/\n          └── R/\n              ├── app_config.R\n              ├── app_server.R\n              ├── app_ui.R\n              └── run_app.R\n    ```\n    :::\n\n    :::\n\n**Configure:**\n\n-   Use the `R/app_config.R` to configure the application to be run on different locations (computers *or* servers).\n\n**`dev/` folder:**\n\n-   the `dev/` folder contains `golem`'s 'guided tour' scripts (`01_start.R`, `02_dev.R`, `03_deploy.R`) and `run_dev.R` (the script run with [`golem::run_dev()`](https://github.com/ThinkR-open/golem/blob/HEAD/R/run_dev.R))\n    -   This is also where to place R scripts that aren't intended to be part of the application package.\n\n**`inst/` folder:**\n\n-   The `inst/app/www/` folder contains external files for the app (images, CSS, JavaScript, etc.)\n\n**Workflow**\n\n-   the workflow is similar to building an R package:\n    -   write functions (modules, helper functions, etc.)\\\n    -   load, document, check, test, install, etc.\\\n    -   then render application (either with `myGolemApp::run_app()` or `golem::run_dev()`)\n\n## Build\n\nThe `golem` framework has three pre-written scripts that guide users through setting up their application/package. These files are stored in the `dev/` folder (`dev/01_start.R` opens automatically).\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\nmyGolemApp/dev/\n            ├── 01_start.R\n            ├── 02_dev.R\n            ├── 03_deploy.R\n            └── run_dev.R\n\n1 directory, 4 files\n```\n:::\n\n:::\n\n### Setup\n\n-   In the setup script, users build a `DESCRIPTION` file with [`golem::fill_desc()`](https://thinkr-open.github.io/golem/reference/fill_desc.html)\n\n    -   `fill_desc()` uses [`desc` package](https://r-lib.github.io/desc/), so the sections are entered in a `key = \"value\"` format\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\"}\n    golem::fill_desc(\n      pkg_name = \"myGolemApp\",\n      pkg_title = \"An example goelm app\",\n      pkg_description = \"A working example of the golem package.\",\n      author_first_name = \"Martin\",\n      author_last_name = \"Frigaard\",\n      author_email = \"mjfrigaard@pm.me\",\n      repo_url = NULL # The URL of the GitHub Repo (optional)\n    )\n    ```\n    :::\n\n    :::\n\n-   [`golem::use_utils_ui()`](https://thinkr-open.github.io/golem/reference/utils_files.html) and [`golem::use_utils_server()`](https://thinkr-open.github.io/golem/reference/utils_files.html) provide `golem`'s UI (`R/golem_utils_ui.R`) and server (`R/golem_utils_server.R`) utility functions\n\n    -   both of these functions include `with_test = TRUE`, which build a `tests` folder (using the [`testthat` framework](https://testthat.r-lib.org/))\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    tests/testthat/\n                ├── _snaps\n                ├── test-golem-recommended.R\n                ├── test-golem_utils_server.R\n                └── test-golem_utils_ui.R\n    \n    2 directories, 4 files\n    ```\n    :::\n\n    :::\n\n-   [`golem::use_recommended_tests()`](https://thinkr-open.github.io/golem/reference/use_recommended.html) is a wrapper around `usethis::use_testthat()`\n\n    -   `golem::use_recommended_tests()` goes a step further by adding the `spelling` package to our `DESCRIPTION` and updates the `WORDLIST`\\\n    -   The tests `golem` creates in the `tests/testthat/` folder can serve as a nice guide for users new to `testthat`\n\n### Develop\n\nNew modules and utility functions can be created with [`golem::add_module()`](https://thinkr-open.github.io/golem/reference/add_module.html) and/or [`golem::add_utils()`/`golem::add_fct()`](https://thinkr-open.github.io/golem/reference/file_creation.html)\n\n-   These functions automatically include [`@noRd`](https://style.tidyverse.org/documentation.html#internal-functions), which must be removed create the `.Rd` files in the `man/` folder ([`@export`](https://roxygen2.r-lib.org/articles/namespace.html) needs to added to include functions in package `NAMESPACE`)\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    # UI module template -------------------\n    #' test UI Function\n    #'\n    #' @description A shiny Module.\n    #'\n    #' @param id,input,output,session Internal parameters for {shiny}.\n    #'\n    #' @noRd\n    #'\n    #' @importFrom shiny NS tagList\n    # server module template ---------------\n    #' test Server Functions\n    #'\n    #' @noRd\n    ```\n    :::\n\n    :::\n\n-   UI module functions end with a `_ui` suffix:\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view code in `R/mod_plot.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\"}\n    #' plot UI Function\n    #'\n    #' @param id\n    #'\n    #' @return shiny UI module\n    #' @export mod_plot_ui\n    #'\n    #' @importFrom shiny NS tagList tags\n    #' @importFrom shiny plotOutput verbatimTextOutput\n    mod_plot_ui <- function(id) {\n      ns <- shiny::NS(id)\n      shiny::tagList(\n        shiny::tags$br(),\n        shiny::tags$blockquote(\n          shiny::tags$em(\n            shiny::tags$h6(\n              \"The code for this application comes from the \",\n              shiny::tags$a(\"Building web applications with Shiny\",\n                href = \"https://rstudio-education.github.io/shiny-course/\"\n              ),\n              \"tutorial\"\n            )\n          )\n        ),\n        shiny::plotOutput(outputId = ns(\"scatterplot\"))\n      )\n    }\n    ```\n    :::\n\n    :::\n\n-   Server module functions end with a `_server` suffix:\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view code in `R/mod_plot.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\"}\n    #' plot Server Functions\n    #'\n    #' @param id module id\n    #' @param var_inputs inputs from mod_var_input\n    #'\n    #' @return shiny server module\n    #' @export mod_plot_server\n    #'\n    #' @importFrom shiny NS moduleServer reactive\n    #' @importFrom tools toTitleCase\n    #' @importFrom shiny renderPlot\n    #' @importFrom stringr str_replace_all\n    #' @importFrom ggplot2 labs theme_minimal theme\n    mod_plot_server <- function(id, var_inputs) {\n      shiny::moduleServer(id, function(input, output, session) {\n        movies <- myGolemApp::movies\n    \n        inputs <- shiny::reactive({\n          plot_title <- tools::toTitleCase(var_inputs$plot_title())\n          list(\n            x = var_inputs$x(),\n            y = var_inputs$y(),\n            z = var_inputs$z(),\n            alpha = var_inputs$alpha(),\n            size = var_inputs$size(),\n            plot_title = plot_title\n          )\n        })\n    \n        output$scatterplot <- shiny::renderPlot({\n          plot <- point_plot(\n            df = movies,\n            x_var = inputs()$x,\n            y_var = inputs()$y,\n            col_var = inputs()$z,\n            alpha_var = inputs()$alpha,\n            size_var = inputs()$size\n          )\n          plot +\n            ggplot2::labs(\n              title = inputs()$plot_title,\n              x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n              y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n            ) +\n            ggplot2::theme_minimal() +\n            ggplot2::theme(legend.position = \"bottom\")\n        })\n      })\n    }\n    \n    ## To be copied in the UI\n    # mod_plot_ui(\"plot_1\")\n    \n    ## To be copied in the server\n    # mod_plot_server(\"plot_1\")\n    ```\n    :::\n\n    :::\n\n    -   [See more module examples](https://github.com/mjfrigaard/shiny-app-setups/blob/main/myGolemApp/R)\\\n\n-   Include tests for new modules and functions using the `with_test = TRUE` argument\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    tests/testthat/\n                ├── _snaps\n                ├── test-golem-recommended.R\n                ├── test-golem_utils_server.R\n                ├── test-golem_utils_ui.R\n                ├── test-mod_plot.R\n                ├── test-mod_plot_utils_server.R\n                └── test-mod_var_input.R\n    \n    2 directories, 6 files\n    ```\n    :::\n\n    :::\n\nCSS, JavaScript, and SASS files can be included using one of `golem`'s functions for adding files to the `inst/app/www/` folder\n\n-   [`golem::add_js_file(\"script\")`](https://thinkr-open.github.io/golem/reference/add_files.html)\n\n-   [`golem::add_js_handler(\"handlers\")`](https://thinkr-open.github.io/golem/reference/add_files.html)\n\n-   [`golem::add_css_file(\"custom\")`](https://thinkr-open.github.io/golem/reference/add_files.html)\n\n-   [`golem::add_sass_file(\"custom\")`](https://thinkr-open.github.io/golem/reference/add_files.html)\n\n-   `golem` uses `app_sys()` (a wrapper around `system.file()`) to add external resources to the application\n\n    -   This function is included in the `R/app_config.R` file (I've omitted the `roxygen2` tags/comments)\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view `R/app_config.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\"}\n    # Access files in the current app\n    app_sys <- function(...) {\n      system.file(..., package = \"myGolemApp\")\n    }\n    # Read App Config\n    get_golem_config <- function(\n      value,\n      config = Sys.getenv(\n        \"GOLEM_CONFIG_ACTIVE\",\n        Sys.getenv(\n          \"R_CONFIG_ACTIVE\",\n          \"default\"\n        )\n      ),\n      use_parent = TRUE,\n      # Modify this if your config file is somewhere else\n      file = app_sys(\"golem-config.yml\")\n    ) {\n      config::get(\n        value = value,\n        config = config,\n        file = file,\n        use_parent = use_parent\n      )\n    }\n    ```\n    :::\n\n    :::\n\n-   To include other files (like images), add the image file to `inst/app/www/`, then include the path as `www` (see example UI code below)\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    shiny::mainPanel(\n      # add icon\n      shiny::tags$img(src = \"www/shiny.png\")\n    )\n    ```\n    :::\n\n    :::\n\n-   In `R/app_ui.R`, the `app_ui()` function contains the UI layout functions (`fluidPage()`, `sidebarLayout()`, etc.), and a call to `golem_add_external_resources()`:\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view `R/app_ui.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\"}\n    # app_ui() from R/app_ui.R\n    app_ui <- function(request) {\n      shiny::tagList(\n        # Leave this function for adding external resources\n        golem_add_external_resources(),\n        # Your application UI logic\n        shiny::fluidPage(\n          shiny::tags$h1(\"myGolemApp\"),\n          shiny::sidebarLayout(\n            shiny::sidebarPanel(\n              mod_var_input_ui(\"vars\")\n            ),\n            shiny::mainPanel(\n              # add icon\n              shiny::tags$img(src = \"www/shiny.png\"),\n              mod_plot_ui(\"plot\")\n            )\n          )\n        )\n      )\n    }\n    # this is also included in the app_ui.R script\n    golem_add_external_resources <- function() {\n      add_resource_path(\n        \"www\",\n        app_sys(\"app/www\")\n      )\n      tags$head(\n        favicon(),\n        bundle_resources(\n          path = app_sys(\"app/www\"),\n          app_title = \"myGolemApp\"\n        )\n        # Add here other external resources\n        # for example, you can add shinyalert::useShinyalert()\n      )\n    }\n    ```\n    :::\n\n    :::\n\n-   The [`R/app_config.R` file](https://github.com/mjfrigaard/shiny-app-setups/blob/main/myGolemApp/R/app_config.R) contains two functions: `app_sys()` (covered above) and `get_golem_config()`, which reads the `inst/golem-config.yml` configuration file\n\n    -   [`golem-config.yml`](https://engineering-shiny.org/golem.html#manipulating-golem-config.yml) gives access to the app version, name, and (development) working directory, so it can be used to add \"production-only elements\" and is \"shareable across golem projects\"\\\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    default:\n      golem_name: golex\n      golem_version: 0.0.0.9000\n      app_prod: no\n    production:\n      app_prod: yes\n    dev:\n      golem_wd: !expr here::here()\n    ```\n    :::\n\n    :::\n\n-   The final step in the guided tour contains functions for deploying a new application to Posit Connect or Docker\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view code in `dev/03_deploy.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\"}\n    ## Run checks ----\n    ## Check the package before sending to prod\n    devtools::check()\n    rhub::check_for_cran()\n    \n    # Deploy\n    \n    ## Local, CRAN or Package Manager ----\n    ## This will build a tar.gz that can be installed locally,\n    ## sent to CRAN, or to a package manager\n    devtools::build()\n    \n    ## RStudio ----\n    ## If you want to deploy on RStudio related platforms\n    golem::add_rstudioconnect_file()\n    golem::add_shinyappsio_file()\n    golem::add_shinyserver_file()\n    \n    ## Docker ----\n    ## If you want to deploy via a generic Dockerfile\n    golem::add_dockerfile_with_renv()\n    \n    ## If you want to deploy to ShinyProxy\n    golem::add_dockerfile_with_renv_shinyproxy()\n    ```\n    :::\n\n    :::\n\n    -   RStudio (Posit) Connect\n        -   [`golem::add_rstudioconnect_file()`](https://thinkr-open.github.io/golem/reference/rstudio_deploy.html), [`golem::add_shinyappsio_file()`](https://thinkr-open.github.io/golem/reference/rstudio_deploy.html), and [`golem::add_shinyserver_file()`](https://thinkr-open.github.io/golem/reference/rstudio_deploy.html)\n    -   Docker\n        -   [`golem::add_dockerfile_with_renv()`](https://thinkr-open.github.io/golem/reference/dockerfiles.html) and [`golem::add_dockerfile_with_renv_shinyproxy()`](https://thinkr-open.github.io/golem/reference/dockerfiles.html)\n\n## Recap\n\nGenerally speaking, `golem`'s start-up scripts save time and serves as a gentle introduction to some of the functions used in R package development. The additional `dev` functions is an area where (I think) `golem` really separates itself from standard R packages. Having dedicated shiny development functions (and a `dev/` folder) reduces the cognitive overhead of mapping the standard R package development functions (i.e., those from `usethis` and `devtools`) into shiny-specific development.\n\n::: {#fig-golem .column}\n![](myGolemApp-compare.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\n`myGolemApp`\n:::\n\n`golem` is a popular framework for a reason--it's designed to allow developers to build a shiny application and R package simultaneously. Added bonuses include taking advantage of RStudio's build tools, great [documentation](https://engineering-shiny.org/index.html), and [user-guides.](https://thinkr-open.github.io/golem/index.html).\n\n# A `leprechaun` app {#sec-myLeprechaunApp}\n\n> `myLeprechaunApp`: a `leprechaun` framework app\n\n`leprechaun` apps are built using the same methods as R packages (`devtools` and `usethis`), but are intended to be a 'leaner and smaller' version of `golem`.\n\n***What does 'leaner and smaller' mean?***\n\n`leprechaun` doesn't add itself as a dependency (i.e., I don't need to add `leprechaun` to the list of `Imports` in my `DESCRIPTION` or `NAMESPACE` of `myLeprechaunApp`). It's worth reading, [\"the golem in the room\"](https://leprechaun.opifex.org/#/#the-golem-in-the-room) on the package website, because it covers the differences between the two packages (and why you might choose one over the other).\n\n## Start\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nusethis::create_package(\"myLeprechaunApp\")\n```\n:::\n\n:::\n\nWhen creating a new `leprechaun` package in the IDE, it's identical to the R package setup.\n\n::: {#fig-leprechaun-setup .column}\n![](leprechaun-setup.png){height=\"70%\" width=\"70%\" fig-align=\"center\"}\n\n`myLeprechaunApp`\n:::\n\nAfter the new project opens, install and load the `leprechaun` package, then run `leprechaun::scaffold()`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ninstall.packages(\"leprechaun\")\nlibrary(leprechaun)\nleprechaun::scaffold()\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"false\"}\n── Scaffolding leprechaun app ─────────────────────────────────────────────────\n\n── Creating lock file ──\n\n✔ Creating .leprechaun\n\n── Adding dependencies ──\n\n✔ Adding 'shiny' to Imports in DESCRIPTION\n✔ Adding 'bslib' to Imports in DESCRIPTION\n✔ Adding 'htmltools' to Imports in DESCRIPTION\n✔ Adding 'pkgload' to Suggests in DESCRIPTION\n\n\n── Generating code ──\n\n✔ Creating R/ui.R\n✔ Creating R/assets.R\n✔ Creating R/run.R\n✔ Creating R/server.R\n✔ Creating R/leprechaun-utils.R\n✔ Creating R/_disable_autoload.R\n✔ Creating R/zzz.R\n✔ Creating R/input-handlers.R\n\n✔ Creating inst/dev\n✔ Creating inst/assets\n✔ Creating inst/img\n✔ Creating inst/run/app.R\n```\n:::\n\n:::\n\nThis results in the following folder tree:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.bash .cell-code  code-fold=\"show\"}\nmyLeprechaunApp/\n      ├── DESCRIPTION\n      ├── NAMESPACE\n      ├── R/\n      │   ├── _disable_autoload.R\n      │   ├── assets.R\n      │   ├── input-handlers.R\n      │   ├── leprechaun-utils.R\n      │   ├── run.R\n      │   ├── server.R\n      │   ├── ui.R\n      │   └── zzz.R\n      ├── inst/\n      │   ├── assets\n      │   ├── dev\n      │   ├── img\n      │   └── run\n      │       └── app.R\n      └── myLeprechaunApp.Rproj\n      \n      7 directories, 12 files\n```\n:::\n\n:::\n\n## Use\n\n**Running `leprechaun` apps:**\n\nAfter creating a `leprechaun` package, I can run the application with `run()` after loading and documenting with devtools.\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndevtools::load_all()\ndevtools::document()\nlibrary(myLeprechaunApp)\nrun()\n```\n:::\n\n:::\n\nThe output below shows that--unlike `golem` apps--`leprechaun` includes the functions in the `R/` folder as part of the `myLeprechaunApp` package.\n\n<br>\n\n::: {#fig-leprechaun-run .column}\n![](myLeprechaunApp-run.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nrun `myLeprechaunApp`\n:::\n\n**App files:**\n\n-   `R/`: the [`R/` folder](https://github.com/mjfrigaard/shiny-app-setups/tree/main/myLeprechaunApp/R) contains standard `ui.R`, `server.R` files, as well as the `run.R` function for running the app.\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    myLeprechaunApp/\n          └── R/\n              ├── _disable_autoload.R\n              ├── assets.R\n              ├── input-handlers.R\n              ├── leprechaun-utils.R\n              ├── run.R\n              ├── server.R\n              ├── ui.R\n              └── zzz.R\n          \n          1 directory, 8 files\n    ```\n    :::\n\n    :::\n\n    -   The additional files are specific to the `leprechaun` framework/workflow.\n\n**Configure:**\n\n`leprechaun` app configuration files use the [config](https://rstudio.github.io/config/articles/introduction.html) package (similar to `golem`). Unlike the golem package, it's not assumed I'll be using a `config.yml` file, but I can easily add one with [`leprechaun::use_config()`](https://leprechaun.opifex.org/#/guide/use#config).\n\n-   `use_config()` adds a `inst/config.yml` and `R/config.R`\n\n-   The default value in the `config.yml` files is `production: true`, which can be read using `config_read()` in `R/config.R`.\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    config_read()\n    ```\n    :::\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code}\n    $production\n    [1] TRUE\n    ```\n    :::\n\n    :::\n\n    -   Values can be added to `inst/config.yml` using the [config file format](https://biostat.app.vumc.org/wiki/Main/YamlR), then the `CONFIG_FILE` can be set as [an environment variable](https://rstudio.github.io/config/articles/introduction.html#configurations)\n\n**`dev/` folder:**\n\nThe `dev/` folder is inside the `inst/` folder, which means it's contents are available using `system.file()` when the package is installed.\n\n**`inst/` folder:**\n\n-   [`inst/` folder](https://github.com/mjfrigaard/shiny-app-setups/tree/main/myLeprechaunApp/inst): the `inst/` folder contains folders for including\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.bash .cell-code  code-fold=\"false\"}\n    myLeprechaunApp/\n        └── inst/\n              ├── assets/\n              ├── dev/\n              ├── img/\n              └── run/\n                  └── app.R\n          \n          5 directories, 1 file\n    ```\n    :::\n\n    :::\n\n    -   `leprechaun` apps are packages, so the `inst/` folder holds the external files for the application (and are available when the package is installed).\n\n**Workflow:**\n\nTwo examples of `leprechaun` apps are available on the package website (basic and lit). I will adapt elements of these in the Develop section below, but\n\n## Build\n\n### Setup\n\n#### `R/`\n\n-   The initial application files are created using [`leprechaun::scaffold()`](https://leprechaun.opifex.org/#/reference/scaffold), which takes the following options as function arguments:\n\n    -   `ui` controls the application layout (can be `\"fluidPage\"` or `\"navbarPage\"`, defaults to `\"navbarPage\"`)\n    -   `bs_version` Bootstrap version (\"*If shiny \\> 1.6 is installed defaults to version 5, otherwise version 4\"* )\n    -   `overwrite`: Overwrite all files?\\\n\n-   `assets.R`: contains the `serveAssets()` function, which will identify the modules using CSS or JavaScript and create `dependencies`, a list of metadata on the app. If you don't have any of these modules, you'll only see the following:\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view code in `R/assets.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    serveAssets()\n    ```\n    :::\n\n\n    ``` bash\n      [[1]]\n      List of 10\n       $ name      : chr \"myLeprechaunApp\"\n       $ version   : chr \"0.0.0.9000\"\n       $ src       :List of 1\n        ..$ file: chr \".\"\n       $ meta      : NULL\n       $ script    : Named chr(0) \n        ..- attr(*, \"names\")= chr(0) \n       $ stylesheet: Named chr \"html/R.css\"\n        ..- attr(*, \"names\")= chr \"file\"\n       $ head      : NULL\n       $ attachment: NULL\n       $ package   : chr \"myLeprechaunApp\"\n       $ all_files : logi TRUE\n       - attr(*, \"class\")= chr \"html_dependency\"\n    ```\n    :::\n\n    ::: {style=\"font-size: 0.80em; ; color: #696969;\"}\n    *Click on Code to view code in `R/assets.R`*\n    :::\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\"}\n    #' Dependencies\n    #'\n    #' @param modules JavaScript files names that require\n    #' the `type = module`.\n    #' @importFrom htmltools htmlDependency\n    #'\n    #' @keywords internal\n    serveAssets <- function(modules = NULL) {\n      # JavaScript files\n      javascript <- list.files(\n        system.file(package = \"myLeprechaunApp\"),\n        recursive = TRUE,\n        pattern = \".js$\"\n      )\n    \n      modules <- get_modules(javascript, modules)\n      javascript <- remove_modules(javascript, modules)\n    \n      # CSS files\n      css <- list.files(\n        system.file(package = \"myLeprechaunApp\"),\n        recursive = TRUE,\n        pattern = \".css$\"\n      )\n    \n      # so dependency processes correctly\n      names(css) <- rep(\"file\", length(css))\n      names(javascript) <- rep(\"file\", length(javascript))\n    \n      # serve dependencies\n      dependencies <- list()\n    \n      standard <- htmlDependency(\n        \"myLeprechaunApp\",\n        version = utils::packageVersion(\"myLeprechaunApp\"),\n        package = \"myLeprechaunApp\",\n        src = \".\",\n        script = javascript,\n        stylesheet = css\n      )\n      dependencies <- append(dependencies, list(standard))\n    \n      if (!is.null(modules)) {\n        modules <- htmlDependency(\n          \"myLeprechaunApp-modules\",\n          version = utils::packageVersion(\"myLeprechaunApp\"),\n          package = \"myLeprechaunApp\",\n          src = \".\",\n          script = modules,\n          meta = list(type = \"module\")\n        )\n        dependencies <- append(dependencies, list(modules))\n      }\n    \n      return(dependencies)\n    }\n    \n    #' Module\n    #'\n    #' Retrieve and add modules from a vector of files.\n    #'\n    #' @param files JavaScript files\n    #' @param modules JavaScript files names that require\n    #' the `type = module`.\n    #' @importFrom htmltools htmlDependency\n    #'\n    #' @keywords internal\n    #' @name js-modules\n    remove_modules <- function(files, modules) {\n      if (is.null(modules)) {\n        return(files)\n      }\n    \n      # make pattern\n      pattern <- collapse_files(modules)\n    \n      # remove modules\n      files[!grepl(pattern, files)]\n    }\n    \n    #' @rdname js-modules\n    #' @keywords internal\n    get_modules <- function(files, modules) {\n      if (is.null(modules)) {\n        return(NULL)\n      }\n    \n      # make pattern\n      pattern <- collapse_files(modules)\n    \n      # remove modules\n      files[grepl(pattern, files)]\n    }\n    \n    # collapse files into a pattern\n    collapse_files <- function(files) {\n      pattern <- paste0(files, collapse = \"$|\")\n      paste0(pattern, \"$\")\n    }\n    ```\n    :::\n\n    :::\n\n-   `disable_autoload.R`\n\n-   `input-handlers.R`\n\n-   `leprechaun-utils.R`\n\n-   `run.R`\n\n-   `server.R`\n\n-   `ui.R`\n\n-   `zzz.R`\n\nThis contains the function for adding images to the application.\n\n### Develop\n\nThe [`leprechaun::scaffold()`](https://leprechaun.opifex.org/#/reference/scaffold) defaults to a `navbarPage()`, but I've switched it to a `fluidPage()`. After running `devtools::load_all()` and `devtools::document()`, I can run the application with `run()`.\n\nCreating modules is simple with [`leprechaun::add_module()`](https://leprechaun.opifex.org/#/reference/add_module). Similar to `golem`, this creates functions for the UI and server portions of the module.\n\n-   The initial UI module:\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\"}\n    #' var_input UI\n    #' \n    #' @param id Unique id for module instance.\n    #' \n    #' @keywords internal\n    var_inputUI <- function(id){\n    \tns <- NS(id)\n    \n    \ttagList(\n    \t\th2(\"var_input\"),\n    \n    \t)\n    }\n    ```\n    :::\n\n    :::\n\n-   The initial server module:\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\"}\n    #' var_input Server\n    #' \n    #' @param id Unique id for module instance.\n    #' \n    #' @keywords internal\n    var_input_server <- function(id){\n    \tmoduleServer(\n    \t\tid,\n    \t\tfunction(\n    \t\t\tinput, \n    \t\t\toutput, \n    \t\t\tsession\n    \t\t\t){\n    \t\t\t\t\n    \t\t\t\tns <- session$ns\n    \t\t\t\tsend_message <- make_send_message(session)\n    \n    \t\t\t\t# your code here\n    \t\t}\n    \t)\n    }\n    \n    # UI\n    # var_inputUI('id')\n    \n    # server\n    # var_input_server('id')\n    ```\n    :::\n\n    :::\n\nThe module contents are similar to `golem`, but instead of using the `@noRd` tag, these functions include `@keywords internal` (which can be used to [document your package](https://roxygen2.r-lib.org/articles/rd-other.html?q=@keywords#packages)).\n\n-   In order to this, run `usethis::use_package_doc()` and a script will be created in `R/` with the following contents:\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"false\"}\n    #' @keywords internal\n    \"_PACKAGE\"\n    \n    ## usethis namespace: start\n    ## usethis namespace: end\n    NULL\n    ```\n    :::\n\n    :::\n\nAfter creating the modules, adding them to the UI and server is straightforward.\n\n-   The `R/ui.R` file:\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\"}\n    #' Shiny UI\n    #'\n    #' Core UI of package.\n    #'\n    #' @param req The request object.\n    #'\n    #' @import shiny\n    #' @importFrom bslib bs_theme\n    #'\n    #' @keywords internal\n    ui <- function(req) {\n      shiny::fluidPage(\n        theme = bs_theme(version = 5),\n        assets(),\n        shiny::tags$h1(\"myLeprechaunApp\"),\n        shiny::sidebarLayout(\n          shiny::sidebarPanel(\n            var_inputUI(\"vars\")\n          ),\n          shiny::mainPanel(\n            plotUI(\"plot\")\n          )\n        )\n      )\n    }\n    ```\n    :::\n\n    :::\n\n-   The `R/server.R` file:\n\n    ::: {style=\"font-size: 0.80em;\"}\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"show\"}\n    #' Server\n    #'\n    #' Core server function.\n    #'\n    #' @param input,output Input and output list objects\n    #' containing said registered inputs and outputs.\n    #' @param session Shiny session.\n    #'\n    #' @noRd\n    #' @keywords internal\n    server <- function(input, output, session){\n    \n    \tsend_message <- make_send_message(session)\n    \n    \t   selected_vars <- var_input_server(\"vars\")\n    \n         plot_server(\"plot\", var_inputs = selected_vars)\n    }\n    ```\n    :::\n\n    :::\n\n::: {#fig-full-run .column}\n![](myLeprechaun-run.png){height=\"100%\" width=\"100%\" fig-align=\"center\"}\n\nrun `myLeprechaunApp`\n:::\n\n#### `inst/`\n\nI'll demonstrate how the `inst/` folder works using the [basic example](https://leprechaun.opifex.org/#/examples/basic) from the package website.\n\nFirst I run `leprechaun::use_sass()`\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nleprechaun::use_sass()\n```\n:::\n\n:::\n\nThe prints the warning,\n\n::: {style=\"font-size: 0.80em;\"}\n``` bash\n! This requires leprechaun::build() or the leprechaun::build_roclet\n```\n:::\n\nand following file is added to `dev/`\n\n#### `dev/`\n\n::: {style=\"font-size: 0.80em;\"}\n``` bash\ninst/\n    ├── assets/\n    │   └── style.min.css\n    ├── config.yml\n    ├── dev/\n    │   └── sass.R\n    ├── img/\n    └── run\n        └── app.R\n```\n:::\n\nThe `inst/dev/sass.R` file contains the `sass_build()` function, which will look in the `scss/` folder for `main.scss` and create the `inst/assets/style.min.css` file.\n\nThe `scss/` folder was create with `use_sass()`, and it holds two scss files:\n\n::: {style=\"font-size: 0.80em;\"}\n``` bash\n# inst/ & scss/ folders\n  ├── inst/\n  │   ├── assets\n  │   ├── config.yml\n  │   ├── dev/\n  │   │   └── sass.R\n  │   ├── img/\n  │   └── run\n  │       └── app.R\n  └── scss/\n      ├── _core.scss\n      └── main.scss\n```\n:::\n\n`_core.scss` is the file I make changes in,\n\n::: {style=\"font-size: 0.80em;\"}\n``` scss\n$accent: #38B44A;\n\nhtml{\n    h1 {\n        color: $accent;\n    }\n}\n```\n:::\n\nThen save this file, run `leprechaun::build()`\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nleprechaun::build()\n```\n:::\n\n:::\n\nNow run the regular package development functions (`devtools::load_all()` and `devtools::document()`), restart and install.\n\n::: {style=\"font-size: 0.80em;\"}\n``` bash\n✔ Running sass.R\n```\n:::\n\n#### `assets/`\n\nAfter adding the `scss/` folder and R script in `inst/dev/`, I can re-check the `serveAssets()` function:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nserveAssets()\n```\n:::\n\n\n``` bash\n[[1]]\nList of 10\n $ name      : chr \"myLeprechaunApp\"\n $ version   : chr \"0.0.0.9000\"\n $ src       :List of 1\n  ..$ file: chr \".\"\n $ meta      : NULL\n $ script    : Named chr(0) \n  ..- attr(*, \"names\")= chr(0) \n $ stylesheet: Named chr [1:2] \"assets/style.min.css\" \"html/R.css\"\n  ..- attr(*, \"names\")= chr [1:2] \"file\" \"file\"\n $ head      : NULL\n $ attachment: NULL\n $ package   : chr \"myLeprechaunApp\"\n $ all_files : logi TRUE\n - attr(*, \"class\")= chr \"html_dependency\"\n```\n:::\n\nThis shows me `stylesheet` has been updated with `assets/style.min.css` and `html/R.css` (these files are loaded into the application when it runs).\n\nLet's try another example using [`packer`](https://packer.john-coene.com/#/)!\n\n#### `packer`\n\n`packer` is a package for using JavaScript with R and provides a collection of functions for\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npacker::scaffold_leprechaun()\n```\n:::\n\n\n``` bash\n── Scaffolding leprechaun ────────────────────────────────────────────────────\n✔ Initialiased npm\n✔ webpack, webpack-cli, webpack-merge installed with scope \"dev\" \n✔ Added npm scripts\n✔ Created srcjs directory\n✔ Created srcjs/config directory\n✔ Created webpack config files\n\n── Adding files to .gitignore and .Rbuildignore ──\n\n✔ Setting active project to '/Users/mjfrigaard/projects/myLeprechaunApp'\n\n── Scaffold built ──\n\nℹ Run `bundle` to build the JavaScript files\nℹ Run `leprechaun::use_packer()`\n```\n:::\n\nAfter we've built the scaffolding for the .js files, we need to make sure R knows we're using `packer`, which we can do with `use_packer()`:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nleprechaun::use_packer()\n```\n:::\n\n\n``` bash\n✔ Creating inst/dev/packer.R\n✔ Adding 'packer' to Suggests in DESCRIPTION\n! This requires `leprechaun::build()` or the `leprechaun::build_roclet`\n```\n:::\n\nThe `inst/dev/packer.R` contains `packer_bundle()` (for bundling the packer files), but in order to run this we need to run `leprechaun::build()`\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nleprechaun::build()\n```\n:::\n\n\n``` bash\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n```\n:::\n\nNow we can add the following code to the `R/server.R` file:\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# server.R\nserver <- function(input, output, session){\n    send_message <- make_send_message(session)\n    # send a message to show an alert\n    send_message(\"show-packer\", text = \"HELLO!\")    \n}\n```\n:::\n\n:::\n\n#### `npm_install`\n\n::: {style=\"font-size: 0.80em;\"}\n\n::: {.cell}\n\n```{.r .cell-code}\npacker::npm_install(\"lit\", scope = \"prod\")\n```\n:::\n\n\n``` bash\n✔ lit installed with scope \"prod\" \n```\n:::\n\n#### `img/`\n\n#### `run/`\n\n#### `run/app.R`\n\n## Recap\n\n# A `rhino` app {#sec-myRhinoApp}\n\n> `myRhinoApp`: a `rhino` framework app\n\n## Final thoughts\n\nFrameworks that assemble the application as an R package give access to RStudio's tools for developing, documenting, and testing. Some practices that are shared across shiny frameworks include:\n\n1.  Use `DESCRIPTION` and `NAMESPACE` files to document your application's metadata and dependencies, and [`renv`](https://rstudio.github.io/renv/articles/renv.html) to record the R/package versions.\n\n2.  Use `roxygen2` and write long-form documentation in `vignettes/`\n\n3.  Separate the application into distinct '[chunks](https://dictionary.apa.org/chunking),' preferably in [modules.](https://mastering-shiny.org/scaling-modules.html)\n\n4.  Plan and implement a formal testing structure with [`testthat`](https://testthat.r-lib.org/) and [`shinytest2`](https://rstudio.github.io/shinytest2/)\n\n5.  Organize the project folders to allow for development (`dev/`) and external resources (`inst/`)\n\nUsing a framework to build your shiny application can be thought of as having a floor plan for a house--it doesn't have to be elaborate, but you wouldn't want to live in a house that didn't have one.\n\n::: {#fig-floorplan .column}\n![](floorplan.png){height=\"75%\" width=\"75%\" fig-align=\"center\"}\n\nBasic [floor plan](https://www.homedepot.com/c/ab/how-to-draw-a-floor-plan/9ba683603be9fa5395fab90118babc83)\n:::\n\nFurthermore, when you start thinking of your work in R as packages, you can start to think about how they fit together into bigger plans.\n\n::: {#fig-site-plan .column}\n![](site.png){height=\"75%\" width=\"75%\" fig-align=\"center\"}\n\nPart of a bigger [site plan](http://www.aftonvillage.com/afton-village-site-map/)\n:::\n\n\n```{=html}\n<!--\n# What is missing?\n\nBelow are some 'big picture' items I'd want to address for a scalable shiny app project:\n\n1.  **Code organization:** a scalable method of handling possible (or *inevitable*?) increases in codebase size and complexity:\n    -   [ ] How am I managing large utility/helper functions?\n    -   [ ] Can my code be broken up into smaller pieces?\n    -   [ ] How do I access the functions I'm writing within the app?\n2.  **Data:** designated locations for internal and external data\n    -   [ ] How are datasets used *in the application* should be loaded, tested, and documented?\n    -   [ ] How are *External datasets* used in the application (for examples or testing?)\n3.  **Documentation:** self-contained information about how the application works, use-cases, etc.\n    -   [ ] Where can I document important use cases or features?\n    -   [ ] Where do I put the long-form documentation to help instruct users (and future me!) how to test and debug `VanillaApp`?\n4.  **Testing:** the ability to perform (and automate) multiple kinds of tests:\n    -   [ ] Can I perform unit tests on the utility functions?\n    -   [ ] Can I run and test different components of my application independently?\n    -   [ ] Can I perform integration/application tests?\n    -   [ ] Can I perform system/load tests? \\*\\*\\*\n-->\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}