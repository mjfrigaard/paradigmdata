[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ParadigmDataGroup, LLC",
    "section": "",
    "text": "Welcome to Paradigm Data Group, LLC.\n\nWe provide data science training and solutions from Posit (formerly RStudio) certified instructors.\n\nTrainings\nExamples of our workshops:\n\nODSC East ggplot2: R Markdown website & slides\nODSC West ggplot2: Quarto website & slides\nData Management, R Markdown, Shiny intro (R Markdown website & slides)\n\n\n\nDashboards\nExample dashboards:\n\nCannabis Sales Dashboard\nCalFresh Outreach Program Dashboard\n\n\n\nContact\nPlease reach out to Martin (mfrigaard(at)paradigmdata.io) or Peter (pspangler(at)paradigmdata.io) for questions or information on training, dashboards, or anything #rstats!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Who we are",
    "section": "",
    "text": "Peter Spangler\n\n\n\n\n\n\n\n\n\nPeter Spangler is a hands-on data science leader with a business-focused approach to building data science solutions and telling stories with data. Experienced in translating business problems into data products using advanced statistical techniques and ML to support decision-making in a variety of rapid growth environments. Scaled data science solutions for user acquisition, retention, channel optimization, revenue, and fraud at Lyft, Alibaba, Citrix and Nextdoor. He is currently the Head of Marketing Analytics Toast."
  },
  {
    "objectID": "pages/posts/vanilla-shiny/vanilla-shiny.html",
    "href": "pages/posts/vanilla-shiny/vanilla-shiny.html",
    "title": "Shiny frameworks (part 1, vanilla shiny)",
    "section": "",
    "text": "This post is the first in a series demonstrating how to build shiny apps using a variety of frameworks. I will focus on three technical areas: Start, Build, and Use.\nThis series was inspired by a Medium article that provided excellent guidance when considering shiny application frameworks. The author compared a ‘vanilla shiny’ (bare-bones shiny application), golem, leprechaun, and rhino across a series of dimensions (framework reliability, target type of developer, overall developing experience, etc.).\nI’ll be covering the three areas mentioned above, and also be comparing a shiny built as an R package (i.e., devtools and usethis). The GitHub repo with all shiny app setups is here."
  },
  {
    "objectID": "pages/posts/vanilla-shiny/vanilla-shiny.html#start",
    "href": "pages/posts/vanilla-shiny/vanilla-shiny.html#start",
    "title": "Shiny frameworks (part 1, vanilla shiny)",
    "section": "Start",
    "text": "Start\n\n\ninstall.packages(\"shiny\")\nlibrary(shiny)\n\n\nCreating a new ‘vanilla’ shiny app from RStudio’s New Project Wizard gives the following default options:\n\n\n\n\n\nFigure 1: New shiny app\n\n\n\nWhen we create VanillaApp, we see a folder with the following files:\n\n\nVanillaApp/\n    ├── VanillaApp.Rproj\n    ├── app.R\n    ├── renv\n    └── renv.lock\n    \n2 directories, 3 files"
  },
  {
    "objectID": "pages/posts/vanilla-shiny/vanilla-shiny.html#build",
    "href": "pages/posts/vanilla-shiny/vanilla-shiny.html#build",
    "title": "Shiny frameworks (part 1, vanilla shiny)",
    "section": "Build",
    "text": "Build\n\nThe code for the VanillaApp app is in app.R (it comes from the RStudio shiny tutorial, “Building web applications with Shiny”).\n\nClick on Code to view code in app.R\n\n\n\nCode# Define UI ------------\nui <- fluidPage(\n  \n  titlePanel(title = \"movies data app (demo)\"),\n  \n  shiny::sidebarLayout(\n    \n    shiny::sidebarPanel(\n      \n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      \n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      \n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      \n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n      \n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n      \n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      \n      shiny::tags$br(),\n      \n        shiny::tags$blockquote(\n          shiny::tags$em(\n            shiny::tags$h6(\"The code for this application comes from the \",\n            shiny::tags$a(\"Building web applications with Shiny\", \n              href = \"https://rstudio-education.github.io/shiny-course/\"), \n                          \"tutorial\"))),\n      \n      shiny::plotOutput(outputId = \"scatterplot\")\n    )\n  )\n)\n\n# Define server -------\n\nserver <- function(input, output, session) {\n  output$scatterplot <- shiny::renderPlot({\n    plot <- point_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    )\n    plot +\n      ggplot2::labs(\n        title = input$plot_title,\n        x = stringr::str_replace_all(tools::toTitleCase(input$x), \"_\", \" \"),\n        y = stringr::str_replace_all(tools::toTitleCase(input$y), \"_\", \" \")\n      )\n  })\n}\n\n# Create App ------------------\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\nThis is a fairly simple application, but as we can see, it imports data (movies.RData) and a requires a helper function stored in utils.R.\n\nClick on Code to view code in utils.R\n\n\n\nCode# pkgs -----\nlibrary(ggplot2)\n\n# point_plot -----\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n  ggplot2::ggplot(\n    data = df,\n    ggplot2::aes(\n      x = .data[[x_var]],\n      y = .data[[y_var]],\n      color = .data[[col_var]]\n    )\n  ) +\n    ggplot2::geom_point(alpha = alpha_var, size = size_var)\n}\n\n\n\nIn my project, I can drop movies.RData and utils.R and these in the top-level folder.\n\n\nVanillaApp/\n        ├── VanillaApp.Rproj\n        ├── app.R\n        ├── movies.RData\n        ├── renv\n        ├── renv.lock\n        └── utils.R\n\n2 directories, 5 files\n\n\n\nrenv/\n\n\n\n\n\n\nrenv\n\n\n\n\n\n\n\n\n\n\nrenv records the version of R + R packages being used in a project, and provides tools for reinstalling the declared versions of those packages in a project\n\n\n\n\n\nThe renv folder and renv.lock file store the R version and package dependencies for my app. This is evident by the R-4.2 under renv/library and renv/sandbox in the folder tree above.\nTo keep renv/ updated, when I install a package with install.packages(), I also need to make sure to include a call to renv::snapshot().\nSee the example with shiny, ggplot2, dplyr and tools below:\n\n\n# install packages \ninstall.packages(c(\"shiny\", \"ggplot2\", \"dplyr\", \"tools\"))\n\n\nInstalling shiny [1.7.4] ...\n    OK [linked cache]\n# Installing <package> [version] ..\n#  OK [linked cache]\n# Installing <package> [version] ..\n#  OK [linked cache]\n# Installing <package> [version] ..\n#  OK [linked cache]\nInstalling dplyr [1.1.0] ...\n    OK [linked cache]\n\n\nrenv::snapshot() records the packages it in renv.lock file.\n\n\n# save declared versions of packages \nrenv::snapshot()\n\n\n* Lockfile written to '~/projects/VanillaApp/renv.lock'.\n\n\n\nRead more about getting started with renv and using renv in package development"
  },
  {
    "objectID": "pages/posts/vanilla-shiny/vanilla-shiny.html#use",
    "href": "pages/posts/vanilla-shiny/vanilla-shiny.html#use",
    "title": "Shiny frameworks (part 1, vanilla shiny)",
    "section": "Use",
    "text": "Use\nTo use VanillaApp, we can click on Run App in the app.R file:\n\n\n\n\n\nFigure 2: Run VanillaApp"
  },
  {
    "objectID": "pages/posts/vanilla-shiny/vanilla-shiny.html#recap",
    "href": "pages/posts/vanilla-shiny/vanilla-shiny.html#recap",
    "title": "Shiny frameworks (part 1, vanilla shiny)",
    "section": "Recap",
    "text": "Recap\nVanillaApp is now a functioning shiny app, but it’s difficult to scale in it’s current structure. As the app codebase grows in complexity, the app.R (or ui.R and server.R) might reach thousands of lines of code.\nIn the next post, I’ll cover developing a shiny app as an R package."
  },
  {
    "objectID": "pages/posts/box/box.html",
    "href": "pages/posts/box/box.html",
    "title": "Writing modular code with box\n",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis post is currently under development. Thank you for your patience."
  },
  {
    "objectID": "pages/posts/box/box.html#what-is-box",
    "href": "pages/posts/box/box.html#what-is-box",
    "title": "Writing modular code with box\n",
    "section": "What is box?",
    "text": "What is box?\nbox is a package…"
  },
  {
    "objectID": "pages/posts/box/box.html#how-box-works",
    "href": "pages/posts/box/box.html#how-box-works",
    "title": "Writing modular code with box\n",
    "section": "How box works",
    "text": "How box works\nTo understand how box works, let’s refresh how we normally interact with packages and their functions when using R and developing packages:\n\nAssume I want to use the foo() function from the pkg package. The first step is to install it with install.packages(\"pkg\")\n\nTo use the functions in pkg:\n\nI need to run library(pkg) in my R session, which loads the pkg namespace ‘and attach[es] it on the search list.’\n\nIf I try to use a function (foo()) from a package (pkg) that hasn’t been loaded with library(pkg) or require(pkg), I see the following:\n\nfoo(x)\nError in foo(x) : could not find function 'foo'\n\n\nThis error can be confusing, because it’s not telling me if the package hasn’t been installed or if the package hasn’t been loaded.\n\nIf I try to use a function (foo()) from a package (pkg) that hasn’t been installed with install.packages(), I get the following error:\n\npkg::foo(x)\nError in loadNamespace(x) : there is no package called ‘pkg’\n\n\nAfter installing pkg, I can get around using library(pkg) by being explicit and using pkg::foo(), which tells R I want to use the foo() function from the pkg namespace\n\n\nRead more about namespaces in Advanced R and R packages.\n\n\n\nIf I am developing an R package, I can include pkg functions in my package by using roxygen2 tags (i.e., #' @importFrom pkg foo)\n\nWhen I use devtools::document(), the tags are converted into directives in the NAMESPACE (i.e., importFrom(pkg,foo))\nI also need to use usethis::use_package(\"pkg\") to include pkg in the DESCRIPTION under Imports:\n\n\n\nThe table below shows the connection between roxygen2 tags, the resulting NAMESPACE entry, and what should be listed in the DESCRIPTION (this is also covered in myPkgApp)\n\n\n\n\n\n\n\n\nRefresher on roxygen2, NAMESPACE & DESCRPTION\n\n\n\n\n\n\n\n\n\n\nroxygen2 tag\n\n\nNAMESPACE directive\n\n\nDESCRIPTION\n\n\n\n\n\n@importFrom\n\n\nimportFrom() : import selected object from another NAMESPACE\n\n\nImports:\n\n\n\n\n@import\n\n\nimport(): import all objects from another package’s NAMESPACE.\n\n\nImports:\n\n\n\n\n@export\n\n\nexport() : export the function, method, generic, or class so it’s available outside of the package (in the NAMESPACE)\n\n\nNothing"
  },
  {
    "objectID": "pages/posts/box/box.html#using-box",
    "href": "pages/posts/box/box.html#using-box",
    "title": "Writing modular code with box\n",
    "section": "Using box\n",
    "text": "Using box"
  },
  {
    "objectID": "pages/posts/my-leprechaun-app/my-leprechaun-app.html",
    "href": "pages/posts/my-leprechaun-app/my-leprechaun-app.html",
    "title": "Shiny frameworks (part 4, leprechaun)",
    "section": "",
    "text": "This is the fourth post in a series on shiny app frameworks. In this post, I’ll build a ‘leaner and smaller’ shiny app using the leprechaun package and framework."
  },
  {
    "objectID": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#framework-comparisons",
    "href": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#framework-comparisons",
    "title": "Shiny frameworks (part 4, leprechaun)",
    "section": "Framework comparisons",
    "text": "Framework comparisons\nThe original post that inspired this series compares ‘vanilla shiny’ (bare-bones shiny application), golem, leprechaun, and rhino across a series of dimensions (framework reliability, target type of developer, overall developing experience, etc.).\nThis series focuses on thee technical areas: Start, Build, and Use.\n\nStart covers the steps required to begin building a shiny app with the framework (from the console and IDE), and any additional packages or dependencies.\nBuild covers the development process, which includes writing and storing code, data, external resources (like CSS or JavaScript), testing, etc.\nUse shows how developers can launch their application using the given framework/package locally (i.e., within the RStudio (Posit) IDE), common workflow tips, and any aspects of the framework I found confusing while building the application.\nIn part 1, I built a ‘minimal’ shiny app (VanillaApp)\nIn part 2, I structured the shiny application as an R package using usethis and devtools, (myPkgApp).\nIn post number three, I used the popular golem framework (myGolemApp)\n\nThe GitHub repo with all shiny app setups is here."
  },
  {
    "objectID": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#start",
    "href": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#start",
    "title": "Shiny frameworks (part 4, leprechaun)",
    "section": "Start",
    "text": "Start\n\n\nusethis::create_package(\"myLeprechaunApp\")\n\n\n\nClick Code to see output\n\n\n\nCode✔ Creating '../projects/myLeprechaunApp/'\n✔ Setting active project to '/Users/mjfrigaard/projects/myLeprechaunApp'\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nPackage: myLeprechaunApp\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R (parsed):\n    * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to\n    pick a license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n✔ Writing 'NAMESPACE'\n✔ Writing 'myLeprechaunApp.Rproj'\n✔ Adding '^myLeprechaunApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n✔ Opening '/Users/mjfrigaard/projects/myLeprechaunApp/' in new RStudio session\n✔ Setting active project to '<no active project>'\n\n\n\nWhen creating a new leprechaun package in the IDE, it’s identical to the R package setup.\n\n\n\n\n\nFigure 1: myLeprechaunApp\n\n\nAfter the new project opens, install and load the leprechaun package, then run leprechaun::scaffold():\n\n\ninstall.packages(\"leprechaun\")\nlibrary(leprechaun)\nleprechaun::scaffold()\n\n\n\nClick Code to see output\n\n\n\nCode── Scaffolding leprechaun app ─────────────────────────────────────────\n\n── Creating lock file ──\n\n✔ Creating .leprechaun\n\n── Adding dependencies ──\n\n✔ Adding 'shiny' to Imports in DESCRIPTION\n✔ Adding 'bslib' to Imports in DESCRIPTION\n✔ Adding 'htmltools' to Imports in DESCRIPTION\n✔ Adding 'pkgload' to Suggests in DESCRIPTION\n\n\n── Generating code ──\n\n✔ Creating R/ui.R\n✔ Creating R/assets.R\n✔ Creating R/run.R\n✔ Creating R/server.R\n✔ Creating R/leprechaun-utils.R\n✔ Creating R/_disable_autoload.R\n✔ Creating R/zzz.R\n✔ Creating R/input-handlers.R\n\n✔ Creating inst/dev\n✔ Creating inst/assets\n✔ Creating inst/img\n✔ Creating inst/run/app.R\n\n── Ignoring files ──\n\n✔ Adding '^\\\\.leprechaun$' to '.Rbuildignore'\n\n\n\nThis results in the following folder tree:\n\n\nmyLeprechaunApp/\n        ├── DESCRIPTION\n        ├── NAMESPACE\n        ├── R/\n        │   ├── _disable_autoload.R\n        │   ├── assets.R\n        │   ├── input-handlers.R\n        │   ├── leprechaun-utils.R\n        │   ├── run.R\n        │   ├── server.R\n        │   ├── ui.R\n        │   └── zzz.R\n        ├── inst/\n        │   ├── assets/\n        │   ├── dev/\n        │   ├── img/\n        │   └── run/\n        │       └── app.R\n        └── myLeprechaunApp.Rproj\n\n7 directories, 12 files\n\n\nThis structure should look familiar if you’ve been following along with this series. The standard R package files and folders (DESCRIPTION, NAMESPACE, R/, and myLeprechaunApp.Rproj) are accompanied by multiple sub-folders in inst/ (recall that inst/ contents are available in the package when the package is installed).\nSetup\nIn this section I’ll cover the initial files in the new leprechaun application.\nR/\n\n\nThe R/ folder contents are below:\n\nSome of these files should look familiar (R/ui.R, R/server.R, and R/run.R)\n\n\n\n        └── R/\n            ├── _disable_autoload.R\n            ├── assets.R\n            ├── input-handlers.R\n            ├── leprechaun-utils.R\n            ├── run.R\n            ├── server.R\n            ├── ui.R\n            └── zzz.R\n\n\n\n\nThe initial application files are created using leprechaun::scaffold(), which takes the following options as function arguments:\n\n\nui controls the application layout (can be \"fluidPage\" or \"navbarPage\", defaults to \"navbarPage\")\n\nbs_version Bootstrap version (“If shiny > 1.6 is installed defaults to version 5, otherwise version 4” )\n\noverwrite: Overwrite all files?\n\n\n\n\nassets.R: contains the serveAssets() function, which will identify the modules using CSS or JavaScript and create dependencies, a list of metadata on the app. If you run the function after initially building your leprechaun app, you’ll see the following:\n\nClick on Code to view code in R/assets.R\n\n\n\nCode#' Dependencies\n#'\n#' @param modules JavaScript files names that require\n#' the `type = module`.\n#' @importFrom htmltools htmlDependency\n#'\n#' @keywords internal\nserveAssets <- function(modules = NULL) {\n  # JavaScript files\n  javascript <- list.files(\n    system.file(package = \"myLeprechaunApp\"),\n    recursive = TRUE,\n    pattern = \".js$\"\n  )\n\n  modules <- get_modules(javascript, modules)\n  javascript <- remove_modules(javascript, modules)\n\n  # CSS files\n  css <- list.files(\n    system.file(package = \"myLeprechaunApp\"),\n    recursive = TRUE,\n    pattern = \".css$\"\n  )\n\n  # so dependency processes correctly\n  names(css) <- rep(\"file\", length(css))\n  names(javascript) <- rep(\"file\", length(javascript))\n\n  # serve dependencies\n  dependencies <- list()\n\n  standard <- htmlDependency(\n    \"myLeprechaunApp\",\n    version = utils::packageVersion(\"myLeprechaunApp\"),\n    package = \"myLeprechaunApp\",\n    src = \".\",\n    script = javascript,\n    stylesheet = css\n  )\n  dependencies <- append(dependencies, list(standard))\n\n  if (!is.null(modules)) {\n    modules <- htmlDependency(\n      \"myLeprechaunApp-modules\",\n      version = utils::packageVersion(\"myLeprechaunApp\"),\n      package = \"myLeprechaunApp\",\n      src = \".\",\n      script = modules,\n      meta = list(type = \"module\")\n    )\n    dependencies <- append(dependencies, list(modules))\n  }\n\n  return(dependencies)\n}\n\n#' Module\n#'\n#' Retrieve and add modules from a vector of files.\n#'\n#' @param files JavaScript files\n#' @param modules JavaScript files names that require\n#' the `type = module`.\n#' @importFrom htmltools htmlDependency\n#'\n#' @keywords internal\n#' @name js-modules\nremove_modules <- function(files, modules) {\n  if (is.null(modules)) {\n    return(files)\n  }\n\n  # make pattern\n  pattern <- collapse_files(modules)\n\n  # remove modules\n  files[!grepl(pattern, files)]\n}\n\n#' @rdname js-modules\n#' @keywords internal\nget_modules <- function(files, modules) {\n  if (is.null(modules)) {\n    return(NULL)\n  }\n\n  # make pattern\n  pattern <- collapse_files(modules)\n\n  # remove modules\n  files[grepl(pattern, files)]\n}\n\n# collapse files into a pattern\ncollapse_files <- function(files) {\n  pattern <- paste0(files, collapse = \"$|\")\n  paste0(pattern, \"$\")\n}\n\n\n\n\n\nserveAssets()\n\n\n\nClick on Code to view the initial output from serveAssets()\n\n\n\nCode[[1]]\nList of 10\n $ name      : chr \"myLeprechaunApp\"\n $ version   : chr \"0.0.0.9000\"\n $ src       :List of 1\n  ..$ file: chr \".\"\n $ meta      : NULL\n $ script    : Named chr(0) \n  ..- attr(*, \"names\")= chr(0) \n $ stylesheet: Named chr(0) \n  ..- attr(*, \"names\")= chr(0) \n $ head      : NULL\n $ attachment: NULL\n $ package   : chr \"myLeprechaunApp\"\n $ all_files : logi TRUE\n - attr(*, \"class\")= chr \"html_dependency\"\n\n\n\n\n_disable_autoload.R is a way to disable the shiny::loadSupport() function. By default, shiny will load any top-level supporting .R files in the R/ directory adjacent to the app.R/server.R/ui.R files.\n\ninput-handlers.R:\n\nClick on Code to view code in R/input-handlers.R\n\n\n\nCode#' Input Dataframe\n#' \n#' Converts the input received from the WebSocket\n#' to a data.frame.\n#' \n#' @param data Input data received from WebSocket.\n#' \n#' @keywords internal\nleprechaun_handler_df <- function(data){\n    do.call(\"rbind\", lapply(data))\n}\n\n#' Input List\n#' \n#' Forces the input received from the WebSocket \n#' to a list. This should really not be needed as\n#' it is handled like so by default.\n#' \n#' @param data Input data received from WebSocket.\n#' \n#' @keywords internal\nleprechaun_handler_list <- function(data){\n    return(data)\n}\n\n.onAttach <- function(...) {\n    shiny::registerInputHandler(\n        \"myLeprechaunApp.list\", \n        leprechaun_handler_list, \n        force = TRUE\n    )\n\n    shiny::registerInputHandler(\n        \"myLeprechaunApp.df\", \n        leprechaun_handler_df, \n        force = TRUE\n    )\n}\n\n\n\n\n\nleprechaun-utils.R initially contains the make_send_message() function (which is used in the R/server.R below).\n\nClick on Code to view code in R/leprechaun-utils.R\n\n\n\nCode#' Create a Helper to Send Messages\n#'\n#' Create a function to send custom messages to the front-end,\n#' this function makes it such that the namespace is carried\n#' along.\n#' The namespace is appended as `ns`.\n#' The namespace with the optional hyphen is\n#' included as `ns2`.\n#'\n#' @param session Shiny session to derive namespace\n#' @param prefix A prefix to add to all types.\n#' Note that the prefix is followed by a hyphen `-`.\n#'\n#' @examples\n#' \\dontrun{\n#' send_message <- make_send_message(session)\n#' send_message(\"do-sth\")\n#' send_message(\"do-sth-else\", x = 1)\n#'\n#' # with prefix\n#' send_message <- make_send_message(session, prefix = \"PREFIX\")\n#'\n#' # this sends a message of type:\n#' # PREFIX-so-th\n#' send_message(\"do-sth\")\n#' }\n#'\n#' @noRd\n#' @keywords internal\nmake_send_message <- function(session, prefix = NULL) {\n  ns <- session$ns(NULL)\n\n  ns2 <- ns\n  if (length(ns) > 0 && ns != \"\") {\n    ns2 <- paste0(ns2, \"-\")\n  }\n\n  function(msgId, ...) {\n    if (!is.null(prefix)) {\n      msgId <- sprintf(\"%s-%s\", prefix, msgId)\n    }\n\n    session$sendCustomMessage(\n      msgId,\n      list(\n        ns = ns,\n        ns2 = ns2,\n        ...\n      )\n    )\n  }\n}\n\n\n\n\n\nrun.R contains functions for running the production (run()) and development version of the application (run_dev()):\n\nClick on Code to view code in R/run.R\n\n\n\nCode#' Run\n#' \n#' Run application\n#' \n#' @param ... Additional parameters to pass to [shiny::shinyApp].\n#' \n#' @importFrom shiny shinyApp\n#' \n#' @export \nrun <- function(...){\n    shinyApp(\n        ui = ui,\n        server = server,\n        ...\n    )\n}\n\n#' Run Development\n#' \n#' Runs the development version which includes\n#' the build step.\n#' \n#' @keywords internal\nrun_dev <- function(){\n    file <- system.file(\"run/app.R\", package = \"myLeprechaunApp\")\n    shiny::shinyAppFile(file)\n}\n\n\n\n\n\nserver.R by default creates send_message with make_send_message(session) (see R/leprechaun-utils.R above).\n\nClick on Code to view code in R/server.R\n\n\n\nCode#' Server\n#' \n#' Core server function.\n#' \n#' @param input,output Input and output list objects\n#' containing said registered inputs and outputs.\n#' @param session Shiny session.\n#' \n#' @noRd \n#' @keywords internal\nserver <- function(input, output, session){\n    send_message <- make_send_message(session)  \n}\n\n\n\n\n\nui.R holds the ui() and assets() functions. assets() loads the resources called in the R/assets.R file (see serveAssets() function above).\n\nClick on Code to view code in ui()\n\n\n\nCode#' Shiny UI\n#' \n#' Core UI of package.\n#' \n#' @param req The request object.\n#' \n#' @import shiny\n#' @importFrom bslib bs_theme\n#' \n#' @keywords internal\nui <- function(req) {\n    fluidPage(\n        theme = bs_theme(version = 5),\n        assets(),\n        h1(\"myLeprechaunApp\")\n    )\n}\n\n\n\n\nClick on Code to view code in assets()\n\n\n\nCode#' Assets\n#' \n#' Includes all assets.\n#' This is a convenience function that wraps\n#' [serveAssets] and allows easily adding additional\n#' remote dependencies (e.g.: CDN) should there be any.\n#' \n#' @importFrom shiny tags\n#' \n#' @keywords internal\nassets <- function() {\n    list(\n        serveAssets(), # base assets (assets.R)\n        tags$head(\n            # Place any additional depdendencies here\n            # e.g.: CDN\n        )   \n    )\n}\n\n\n\n\n\nzzz.R contains shiny’s addResourcePath() function for adding images to the application (in inst/img/)\n\nClick on Code to view code in R/zzz.R\n\n\n\nCode.onLoad <- function(...){\n    shiny::addResourcePath(\n        \"img\",\n        system.file(\"img\", package = \"myLeprechaunApp\")\n    )\n}\n\n\n\n\ninst/run/app.R\n\n\napp.R contains a file that looks like it would be used to run the application, but it’s not. This file contains a call to leprechaun::build(), then pkgload::load_all().\n\nClick on Code to view code in inst/run/app.R\n\n\n\nCode# do not deploy from this file\n# see leprechaun::add_app_file()\nleprechaun::build()\n\npkgload::load_all(\n    path = \"../../\",\n    reset = TRUE,\n    helpers = FALSE\n)\n\nrun()\n\n\n\n\nThis file is not run directly (check leprechaun::add_app_file()):"
  },
  {
    "objectID": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#build",
    "href": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#build",
    "title": "Shiny frameworks (part 4, leprechaun)",
    "section": "Build",
    "text": "Build\nBuilding leprechaun apps is similar to golem/R packages. New code is placed in the R/ folder, and application resources (CSS, SASS, JavaScript files) are added using one of the leprechaun::use_* functions:\n\nuse_sass()\n\nuse_html_utils()\n\nuse_endpoints_utils()\nuse_js_utils()\n\nMore assets can be added using the leprechaun::use_packer() function.\nDevelop\nThe leprechaun::scaffold() defaults to a navbarPage(), but I’ll switch to a fluidPage() for this example.\nAfter devtools::load_all() and devtools::document(), restarting and loading the package, I can run the application with run().\n\n\n\n\n\nFigure 2: Initial run()\n\n\nadd_module()\nCreating modules is simple with leprechaun::add_module().\n\n\nThe initial UI module:\n\n\nleprechaun::add_module(\"var_input\")\n\n\n✔ Creating R/module_var_input.R\n\n\n\nSimilar to golem, this creates functions for the UI and server portions of the module.\n\n\n\n#' var_input UI\n#' \n#' @param id Unique id for module instance.\n#' \n#' @keywords internal\nvar_inputUI <- function(id){\n    ns <- NS(id)\n\n    tagList(\n        h2(\"var_input\"),\n\n    )\n}\n\n\n\nThe initial server module:\n\n\n\n#' var_input Server\n#' \n#' @param id Unique id for module instance.\n#' \n#' @keywords internal\nvar_input_server <- function(id){\n    moduleServer(\n        id,\n        function(\n            input, \n            output, \n            session\n            ){\n\n                ns <- session$ns\n                send_message <- make_send_message(session)\n\n                # your code here\n        }\n    )\n}\n\n# UI\n# var_inputUI('id')\n\n# server\n# var_input_server('id')\n\n\n\nNote the send_message <- make_send_message(session) in var_input_server(). I will show how this is used in the JavaScript section below.\n\n\n\n\n\n\n\n\n\nTip: @keywords internal\n\n\n\n\n\n\nThe module contents are similar to golem, but instead of using the @noRd tag, these functions include @keywords internal (which can be used to document your package).\n\nIn order to this, run usethis::use_package_doc() and a script will be created in R/ with the following contents:\n\n'_PACKAGE'\n\n## usethis namespace: start\n## usethis namespace: end\nNULL\n\n\n\n\n\nThe code for the var_input and plot_display modules are below.\n\n\nThe R/module_var_input.R file:\n\nClick on Code to view code in R/module_var_input.R\n\n\n\nCode#' var_input UI\n#'\n#' @param id Unique id for module instance.\n#'\n#' @keywords internal\n#'\n#' @return shiny UI module\n#' @export var_inputUI\n#'\n#' @description A shiny Module.\n#'\n#' @importFrom shiny NS tagList selectInput\n#' @importFrom shiny sliderInput textInput\nvar_inputUI <- function(id){\n    ns <- shiny::NS(id)\n    shiny::tagList(\n    shiny::selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n    )\n}\n\n#' var_input Server\n#'\n#' @param id Unique id for module instance.\n#'\n#' @keywords internal\n#'\n#' @return shiny server module\n#' @export var_input_server\n#'\n#' @importFrom shiny NS moduleServer reactive\nvar_input_server <- function(id){\n    moduleServer(\n        id,\n        function(\n            input,\n            output,\n            session\n            ){\n\n                ns <- session$ns\n                send_message <- make_send_message(session)\n\n                # your code here\n    return(\n      list(\n        \"x\" = shiny::reactive({\n          input$x\n        }),\n        \"y\" = shiny::reactive({\n          input$y\n        }),\n        \"z\" = shiny::reactive({\n          input$z\n        }),\n        \"alpha\" = shiny::reactive({\n          input$alpha\n        }),\n        \"size\" = shiny::reactive({\n          input$size\n        }),\n        \"plot_title\" = shiny::reactive({\n          input$plot_title\n        })\n        )\n      )\n        }\n    )\n}\n\n# UI\n# var_inputUI('id')\n\n# server\n# var_input_server('id')\n\n\n\n\n\nThe R/module_plot_display.R file:\n\nMy plot_dispay module collects the data from var_input and creates the plot with the custom point_plot() function:\n\n\nClick on Code to view code in R/module_plot_display.R\n\n\n\nCode#' plot_display UI\n#'\n#' @param id Unique id for module instance.\n#'\n#' @return shiny UI module\n#' @export plot_displayUI\n#'\n#' @description A shiny Module.\n#'\n#' @importFrom shiny NS tagList tags\n#' @importFrom shiny plotOutput\nplot_displayUI <- function(id){\n    ns <- shiny::NS(id)\n    shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\n          \"The code for this application comes from the \",\n          shiny::tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    ),\n    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n    )\n}\n\n#' plot_display Server\n#'\n#' @param id Unique id for module instance.\n#'\n#' @keywords internal\nplot_display_server <- function(id, var_input){\n    moduleServer(\n        id,\n        function(\n            input,\n            output,\n            session\n            ){\n\n                ns <- session$ns\n                send_message <- make_send_message(session)\n\n                # your code here\n    movies <- myLeprechaunApp::movies\n\n    inputs <- shiny::reactive({\n      plot_title <- tools::toTitleCase(var_inputs$plot_title())\n      list(\n        x = var_inputs$x(),\n        y = var_inputs$y(),\n        z = var_inputs$z(),\n        alpha = var_inputs$alpha(),\n        size = var_inputs$size(),\n        plot_title = plot_title\n      )\n    })\n\n    output$scatterplot <- shiny::renderPlot({\n      plot <- point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n            x = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$x),\n                    \"_\",\n                  \" \"),\n            y = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$y),\n                  \"_\",\n                \" \")) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n        }\n    )\n}\n\n# UI\n# plot_displayUI('id')\n\n# server\n# plot_display_server('id')\n\n\n\n\n\nAfter creating the modules, adding them to the UI (R/ui.R) and server (R/server.R) is straightforward.\n\n\nThe R/ui.R file:\n\n\nCode#' Shiny UI\n#'\n#' Core UI of package.\n#'\n#' @param req The request object.\n#'\n#' @import shiny\n#' @importFrom bslib bs_theme\n#'\n#' @keywords internal\nui <- function(req) {\n  fluidPage(\n    theme = bs_theme(version = 5),\n    assets(),\n    h1(\"myLeprechaunApp\"),\n    # Begin new code -->\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        var_inputUI(\"vars\")\n      ),\n      shiny::mainPanel(\n        plot_displayUI(\"plot\")\n      )\n    )\n    ## End new code <--\n  )\n}\n\n\n\n\n\nThe R/server.R file:\n\nThe server also has the make_send_message() function in it by default (more on that below).\n\n\nClick on Code to view code in R/server.R\n\n\n\nCode#' Server\n#'\n#' Core server function.\n#'\n#' @param input,output Input and output list objects\n#' containing said registered inputs and outputs.\n#' @param session Shiny session.\n#'\n#' @noRd\n#' @keywords internal\nserver <- function(input, output, session){\n\n    send_message <- make_send_message(session)\n\n  ## New code -->\n   selected_vars <- var_input_server(\"vars\")\n\n   plot_display_server(\"plot\", var_inputs = selected_vars)\n   ## New code <--\n\n}\n\n\n\n\n\nThe other components of myLeprechaunApp were created using the standard usethis package development functions.\nuse_data_raw()\n\nthe movies data was added to inst/extdata and loaded into the package with usethis::use_data_raw()\n\n\n\n\n\n\n\n\nAdding data to a package\n\n\n\n\n\n\nAfter calling usethis::use_data_raw('movies'), I can use system.file() to locate the file with the following code in data-raw/movies.R:\n## code to prepare `movies` dataset goes here\npth <- system.file('extdata/movies.RData', package = 'myLeprechaunApp')\nload(pth)\nusethis::use_data(movies, overwrite = TRUE)\n\n\n\n\nuse_r()\n\n\nusethis::use_r() created R/utils_plot_display.R to hold the point_plot() function\n\nClick on Code to view code in R/utils_plot_display.R\n\n\n\nCode#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return plot object\n#' @export point_plot\n#'\n#' @importFrom ggplot2 ggplot aes geom_point\n#'\n#' @examples\n#' \\donttest{\n#' load(\n#'   list.files(\n#'     system.file(\"extdata\", package = \"myLeprechaunApp\"),\n#'    pattern = \"movies\",\n#'    full.names = TRUE)\n#'    )\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n#' }\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\nNow I can run devtools::load_all(), devtools::document(), restart and load the package, then run()\n\n\n\n\n\nFigure 3: run myLeprechaunApp\n\n\ninst/\nleprechaun uses the inst/ folder similar to the golem framework, but instead of only loading the files in inst/app/www, leprechaun apps include four sub-folders that are ready at application runtime.\npacker\nTo demonstrate how the make_send_message() function works, I’ll walk through the JavaScript example from the package website.\n\n\nRun packer::scaffold_leprechaun()\n\n\npacker::scaffold_leprechaun()\n\n\n\nClick on Code to view the output from packer::scaffold_leprechaun()\n\n\n\n── Scaffolding leprechaun ──────────────────────────────────────────────\n✔ Initialiased npm\n✔ webpack, webpack-cli, webpack-merge installed with scope \"dev\" \n✔ Added npm scripts\n✔ Created srcjs directory\n✔ Created srcjs/config directory\n✔ Created webpack config files\n\n── Adding files to .gitignore and .Rbuildignore ──\n\n✔ Setting active project to '/Users/mjfrigaard/projects/myLeprechaunApp'\n✔ Adding '^srcjs$' to '.Rbuildignore'\n✔ Adding '^node_modules$' to '.Rbuildignore'\n✔ Adding '^package\\\\.json$' to '.Rbuildignore'\n✔ Adding '^package-lock\\\\.json$' to '.Rbuildignore'\n✔ Adding '^webpack\\\\.dev\\\\.js$' to '.Rbuildignore'\n✔ Adding '^webpack\\\\.prod\\\\.js$' to '.Rbuildignore'\n✔ Adding '^webpack\\\\.common\\\\.js$' to '.Rbuildignore'\n✔ Adding 'node_modules' to '.gitignore'\n\n── Scaffold built ──\n\nℹ Run `bundle` to build the JavaScript files\nℹ Run `leprechaun::use_packer()`\n\n\n\n\nRun leprechaun::use_packer()\n\n\nleprechaun::use_packer()\n\n\n\n\n✔ Creating inst/dev/packer.R\n✔ Adding 'packer' to Suggests in DESCRIPTION\n! This requires `leprechaun::build()` or the `leprechaun::build_roclet`\n\n\n\n\nRun leprechaun::build()\n\n\nleprechaun::build()\n\n\n\n\n✔ Running packer.R\n✔ Bundled   \n\n\n\n\nNow I can see what new files have been added to the package/app.\n\n\nIn the inst/dev/ folder:\n\nI can see the packer.R file has been added\n\n\n\ninst/dev/\n      └── packer.R\n\n1 directory, 1 file\n\n\n\nClick on Code to view the output from packer.R\n\n\n\nCode#' Bundle for Prod\n#' \n#' Bundles packer using packer.\npacker_bundle <- function(){\n    has_packer <- requireNamespace(\"packer\", quietly = TRUE)\n\n    if(!has_packer){\n        warning(\n            \"Requires `packer` package: `install.packages('packer')`\\n\", \n            \"Skipping.\",\n            call. = FALSE\n        )\n        return()\n    }\n\n    packer::bundle()\n}\n\npacker_bundle()\n\n\n\n\n\nIn the srcjs/ folder:\n\nI can see how modules/message.js and index.js create the alert with Shiny.addCustomMessageHandler\n\n\n\n\nsrcjs/\n    ├── config\n    │   ├── entry_points.json\n    │   ├── externals.json\n    │   ├── loaders.json\n    │   ├── misc.json\n    │   └── output_path.json\n    ├── index.js\n    └── modules\n        └── message.js\n\n\n\nThe JavaScript in modules/message.js and index.js\n\n\n// srcjs/modules/message.js\nexport const message = (msg) => {\n  alert(msg);\n}\n// srcjs/index.js\nimport { message } from './modules/message.js';\nimport 'shiny';\n\n// In shiny server use:\n// session$sendCustomMessage('show-packer', 'hello packer!')\nShiny.addCustomMessageHandler('show-packer', (msg) => {\n  message(msg.text);\n})\n\n\n\nTo use the JS message scripts in srcjs/, I add the following to R/server.R:\n\n\nIn R/server.R\n\n\n    send_message <- make_send_message(session)\n    send_message(\"show-packer\",\n                  text = \"this is a message from your server()\")\n\n\n\n\nAfter running devtools::load_all() and devtools::document(), the application loads with an alert:\n\n\n\n\n\nFigure 4: send_message()\n\n\nI can also include messages from modules.\n\n\nIn R/module_plot_display.R\n\n\n        send_message <- make_send_message(session)\n        send_message(\"show-packer\",\n          text = \"this is a message from your plot_display module\")\n\n\n\n\n\n\n\n\n\nFigure 5: send_message() (module)\n\n\nRead more about sending JavaScript messages here on the shiny website.\nimg/\nI’ll demonstrate how to use the inst/ folder by adding an image to the application.\n\n\nAssume I want to add leprechaun.jpg to my UI. I start by adding the file to inst/img/:\n\n\ninst/\n  └── img/\n       └── leprechaun.jpg <- new image file!\n\n\n\n\nThen I add the img/ path to the code to UI:\n\n\nui <- function(req) {\n  fluidPage(\n    theme = bs_theme(version = 5),\n    assets(),\n    h1(\"myLeprechaunApp\"),\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        var_inputUI(\"vars\")\n      ),\n      shiny::mainPanel(\n        # new image\n        shiny::tags$img(src = \"img/leprechaun.jpg\"),\n        plot_displayUI(\"plot\")\n      )\n    )\n  )\n}\n\n\n\n\nOnce again, run devtools::load_all() and devtools::document(), restarting and loading the package, then run the application with run()\n\n\n\n\n\nFigure 6: Adding images to inst/img/\n\n\nSass\nleprechaun also has helper functions for adding additional resources (or assets) to an application. I’ll work through the SASS example from the website below.\nTo add a Sass file, I can use leprechaun’s use_sass() function.\n\n\nRun leprechaun::use_sass() (no arguments):\n\n\nleprechaun::use_sass()\n\n\n\nThis will add files to assets/ and dev/ and I see the following messages:\n\n\n\n✔ Creating scss\n✔ Creating inst/dev/sass.R\n✔ Adding 'sass' to Suggests in DESCRIPTION\n✔ Adding '^scss$' to '.Rbuildignore'\n! This requires `leprechaun::build()` or the `leprechaun::build_roclet`\n\n\n\nBelow are the new files in inst/dev/ and sass/:\n\n\n\ninst/\n    ├── scss/\n    │   ├── _core.scss\n    │   └── main.scss\n    └── dev/\n        └── sass.R\n\n\n\n\nThe scss/ folder is created by leprechaun::use_sass(), and it includes _core.scss and main.scss.\n\n\n_core.scss: the original file is below\n\n\nhtml{\n    .error {\n        color: red\n    }\n}\n\n\n\n\nI will change the color: from red to green (#38B44A) using $accent: #38B44A;\n\n\n$accent: #38B44A;\n\nhtml{\n    h1 {\n        color: $accent;\n    }\n}\n\n\n\n\nThen save this file and run leprechaun::build()\n\n\nleprechaun::build()\n\n\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n\n\n\ndev/\n\n\nThe inst/dev/sass.R file contains a sass_build() function\n\n\nsass_build() looks in the scss/ folder for main.scss and creates the inst/assets/style.min.css file.\n\n\nClick on Code to view code in inst/dev/sass.R\n\n\n\nCode#' Build CSS\n#'\n#' Build the sass\nsass_build <- function() {\n  has_sass <- requireNamespace(\"sass\", quietly = TRUE)\n\n  if (!has_sass) {\n    warning(\n      \"Requires `sass` package: `install.packages('sass')`\\n\",\n      \"Skipping.\",\n      call. = FALSE\n    )\n    return()\n  }\n\n  output <- sass::sass(\n    sass::sass_file(\n      \"scss/main.scss\"\n    ),\n    cache = NULL,\n    options = sass::sass_options(\n      output_style = \"compressed\"\n    ),\n    output = \"inst/assets/style.min.css\"\n  )\n  invisible(output)\n}\n\nsass_build()\n\n\n\n\n\nOnce again, I run devtools::load_all(), devtools::document(), install and restart, then load the package and run()\n\n\n\n\n\nFigure 7: run myLeprechaunApp with new Sass\n\n\n\n\n\nassets/\nHow does leprechaun::build() work?\nThe assets/ folder contains the files generated by the .R scripts in the dev/ folder.\n\n\nThe contents of the inst/dev/ folder:\n\n\ninst/dev/\n      ├── packer.R\n      └── sass.R\n\n1 directory, 2 files\n\n\n\n\nThe contents of the inst/assets/ folder:\n\n\ninst/assets/\n        ├── index.js\n        └── style.min.css\n\n1 directory, 2 files\n\n\n\ninst/dev/sass.R creates inst/assets/style.min.css and inst/dev/packer.R creates inst/assets/index.js\n\n\n“Do not call this function from within the app. It helps build things, not run them.” - build.md guide\n\ncheck serveAssets()\n\nAfter running leprechaun::use_sass() and leprechaun::build() (which adds the scss/ folder and the .R script in inst/dev/), I can re-check the serveAssets() function:\n\n\nserveAssets()\n\n\n[[1]]\nList of 10\n $ name      : chr \"myLeprechaunApp\"\n $ version   : chr \"0.0.0.9000\"\n $ src       :List of 1\n  ..$ file: chr \".\"\n $ meta      : NULL\n $ script    : Named chr \"assets/index.js\"\n  ..- attr(*, \"names\")= chr \"file\"\n $ stylesheet: Named chr [1:2] \"assets/style.min.css\" \"html/R.css\"\n  ..- attr(*, \"names\")= chr [1:2] \"file\" \"file\"\n $ head      : NULL\n $ attachment: NULL\n $ package   : chr \"myLeprechaunApp\"\n $ all_files : logi TRUE\n - attr(*, \"class\")= chr \"html_dependency\"\n\n\nThis shows me stylesheet has been updated with \"assets/style.min.css\" and script has been updated with \"assets/index.js\" (these files are loaded into the application when it runs)."
  },
  {
    "objectID": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#use",
    "href": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#use",
    "title": "Shiny frameworks (part 4, leprechaun)",
    "section": "Use",
    "text": "Use\nRunning leprechaun apps:\nWhen I initially create a new leprechaun package with leprechaun::scaffold(), I can run the application after a few quick steps:\n\ndevtools::load_all()\ndevtools::document()\nInstall and restart (optional)\nrun()\n\n\n\ndevtools::load_all()\ndevtools::document()\n# install and restart\nlibrary(myLeprechaunApp)\nrun()\n\n\n\n\n\n\n\nFigure 8: run myLeprechaunApp\n\n\n\n\n\n\n\n\nApp package scripts\n\n\n\n\n\n\nThe output above shows that–unlike golem apps–leprechaun includes the functions in the R/ folder as part of the myLeprechaunApp package.\n\n\n\n\nApp files:\n\n\nR/: After the initial setup, the R/ folder of a leprechaun app contains standard ui.R, server.R files, as well as the run.R function for running the app.\n\n\nmyLeprechaunApp/\n      └── R/\n          ├── _disable_autoload.R\n          ├── assets.R\n          ├── input-handlers.R\n          ├── leprechaun-utils.R\n          ├── run.R\n          ├── server.R\n          ├── ui.R\n          └── zzz.R\n\n      1 directory, 8 files\n\n\n\nThe additional files are specific to the leprechaun framework and workflow.\n\n\n\nConfigure:\nleprechaun app configuration files use the config package (similar to golem). Unlike the golem package, it’s not assumed I’ll be using a config.yml file, but I can easily add one with leprechaun::use_config().\n\nuse_config() adds a inst/config.yml and R/config.R\n\nThe default value in the config.yml files is production: true, which can be read using config_read() in R/config.R.\n\n\nconfig_read()\n\n\n$production\n[1] TRUE\n\n\n\nValues can be added to inst/config.yml using the config file format, then the CONFIG_FILE can be set as an environment variable\n\n\n\n\nWorkflow:\n\n\nThe inst/ folder contains various sub-folders for including external app resources (images, SASS, CSS, JavaScript, etc.).\n\n\nmyLeprechaunApp/\n    └── inst/\n          ├── assets/\n          ├── dev/\n          ├── img/\n          └── run/\n              └── app.R\n\n      5 directories, 1 file\n\n\n\n\nleprechaun apps are packages, so the inst/ folders are available to the application at runtime (which I can find using system.file()).\n\nBelow I’ve passed the output from system.file(\".\", package = \"myLeprechaunApp\") to fs::dir_tree() to view it’s contents:\n\n\n\nCode├── DESCRIPTION\n├── INDEX\n├── Meta/\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R/\n│   ├── myLeprechaunApp\n│   ├── myLeprechaunApp.rdb\n│   └── myLeprechaunApp.rdx\n├── assets/\n│   ├── index.js\n│   └── style.min.css\n├── data/\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── dev/\n│   ├── packer.R\n│   └── sass.R\n├── extdata/\n│   └── movies.RData\n├── help/\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── myLeprechaunApp.rdb\n│   ├── myLeprechaunApp.rdx\n│   └── paths.rds\n├── html/\n│   ├── 00Index.html\n│   └── R.css\n├── img/\n│   └── leprechaun.jpg\n└── run/\n    └── app.R\n\n\n\n\nI can see the inst/ folders and files I’ve created are available to myLeprechaunApp at runtime:\n\n\n\nCode├── DESCRIPTION\n├── NAMESPACE\n├── assets/\n│   ├── index.js\n│   └── style.min.css\n├── dev/\n│   ├── packer.R\n│   └── sass.R\n├── extdata/ \n│   └── movies.RData\n└── img/\n      └── leprechaun.jpg"
  },
  {
    "objectID": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#recap",
    "href": "pages/posts/my-leprechaun-app/my-leprechaun-app.html#recap",
    "title": "Shiny frameworks (part 4, leprechaun)",
    "section": "Recap",
    "text": "Recap\nleprechaun delivers on its promise to be a ‘leaner and smaller’ version of golem. Most of the features in golem are also accessible in leprechaun. Including multiple inst/ sub-folders makes adding assets to the application easier, and leprechaun has a long list of use_* functions for including Sass, CSS, HTML, and JavaScript. The package website has examples for getting started and adding multiple resources, but unfortunately the function Reference had limited documentation.\nleprechaun doesn’t come with any testing functions, although this can be done using testthat and shinytest2 (just as we would with a standard R package).\nFor the next (and last) post in this series, I will build a shiny application using the rhino package."
  },
  {
    "objectID": "pages/posts/my-rhino-app/my-rhino-app.html",
    "href": "pages/posts/my-rhino-app/my-rhino-app.html",
    "title": "Shiny frameworks (part 5, rhino)",
    "section": "",
    "text": "This is the fifth and final post on creating shiny apps with various frameworks. In this post, I’ll build a ‘high quality, enterprise-grade’ shiny app using the rhino package and framework."
  },
  {
    "objectID": "pages/posts/my-rhino-app/my-rhino-app.html#framework-comparisons",
    "href": "pages/posts/my-rhino-app/my-rhino-app.html#framework-comparisons",
    "title": "Shiny frameworks (part 5, rhino)",
    "section": "Framework comparisons",
    "text": "Framework comparisons\nThis series has focused on the following technical areas: Start, Build, and Use.\n\nStart covers the steps required to begin building a shiny app with the framework (from the console and IDE), and any additional packages or dependencies.\nBuild covers the development process, which includes writing and storing code, data, external resources (like CSS or JavaScript), testing, etc.\nUse shows how developers can launch their application using the given framework/package locally (i.e., within the RStudio (Posit) IDE), common workflow tips, and any points I found confusing.\nIn part one, I built a ‘minimal’ shiny app (VanillaApp)\nIn part two, I structured the shiny application as an R package using usethis and devtools, myPkgApp.\nIn part three, I used the popular golem framework, myGolemApp.\nIn part four, I created a shiny app using the leprechaun package and framework, myLeprechaunApp\n\nThe GitHub repo with all shiny app setups is here."
  },
  {
    "objectID": "pages/posts/my-rhino-app/my-rhino-app.html#start",
    "href": "pages/posts/my-rhino-app/my-rhino-app.html#start",
    "title": "Shiny frameworks (part 5, rhino)",
    "section": "Start",
    "text": "Start\nTo create a new rhino application, select Project > New Project > New Directory, and Shiny Application using rhino\nThe New Project Wizard will require a Directory name and subdirectory. I’ve also left Github Actions CI selected (the default)\n\n\n\n\n\nFigure 1: myRhinoApp\n\n\n\nClick Code to see output\n\n\n\nCode* Initializing project ...\n* Discovering package dependencies ... Done!\n* Copying packages into the cache ... Done!\nThe following package(s) will be updated in the lockfile:\n\n# CRAN ===============================\n- R.cache        [* -> 0.16.0]\n- R.methodsS3    [* -> 1.8.2]\n\n  < < < < < < < OMITTED > > > > > > > >\n\n- xtable         [* -> 1.8-4]\n- yaml           [* -> 2.3.7]\n\n# GitHub =============================\n- box            [* -> klmr/box@dev]\n\nThe version of R recorded in the lockfile will be updated:\n- R              [*] -> [4.2.2]\n\n* Lockfile written to '~/projects/myRhinoApp/renv.lock'.\n✔ Initialized renv.\n✔ Application structure created.\n✔ Unit tests structure created.\n✔ E2E tests structure created.\n✔ Github Actions CI added.\n\n\n\nThis initializes the new rhino app by opening the .Rproj file in RStudio.\nIf I wanted to create the myRhinoApp application from the console, I would use the following:\n\n\ninstall.packages(\"rhino\")\nrhino::init(\"/Users/mjfrigaard/projects/myRhinoApp\")\n\n\n\nClick Code to see output\n\n\n\nCode✔ Rproj file created.\n* Initializing project ...\n* Discovering package dependencies ... Done!\n* Copying packages into the cache ... Done!\nThe following package(s) will be updated in the lockfile:\n\n# CRAN ===============================\n- R.cache        [* -> 0.16.0]\n- R.methodsS3    [* -> 1.8.2]\n\n  < < < < < < < OMITTED > > > > > > > >\n\n- xtable         [* -> 1.8-4]\n- yaml           [* -> 2.3.7]\n\n# GitHub =============================\n- box            [* -> klmr/box@dev]\n\nThe version of R recorded in the lockfile will be updated:\n- R              [*] -> [4.2.2]\n\n* Lockfile written to '~/projects/myRhinoApp/renv.lock'.\n✔ Initialized renv.\n✔ Application structure created.\n✔ Unit tests structure created.\n✔ E2E tests structure created.\n✔ Github Actions CI added.\n\n\n\n\n\n\n\n\n\nWhat’s the difference?\n\n\n\n\n\n\nBoth methods create the same structure, using rhino::init() will not automatically open the new rhino application project file (~/projects/myRhinoApp/myRhinoApp.Rproj), so I have to navigate to this file and open it.\n\n\n\n\nThe initial folder structure for a new rhino app is below:\n\n\nmyRhinoApp/\n      ├── app/\n      │   ├── js\n      │   │   └── index.js\n      │   ├── logic\n      │   │   └── __init__.R\n      │   ├── main.R\n      │   ├── static\n      │   │   └── favicon.ico\n      │   ├── styles\n      │   │   └── main.scss\n      │   └── view\n      │       └── __init__.R\n      ├── app.R\n      ├── config.yml\n      ├── dependencies.R\n      ├── myRhinoApp.Rproj\n      ├── renv/\n      │   ├── activate.R\n      │   ├── library\n      │   │   └── R-4.2\n      │   ├── sandbox\n      │   │   └── R-4.2\n      │   └── settings.dcf\n      ├── renv.lock\n      ├── rhino.yml\n      └── tests/\n          ├── cypress\n          │   └── integration\n          ├── cypress.json\n          └── testthat\n              └── test-main.R\n\n16 directories, 16 files\n\n\nThe rhino package website has excellent documentation on their app structure philosophy, and it’s worth reading through this before getting started. I’ll do my best to summarize the application’s files below:\napp/\nThe app/ folder contains the primary folder and files for my application.\n\n\napp/ includes the following files and sub-folders:\n\n\napp/\n  ├── js/\n  │   └── index.js\n  ├── logic/\n  │   └── __init__.R\n  ├── main.R\n  ├── static/\n  │   └── favicon.ico\n  ├── styles/\n  │   └── main.scss\n  └── view/\n      └── __init__.R\n\n6 directories, 6 files\n\n\n\njs/: the js folder initially contains a blank index.js script\n\nlogic/: the logic folder contains code independent from Shiny\n\n\nlogic/__init__.R is originally blank, but provides a link to the website section on project structure\n\n\n\n# Logic: application code independent from Shiny.\n# https://go.appsilon.com/rhino-project-structure\n\n\n\n\nstatic/: the static/ folder will contain external resources (like JavaScript files) and is similar to the sub-folders in inst/ from golem and leprechaun.\n\nUse these file in the UI with:\n\n\n\ntags$script(src = \"static/js/app.min.js\")\n\n\n\nstyles/: the styles/ folder will hold custom styles (CSS and HTML) in the styles/main.css file (which is initially blank)\n\nview/: the view/ folder holds the code which describes the user interface of your application and relies upon the reactive capabilities of Shiny.\n\n\nview/__init__.R is also intially blank, but provides a link to the website section on project structure\n\n\n\n# View: Shiny modules and related code.\n# https://go.appsilon.com/rhino-project-structure\n\n\n\n\nmain.R: the main.R file contains the actual application code (this is where I’ll make edits).\n\n\napp/main.R contains the code for the application I see when I run rhino::app()\n\n\n\nClick Code to see app/main.R\n\n\n\nCodebox::use(\n  shiny[bootstrapPage, moduleServer, NS, renderText, tags, textOutput],\n)\n\n#' @export\nui <- function(id) {\n  ns <- NS(id)\n  bootstrapPage(\n    tags$h3(\n      textOutput(ns(\"message\"))\n    )\n  )\n}\n\n#' @export\nserver <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    output$message <- renderText(\"Hello!\")\n  })\n}\n\n\n\n\n\n\n\n\n\n\n\n\nbox::use()?\n\n\n\n\n\n\nIf box’s syntax looks strange–don’t worry! It looked strange to me too at first. But it’s actually something special with those roxygen2 tags. I’ll cover it more in the Build section below.\n\n\n\n\napp.R\n\n\napp.R is the file that will run my application and contains the rhino::app() function.\n\nDo not edit this file!\n\n\n\n# Rhino / shinyApp entrypoint. Do not edit.\nrhino::app()\n\n\n\n\nrhino has a ‘minimal app.R’ philosophy, and the call to rhino::app() performs multiple operations beyond shiny::runApp()\n\n\n\nconfig.yml\n\n\nconfig.yml is a YAML file that follows the config package format. This file initially contains two calls to Sys.getenv():\n\ndefault:\n  rhino_log_level: !expr Sys.getenv(\"RHINO_LOG_LEVEL\", \"INFO\")\n  rhino_log_file: !expr Sys.getenv(\"RHINO_LOG_FILE\", NA)\n\n\nRead more about how to use config.yml in the Environments section of the How to: Manage secrets and environments vignette.\n\n\ndependencies.R\n\n\ndependencies.R is an .R script that contains any other packages used by the application. Using this file is covered in the Manage Dependencies vignette on the package website, and I’ve covered renv in the first application (VanillaShiny).\n\nAs I can see from the note in the comments, the dependencies will be tracked using packrat in rsconnect.\n\n\n\n# This file allows packrat (used by rsconnect during deployment)\n# to pick up dependencies.\nlibrary(rhino)\n\n\n\nI know I’ll be using ggplot2 and stringr in this application, so I’ll load those there.\n\n\n\n# This file allows packrat (used by rsconnect during deployment)\n# to pick up dependencies.\nlibrary(rhino)\nlibrary(ggplot2)\nlibrary(stringr)\n\n\n\nNow I install and take a snapshot with renv:\n\n\n\nrenv::install(c(\"ggplot2\", \"stringr\"))\nrenv::snapshot()\n\n\n\nrenv/\n\n\nThe renv/ folder contains the R version and packages used to build the application:\n\n\nrenv.lock is the lock file and contains the packages and R version used in the application.\n\n\n\nmyRhinoApp/\n  ├── renv/\n  │    ├── activate.R\n  │    ├── library/\n  │    │   └── R-4.2\n  │    │       └── x86_64-apple-darwin17.0\n  │    ├── sandbox/\n  │    │   └── R-4.2\n  │    │       └── x86_64-apple-darwin17.0\n  │    └── settings.dcf\n  └── renv.lock\n\n\n\nRead more about getting started with renv and using renv in package development\n\n\n\nrhino.yml\n\n\nrhino.yml is the configuration file and contains options for setting how Sass is built or for importing from another application structure to rhino.\n\nthe code below showcases the optional arguments (and is not included in the application)\n\n\nsass: string               # required | one of: \"node\", \"r\"\nlegacy_entrypoint: string  # optional | one of: \"app_dir\", \"source\", \"box_top_level\"\n\n\nRead more about rhino.yml in the Explanation: Configuring Rhino - rhino.yml vignette.\n\n\ntests/\n\n\ntests/ contains two sub-folders, cypress/ and testthat/:\n\n\ntests/\n    ├── cypress/\n    │   └── integration/\n    │       └── app.spec.js\n    ├── cypress.json\n    └── testthat/\n        └── test-main.R\n\n\n\n\ncypress/\n\n\ntests/cypress/ holds folders for using the Cypress web and component testing framework.\n\nThis is also covered in the ‘Use shinttest2 vignette’.\n\n\ntests/\n    ├── cypress/\n    │    └── integration/\n    │        └── app.spec.js\n    └── cypress.json\n\n\ntestthat/\n\n\ntests/testthat/ contains the architecture for writing tests with testthat\n\n\nrhino also has a helper function for running all tests in the testthat/ folder (rhino::test_r())\n\n\ntests/\n    └── testthat/\n            └── test-main.R"
  },
  {
    "objectID": "pages/posts/my-rhino-app/my-rhino-app.html#build",
    "href": "pages/posts/my-rhino-app/my-rhino-app.html#build",
    "title": "Shiny frameworks (part 5, rhino)",
    "section": "Build",
    "text": "Build\nUnlike the previous applications in this series, rhino applications don’t use the NAMESPACE and DESCRIPTION to manage dependencies. Instead, they use the box modules to explicitly import packages and functions\nbox\n\n\n\n\n\n\n\n\n\n\nrhino apps use box to create modules, which is handy, because it’s specifically designed for writing “reusable, composable and modular R code”\nQuick refresher: if I’m building a shiny app,\n\nI install dependencies using install.packages('<package>') (or renv::install('<package>'))\nWhen I want to use an installed package, I run library(<package>), which loads the package namespace ‘and attach[es] it on the search list’ (or I can use <package>::<function>)\nIf the application gets converted into an R package, I track these dependencies using roxygen2 tags @importFrom or @import (which are converted into NAMESPACE directives)\nI also include them in the DESCRIPTION under Imports:\n\nSo, I run library(<package>) to load the entire package namespace when I want to use a function, but it’s recommended I use @importFrom to specify the package functions if I’m developing my own R package.\nPut another way,\n“If I only need one or two items from a package, why am I loading everything in the namespace with library()?“\nThis is where box comes in–it’s designed to ‘completely replace the base R library and require functions’.\nbox handles dependencies by ‘writing modular code’ and is perhaps best summarized in the following quote from The Zen of Python (also on the package website)\n\n‘explicit is better than implicit.’\n\nA box module is essentially just an R script in a folder. However, in box::use(), instead of loading packages and functions using library() or ::, I can encapsulate and explicitly import packages and functions in these R scripts using the syntax package[function].\n\n\nThe module below imports the foo() and bar() functions from the pkg package in the mod.R file (in the box/ folder)\n\n# contents of box/mod.R\n#' @export\nbox::use(\n  pkg[foo, bar]\n)\n\n\n\nI can now access foo() and bar() from mod.R using box::use(box/mod):\n\n# using contents of box/mod.R\nbox::use(\n  box/mod\n)\n\n\n\n\nbox modules\nHere is a quick example:\n\n\nBelow I attempt to use tidyverses tidyverse_logo() function\n\n\ntidyverse_logo()\n\nError in tidyverse_logo(): could not find function \"tidyverse_logo\"\n\n\n\n\nThe error is expected, because dplyr has been installed, but hasn’t been loaded.\n\n\n\nIn a box module, I import the tidyverse_logo() from tidyverse (without using library() or ::), by creating a logo.R file in a tidy folder. In logo.R, I include box::use() and the following code:\n\nI also include #' @export on the preceding line:\n\n\n\n# contents of tidy/logo.R\n#' @export\nbox::use(\n  tidyverse[tidyverse_logo]\n)\n\n\n\nNote I did not have to use tidyverse::tidyverse_logo()\n\n\n\n\nTo use this module, I call box::use(tidy/logo), which loads logo into the environment.\n\n\nbox::use(tidy/logo)\nls(logo)\n\n <module: tidy/logo>\n\n\nI can use ls() on logo to return the imported names.\n\n\n\nls(logo)\n\n[1] \"tidyverse_logo\"\n\n\n\nTo use the tidyverse_logo() function, I use $:\n\n\nlogo$tidyverse_logo()\n\n⬢ __  _    __   .    ⬡           ⬢  . \n / /_(_)__/ /_ ___  _____ _______ ___ \n/ __/ / _  / // / |/ / -_) __(_-</ -_)\n\\__/_/\\_,_/\\_, /|___/\\__/_/ /___/\\__/ \n     ⬢  . /___/      ⬡      .       ⬢ \n\n\n\nNote that tidyverse_logo() is still not loaded outside the logo module\n\n\ntidyverse_logo()\n\nError in tidyverse_logo(): could not find function \"tidyverse_logo\"\n\n\n\n\n\nI can also include (or wrap) box::use() inside custom functions, and then call these when I’ve imported the module:\n\n\ntidy/plogo.R imports tidyverse_logo() inside a custom function, print_logo()\n\nNote that to use a packages/functions from a module, you must include #' @export from roxygen2 (in the line above):\n\n\n\n# contents of tidy/plogo.R\n\n#' prints tidyverse logo\n#' @export\nprint_logo <- function() {\n  # import pkg[fun] inside function\n  box::use(\n    tidyverse[tidyverse_logo]\n  )\n  # use fun\n  tidyverse_logo()\n}\n\n\n\nI load the module into the environment with box::use(path/to/module)\n\n\n\n\n# use tidy/plogo\nbox::use(tidy/plogo)\nplogo\n\n<module: tidy/plogo>\n\n\nI can use the print_logo() function the same way I used tidyverse_logo() in the logo module.\n\n\n\n# access print_logo() with $\nplogo$print_logo()\n\n⬢ __  _    __   .    ⬡           ⬢  . \n / /_(_)__/ /_ ___  _____ _______ ___ \n/ __/ / _  / // / |/ / -_) __(_-</ -_)\n\\__/_/\\_,_/\\_, /|___/\\__/_/ /___/\\__/ \n     ⬢  . /___/      ⬡      .       ⬢ \n\n\n\nAlso note print_logo() doesn’t exist outside the plogo module:\n\n\nprint_logo()\n\nError in print_logo(): could not find function \"print_logo\"\n\n\n\n\nThis is what is meant by encapsulation\n\n\n\n\nbox modules can also import functions and packages using aliases.\n\n\nThe example below (tidy/tidy_logo.R) exports tidyverse_logo() as tidy_logo() and print_logo()\n\nBoth the contents of box::use() and print_logo() need the #' @export tag\n\n\n\n# contents of tidy/tidy_logo.R\n\n#' import alias tidyverse logo\n#' @export\nbox::use(\n  tidyverse[tidy_logo = tidyverse_logo]\n)\n\n#' prints tidyverse logo\n#' @export\nprint_logo <- function() {\n  # use fun alias\n  tidy_logo()\n}\n\n\n\nAfter I load the module with box::use(), I can see both functions in tidy_logo using ls()\n\n\n\n\nbox::use(tidy/tidy_logo)\nls(tidy_logo)\n\n[1] \"print_logo\" \"tidy_logo\"\n\n\nIf I compare both functions, I find they are identical:\n\n\n\nidentical(\n  x = tidy_logo$print_logo(),\n  y = tidy_logo$tidy_logo()\n)\n\n[1] TRUE\n\n\n\nThere are multiple methods for importing packages and functions with box. The table below list a few of these options:\n\n\n\n\n\n\n\nbox::use() options\n\n\n\n\n\n\n\n\n\n\nInside box::use()\n\n\nAction\n\n\n\n\n\nbox::use( pkg )\n\n\nimports ‘pkg’, does not attach any function names\n\n\n\n\nbox::use( p = pkg )\n\n\nimports ‘pkg’ with alias (‘p’), does not attach any function names\n\n\n\n\nbox::use( pkg = pkg[foo, bar] )\n\n\nimports ‘pkg’ and attaches the function names ‘pkg::foo()’ and ‘pkg::bar()’\n\n\n\n\nbox::use( pkg[my_foo = foo, …] )\n\n\nimports ‘pkg’ with alias for ‘foo’ (‘my_foo’) and attaches all exported function names\n\n\n\n\n\n\n\n\n\n\nThese options are also listed on the package website\n\nThis has been a very brief overview of box, so I highly recommend consulting the box website and vignettes (especially “the hierarchy of module environments”). The rhino website also has a great overview on using box with shiny apps (I also have a collection of box module examples in this repo.)\nModules\nNow that I’ve covered a bit on how box modules work, I am going to create the application modules. New modules should be created in the app/view/ folder.\nThe first module we’ll create is the app/view/inputs.R module for collecting the user inputs\n\n\nThe code below is placed in app/view/inputs.R\n\nClick Code to see app/view/inputs.R\n\n\n\nCode# app/view/inputs.R\n\n# define module functions\nbox::use(\n  shiny[\n    NS, tagList, selectInput, h3,\n    sliderInput, textInput, moduleServer, reactive\n  ],\n)\n\n#' input values UI\n#' @export\nui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n#' input values server\n#' @export\nserver <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    return(\n      list(\n        \"x\" = reactive({\n          input$x\n        }),\n        \"y\" = reactive({\n          input$y\n        }),\n        \"z\" = reactive({\n          input$z\n        }),\n        \"alpha\" = reactive({\n          input$alpha\n        }),\n        \"size\" = reactive({\n          input$size\n        }),\n        \"plot_title\" = reactive({\n          input$plot_title\n        })\n      )\n    )\n  })\n}\n\n\n\n\n\nInit files\nBack in the app/view/ folder, I want to use the app/view/inputs.R function in the app/main.R. I can do this by adding a __init__.R file in the app/view/ folder with the following contents:\n\n\nThe __init__.R files are covered on the rhino website:\n\n\nCode# View: Shiny modules and related code.\n# https://go.appsilon.com/rhino-project-structure\n#' @export\nbox::use(\n  app/view/inputs)\n\n\n\n\n\nAfter composing the module in app/view/input.R, I add the input module to the app/main.R file just like the examples above:\n\nNote that I’ve added the necessary functions for using a fluidPage() layout (instead of the default bootstrapPage())\n\n\nClick Code to see app/main.R\n\n\n\nCode# app/main.R\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel, mainPanel,\n    tags, textOutput, moduleServer, renderText\n  ],\n)\n# load inputs module ----\nbox::use(\n  app/view/inputs,\n)\n\n#' @export\nui <- function(id) {\n  ns <- NS(id)\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        # use inputs module UI ----\n        inputs$ui(ns(\"vals\"))\n      ),\n      mainPanel(\n        tags$h3(\"myRhinoApp\"),\n        tags$h3(textOutput(ns(\"message\")))\n      )\n    )\n  )\n}\n\n#' @export\nserver <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    # use inputs module server ----\n    inputs$server(\"vals\")\n    output$message <- renderText(\"Hello!\")\n  })\n}\n\n\n\n\n\nAfter saving both app/view/inputs.R and app/main.R, I can click Run App in app.R and check the output:\n\n\n\n\n\nFigure 2: inputs.R module\n\n\nThe display.R module will show the graph output, but I know this module will require adding the movies data and the point_plot() function (both of which I’ll cover below).\nLogic\nrhino apps come with an app/logic/ folder, which is used to store code for “data manipulation, generating non-interactive plots and graphs, or connecting to an external data source, but outside of definable inputs, it doesn’t interact with or rely on shiny in any way.”\n\n\nThe point_plot() function definitely meets the definition above, so I will write two modules in app/logic: data for importing the movies data, and plot for creating a scatter plot with point_plot()\n\n\napp/logic/data.R: imports movies from my GitHub repo with all the shiny frameworks. Using data in box() modules is tricky (and its a known, issue), but this method works for my application.\n\n\nClick Code to see app/logic/data.R\n\n\n\nCode# contents of app/logic/data.R\n#' @export\nbox::use(\n  readr[get_csv = read_csv, cols]\n)\n\n#' @export\nmovies_data <- function() {\n  raw_csv_url <- \"https://bit.ly/3Jds4g1\"\n  # use alias for read_csv()\n  get_csv(raw_csv_url, col_types = cols())\n}\n\n\n\n\nThe second module, app/logic/plot.R, holds the point_plot() function:\n\n\n\nCode# contents of app/logic/plot.R\n#' point plot function\n#' @export\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n\nbox::use(\n  ggplot2 = ggplot2[...]\n)\n\n  ggplot(\n    data = df,\n    aes(\n      x = .data[[x_var]],\n      y = .data[[y_var]],\n      color = .data[[col_var]]\n    )\n  ) +\n    geom_point(alpha = alpha_var, size = size_var)\n}\n\n\n\n\nThe __init__.R file in app/logic contains the following:\n\n\n\nCode# Logic: application code independent from Shiny.\n# https://go.appsilon.com/rhino-project-structure\n#' @export\nbox::use(\n  app/logic/data,\n  app/logic/plot)\n\n\n\n\nTo make sure everything is working, I’ll also include a app/logic/check-point_plot.R file that contains the following:\n\n\n\nCode# contents of app/logic/check-point_plot.R\n# contents for app/logic/check-point_plot.R\n\n# load modules from logic folder\nbox::use(\n  app/logic/data,\n  app/logic/plot\n)\n\n# import movies data\nmovies <- data$movies_data()\n\n# check point plot\nplot$point_plot(\n  df = movies,\n  x_var = 'critics_score', # as string\n  y_var = 'imdb_rating', # as string\n  col_var = 'mpaa_rating', # as string\n  alpha_var = 2 / 3,\n  size_var = 2\n)\n\n\n\n\n\ncheck-point_plot.R imports the two logic modules (data and plot), creates the movies data, and checks to see if the data and plotting function work:\n\n\nAfter saving app/logic/data.R and app/logic/plot.R, I can run the code in check-point_plot.R\n\n\n\n\n\n\nFigure 3: app/logic/check-point_plot.R module\n\n\nThe app/view/display.R module can now call box::use() to import the app/logic/data and app/logic/plot.\n\n\nThe app/view/display.R module contains theui and the server functions:\n\n\nCode# app/view/display.R\n# import data and plot modules ----\nbox::use(\n  app/logic/data,\n  app/logic/plot\n)\n\n#' display values ui ----\n#' @export\nui <- function(id) {\nbox::use(\n  shiny[NS, tagList, tags, plotOutput]\n)\n  ns <- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\n          \"The code for this application comes from the \",\n          tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    ),\n    plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n#' display values server ----\n#' @export\nserver <- function(id, var_inputs) {\n\n# load plotting, shiny, tools, and stringr functions\nbox::use(\n  ggplot2 = ggplot2[...],\n  shiny[NS, moduleServer, plotOutput, reactive, renderPlot],\n  tools[toTitleCase],\n  stringr[str_replace_all]\n)\n\n  moduleServer(id, function(input, output, session) {\n\n    # use data$movies_data() ----\n    movies <- data$movies_data()\n\n      inputs <- reactive({\n        plot_title <- toTitleCase(var_inputs$plot_title())\n        list(\n          x = var_inputs$x(),\n          y = var_inputs$y(),\n          z = var_inputs$z(),\n          alpha = var_inputs$alpha(),\n          size = var_inputs$size(),\n          plot_title = plot_title\n        )\n      })\n\n    output$scatterplot <- renderPlot({\n      # use plot$point_plot() ----\n      plot <- plot$point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        labs(\n          title = inputs()$plot_title,\n          x = str_replace_all(\n            toTitleCase(\n              inputs()$x\n            ),\n            \"_\",\n            \" \"\n          ),\n          y = str_replace_all(\n            toTitleCase(\n              inputs()$y\n            ),\n            \"_\",\n            \" \"\n          )\n        ) +\n        theme_minimal() +\n        theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n\n\nIn app/main.R, I can place the display module in call to box::use(), then:\n\nAdd display$ui() to the mainPanel()\n\nIn the server, the output from inputs$server() is assigned to selected_vars, which becomes the var_inputs input for display$server():\n\n\nCode# app/view/main.R\n\n# shiny functions\nbox::use(\n  shiny[NS, fluidPage, sidebarLayout, sidebarPanel,\n        mainPanel, tags, textOutput, moduleServer,\n        renderText]\n)\n\n# import modules\nbox::use(\n  # load inputs module ----\n  app/view/inputs,\n  # load display module ----\n  app/view/display\n)\n\n#' myRhinoApp ui\n#' @export\nui <- function(id) {\n  ns <- NS(id)\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        # use inputs module UI ----\n        inputs$ui(ns(\"vals\"))\n      ),\n      mainPanel(\n        tags$h3(\"myRhinoApp\"),\n        tags$h3(textOutput(ns(\"message\"))),\n        # use display module UI ----\n        display$ui(ns(\"disp\"))\n      )\n    )\n  )\n}\n\n#' myRhinoApp server\n#' @export\nserver <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    # use inputs module server ----\n    selected_vars <- inputs$server(id = \"vals\")\n    # use display module server ----\n    display$server(id = \"disp\",\n                   var_inputs = selected_vars)\n  })\n}\n\n\n\n\n\nAfter saving app/view/data.R and app/view/display.R files, the app/view/ and app/logic/ folders contain the following modules:\n\n\napp/logic/:\n\n\napp/logic/\n      ├── __init__.R\n      ├── check-point_plot.R\n      ├── data.R\n      └── plot.R\n\n1 directory, 4 files\n\n\n\n\napp/view/:\n\n\napp/view/\n      ├── __init__.R\n      ├── display.R\n      └── inputs.R\n\n1 directory, 3 files\n\n\n\n\nWhen I click Run App in app.R I should see the following output:\n\n\n\n\n\nFigure 4: myRhinoApp\n\n\nExternal scripts\nIt’s fairly straightforward to add external resources (i.e., JavaScript, CSS, Sass, etc.) to rhino apps. I’ll use the example from the website to demonstrate because it adds both CSS and JavaScript to the codebase.\n\n\nThe first place to add code is the UI in app/main.R:\n\nUpdate the call to box::use() and include the layout functions (fluidRow, column, icon)\n\n\n\n# app/view/main.R\n\n# shiny functions\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel,\n    mainPanel, fluidRow, column, tags, icon,\n    textOutput, moduleServer, renderText\n  ]\n)\n\n\n\nUpdate the mainPanel() to include the title, info button, and display module:\n\n\n\nCode  mainPanel(\n    fluidRow(\n      column(\n        width = 12,\n        tags$h3(\"myRhinoApp\")\n      )\n    ),\n    fluidRow(\n      column(\n        width = 1,\n        offset = 11,\n        # example info button ---\n        tags$button(\n          id = \"help-button\",\n          icon(\"info\")\n        )\n      )\n    ),\n    fluidRow(\n      column(\n        width = 12,\n        # use display module UI ----\n        display$ui(ns(\"disp\"))\n      )\n    )\n  )\n\n\n\n\nThe CSS added to app/styles/main.css is the container for the button.\n\n\n// app/styles/main.scss\n\n.components-container {\n  display: inline-grid;\n  grid-template-columns: 1fr 1fr;\n  width: 100%;\n\n  .component-box {\n    padding: 10px;\n    margin: 10px;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n  }\n}\n\nh1 {\n  text-align: center;\n  font-weight: 900;\n}\n\n#help-button {\n  position: fixed;\n  top: 0;\n  right: 0;\n  margin: 10px;\n}\n\n\nRun rhino::build_sass() to create the app/static/css/app.min.css file (requires node.js)\n\n\n\nrhino::build_sass()\n\nadded 748 packages in 49s\nbuild-sass\nsass --no-source-map --style=compressed \n  ../app/styles/main.scss:../app/static/css/app.min.css\n\n\nThis tells me app.min.css has been added to in app/static/css/\n\n\n\napp/static/\n      └── css\n           └── app.min.css\n\n\nAdd the following to app/js/index.js:\n\n\nexport function showHelp() {\nalert('Learn more about shiny frameworks: https://mjfrigaard.github.io/posts/my-rhino-app/');\n}\n\n\nRun rhino::build_js() to build the app/static/js/app.min.js (requires node.js)\n\n\n\nrhino::build_js()\n\nbuild-js\nwebpack\n\nasset app.min.js 502 bytes [emitted] [minimized] (name: main)\nruntime modules 670 bytes 3 modules\n../app/js/index.js 126 bytes [built] [code generated]\nwebpack 5.69.0 compiled successfully in 1300 ms\n\n\nThe output tells me the app.min.js has been created in app/static/js\n\n\n\napp/static/\n      └── js\n          └── app.min.js\n\n\nBack in app/main.R, I add the onclick to the mainPanel()\n\n\n\n\nCode  mainPanel(\n    fluidRow(\n      column(\n        width = 12,\n        tags$h3(\"myRhinoApp\")\n      )\n    ),\n    fluidRow(\n      column(\n        width = 1,\n        offset = 11,\n        # example info button ---\n        tags$button(\n          id = \"help-button\",\n          icon(\"info\"),\n          # add 'onclick' after rhino::build_sass()\n          # and rhino::build_js()\n          onclick = \"App.showHelp()\"\n        )\n      )\n    ),\n    fluidRow(\n      column(\n        width = 12,\n        # use display module UI ----\n        display$ui(ns(\"disp\"))\n      )\n    )\n  )\n\n\n\n\nNow when I save everything and click ‘Run App’ in app.R I should see the info button (and message):\n\n\n\n\n\n\nFigure 5: Adding .js to app/js/index.js\n\n\n\n\n\n\n\nFigure 6: Adding .js to app/js/index.js ‘on click’"
  },
  {
    "objectID": "pages/posts/my-rhino-app/my-rhino-app.html#use",
    "href": "pages/posts/my-rhino-app/my-rhino-app.html#use",
    "title": "Shiny frameworks (part 5, rhino)",
    "section": "Use",
    "text": "Use\n\nTo run a rhino application, use rhino::app() in the app.R file:\n\n\n\n\n\n\nFigure 7: rhino::app()\n\n\n\nMost of the development takes place in app/logic and app/view (using box modules). The separation of the ‘business logic’ workflow from the ‘app view’ code is similar to the dev folder in golem and leprechaun, but the modules make it easy to move code and functions back and forth between the two folders.\n\nThe app/js/index.js and app/styles/main.css are used to include any custom CSS or JavaScript code, but you won’t create any new files (other than index.js and main.css).\n\nNew JavaScript or CSS code is placed in app/js/index.js or app/styles/main.css and then the corresponding rhino function is run (rhino::build_js() or rhino::build_sass()). This requires installing node.js.\nThese functions create output files in app/static/js/app.min.js and app/static/css/app.min.css that are used in the application.\n\n\ntests/ functions like any testthat folder (and can be used with shinytest2) and comes with a helper function, rhino::test_r()"
  },
  {
    "objectID": "pages/posts/my-golem-app/my-golem-app.html",
    "href": "pages/posts/my-golem-app/my-golem-app.html",
    "title": "Shiny frameworks (part 3, golem)",
    "section": "",
    "text": "This is the third post in a series on building shiny apps with various frameworks. In this example, I’ll be using golem to build a ‘production-grade’ shiny app myGolemApp.\nI’ve previously built 1) a ‘minimal’ shiny app (VanillaApp), and 2) a shiny app built as an R package (myPkgApp). The GitHub repo with all shiny app setups is here."
  },
  {
    "objectID": "pages/posts/my-golem-app/my-golem-app.html#framework-comparisons",
    "href": "pages/posts/my-golem-app/my-golem-app.html#framework-comparisons",
    "title": "Shiny frameworks (part 3, golem)",
    "section": "Framework comparisons",
    "text": "Framework comparisons\nThe original post that inspired this series compares ‘vanilla shiny’ (bare-bones shiny application), golem, leprechaun, and rhino across a series of dimensions (framework reliability, target type of developer, overall developing experience, etc.).\nI’ll continue focusing on three technical areas: Start, Build, and Use.\n\nStart covers the steps required to begin building the shiny app within the framework (from the console and IDE), and any additional packages or dependencies.\nBuild covers the development process, which includes writing and storing code, data, external resources (like CSS or JavaScript), testing, etc.\nUse shows how developers can launch their application using the given framework/package locally (i.e., within the RStudio (Posit) IDE), common workflow tips, and anything I found confusing while building the application."
  },
  {
    "objectID": "pages/posts/my-golem-app/my-golem-app.html#start",
    "href": "pages/posts/my-golem-app/my-golem-app.html#start",
    "title": "Shiny frameworks (part 3, golem)",
    "section": "Start",
    "text": "Start\nTo create a new golem app from the console, enter the following:\n\n\ninstall.packages(\"golem\")\nlibrary(golem)\ngolem::create_golem(path = \"myGolemApp\")\n\n\nIf creating a golem app from RStudio’s New Project Wizard, the following defaults are available:\n\n\n\n\n\nFigure 1: Creating a new golem shiny app\n\n\nThe initial folder structure for a new golem application is below:\n\n\nmyGolemApp\n    ├── DESCRIPTION\n    ├── NAMESPACE\n    ├── R\n    │   ├── app_config.R\n    │   ├── app_server.R\n    │   ├── app_ui.R\n    │   └── run_app.R\n    ├── dev\n    │   ├── 01_start.R\n    │   ├── 02_dev.R\n    │   ├── 03_deploy.R\n    │   └── run_dev.R\n    ├── inst\n    │   ├── app\n    │   │   └── www\n    │   │       └── favicon.ico\n    │   └── golem-config.yml\n    ├── man\n    │   └── run_app.Rd\n    ├── myGolemApp.Rproj\n    ├── renv\n    │   ├── activate.R\n    │   ├── sandbox\n    │   │   └── R-4.2\n    │   └── settings.dcf\n    └── renv.lock\n\n12 directories, 17 files\n\n\n\ndev/ scripts\nThe dev/ folder contains golem‘s ’guided tour’ scripts and dev/run_dev.R:\n\n\nBelow are the scripts to guide you through developing your golem app and the dev/run_dev.R code.\n\n\ndev/01_start.R opens automatically\n\n\n\nmyGolemApp/dev/\n            ├── 01_start.R\n            ├── 02_dev.R\n            ├── 03_deploy.R\n            └── run_dev.R\n\n1 directory, 4 files\n\n\n\n\ndev/run_dev.R is for running the ‘development version’ of the application.\n\n\n\nIf you’ve been following along with the post in this series, you should recognize most of the items in the dev/ scripts. Even if you are familiar with R package developement, you can think of these scripts as a ‘shiny app development checklist.’\nDESCRIPTION\nIn the dev/01_start.R script, users build a DESCRIPTION file with golem::fill_desc()\n\n\nfill_desc() uses desc package, so the sections are entered in a key = \"value\" format\n\nBelow are the values I’ve used in myGolemApp\n\n\n\n\nCodegolem::fill_desc(\n  pkg_name = \"myGolemApp\",\n  pkg_title = \"An example goelm app\",\n  pkg_description = \"A working example of the golem package.\",\n  author_first_name = \"Martin\",\n  author_last_name = \"Frigaard\",\n  author_email = \"mjfrigaard@pm.me\",\n  repo_url = NULL # The URL of the GitHub Repo (optional)\n)\n\n\n\n\nIn dev/02_dev.R, the attachment::att_amend_desc() will “Amend DESCRIPTION with dependencies read from package code parsing”. If attachment is not installed, use install.package('attachment')\n\n\n\nPackage files\n\n\ndev/01_start.R also contains the usethis functions for for creating common package development files:\n\nLICENSE: usethis::use_mit_license()\nREADME: usethis::use_readme_rmd()\nCode of Conduct: usethis::use_code_of_conduct()\nLifecycle badge: usethis::use_lifecycle_badge(\"Experimental\")\nNEWS.md: usethis::use_news_md(open = FALSE)\nGit: usethis::use_git()\n\n\n\ngolem files\n\n\nThe golem functions in dev/01_start.R are for setting the golem options and using recommended tests.\n\nOptions: golem::set_golem_options()\nTests (with testthat): golem::use_recommended_tests()\nFavicon: golem::use_favicon()\nHelper functions: golem::use_utils_ui() and golem::use_utils_server() create golem’s UI (R/golem_utils_ui.R) and server (R/golem_utils_server.R) utility functions in the R/ folder\n\n\n\n\n\n\n\n\n\ngolem gives away lots of free code!\n\n\n\n\n\n\nBoth R/golem_utils_ui.R and R/golem_utils_server.R contain a lot of helper functions that come in handy if you’re tired of writing out particular function names (like reactiveValuesToList() or column(width = 6)/column(width = 12))\nCheck them out here:\n\ngolem_utils_ui.R\ngolem_utils_server.R\n\n\n\n\n\nApp files\nThe dev/02_dev.R file covers development, so most of the golem functions are for creating files in the R/ and inst/ folders:\n\n\nThe initial R/ scripts in a new golem app:\n\nR/\n├── app_config.R\n├── app_server.R\n├── app_ui.R\n└── run_app.R\n\n1 directory, 4 files\n\n\n\nR/app_ui.R and R/app_server.R are golem’s version of ui.R and server.R\n\n\n\nClick on Code to view code in R/app_ui.R\n\n\n\nCode#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_ui <- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"BareBonesGolem\")\n    )\n  )\n}\n\n#' Add external Resources to the Application\n#'\n#' This function is internally used to add external\n#' resources inside the Shiny application.\n#'\n#' @import shiny\n#' @importFrom golem add_resource_path activate_js favicon bundle_resources\n#' @noRd\ngolem_add_external_resources <- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"BareBonesGolem\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\n\n\nClick on Code to view code in R/app_server.R\n\n\n\nCode#' The application server-side\n#'\n#' @param input,output,session Internal parameters for {shiny}.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_server <- function(input, output, session) {\n  # Your application server logic\n}\n\n\n\n\n\nrun_app.R is an exported function that is available for me to run my app after I’ve installed the package:\n\n\n\nlibrary(myGolemApp)\nmyGolemApp::run_app()\n\n\n\nAdd code files\n\n\ngolem has wrappers for creating modules and helper functions in the R/ folder:\n\n\n## Add modules ----\n## Create a module infrastructure in R/\ngolem::add_module(name = \"name_of_module1\", with_test = TRUE) \ngolem::add_module(name = \"name_of_module2\", with_test = TRUE) \n\n## Add helper functions ----\n## Creates fct_* and utils_*\ngolem::add_fct(\"helpers\", with_test = TRUE)\ngolem::add_utils(\"helpers\", with_test = TRUE)\n\n\n\n\nwith_test = TRUE ensures these functions will also create test files in tests/\n\n\n\nConfigure\n\n\nThe R/app_config.R file contains two functions: app_sys() (covered above) and get_golem_config(), which reads the inst/golem-config.yml configuration file\n\n\ndefault:\n  golem_name: myGolemApp\n  golem_version: 0.0.0.9000\n  app_prod: no\nproduction:\n  app_prod: yes\ndev:\n  golem_wd: !expr here::here()\n\n\n\n\ngolem-config.yml gives access to the app version, name, and (development) working directory, so it can be used to add “production-only elements” and is “shareable across golem projects”\n\n\n\n\ngolem uses app_sys() (a wrapper around system.file()) to add external resources to the application\n\n\napp_sys() is included in the R/app_config.R file\n\n\n\n# Access files in the current app\napp_sys <- function(...) {\n  system.file(..., package = \"myGolemApp\")\n}\n\n\n\n\nget_golem_config() is also included in the R/app_config.R file\n\nClick on Code to view get_golem_config()\n\n\n\nCode# Read App Config\nget_golem_config <- function(\n  value,\n  config = Sys.getenv(\n    \"GOLEM_CONFIG_ACTIVE\",\n    Sys.getenv(\n      \"R_CONFIG_ACTIVE\",\n      \"default\"\n    )\n  ),\n  use_parent = TRUE,\n  # Modify this if your config file is somewhere else\n  file = app_sys(\"golem-config.yml\")\n) {\n  config::get(\n    value = value,\n    config = config,\n    file = file,\n    use_parent = use_parent\n  )\n}\n\n\n\n\nTesting\nThe tests/ folder is created in dev/01_start.R with golem::use_recommended_tests(), which is a wrapper around usethis::use_testthat()\n\ngolem::use_recommended_tests() adds the spelling package to our DESCRIPTION and updates the WORDLIST\n\nThe tests golem creates in the tests/testthat/ folder can serve as a nice guide for users new to testthat\n\nThe tests folder uses the testthat framework\n\n\n\n\ntests/testthat/\n            ├── _snaps\n            ├── test-golem-recommended.R\n            ├── test-golem_utils_server.R\n            └── test-golem_utils_ui.R\n\n2 directories, 4 files\n\n\n\nIn dev/02_dev.R the golem::use_utils_ui() and golem::use_utils_server() functions also include a with_test = TRUE argument, which creates a tests/ folder (if it doesn’t already exist)\n\n\nExternal\nThe inst/ file initially has the following contents/structure:\n\ninst/\n  ├── WORDLIST\n  ├── app/\n  │   └── www/\n  │       └── favicon.ico\n  └── golem-config.yml \n\nThe golem-config.yml file is covered above, but the inst/app/ folder works just like the inst/extdata folder (it is loaded when the package is installed and makes these files available to the application).\n\ndev/02_dev.R includes golem wrappers for including CSS, JavaScript, and SASS files to the inst/app/www/ folder:\ngolem::add_js_file(\"script\")\ngolem::add_js_handler(\"handlers\")\ngolem::add_css_file(\"custom\")\ngolem::add_sass_file(\"custom\")\nDeploy\n\n\nThe final step in the guided tour contains functions for deploying a new application to Posit Connect or Docker (it opens automatically after completing the dev/02_dev.R)\n\nClick on Code to view code in dev/03_deploy.R\n\n\n\nCode## Run checks ----\n## Check the package before sending to prod\ndevtools::check()\nrhub::check_for_cran()\n\n# Deploy\n\n## Local, CRAN or Package Manager ----\n## This will build a tar.gz that can be installed locally,\n## sent to CRAN, or to a package manager\ndevtools::build()\n\n## RStudio ----\n## If you want to deploy on RStudio related platforms\ngolem::add_rstudioconnect_file()\ngolem::add_shinyappsio_file()\ngolem::add_shinyserver_file()\n\n## Docker ----\n## If you want to deploy via a generic Dockerfile\ngolem::add_dockerfile_with_renv()\n\n## If you want to deploy to ShinyProxy\ngolem::add_dockerfile_with_renv_shinyproxy()\n\n\n\n\nRStudio (Posit) Connect\n\n\ngolem::add_rstudioconnect_file(), golem::add_shinyappsio_file(), and golem::add_shinyserver_file()\n\n\n\nDocker\n\n\ngolem::add_dockerfile_with_renv() and golem::add_dockerfile_with_renv_shinyproxy()\n\n\n\nI’ll deploy my app using shinyapps.io, so after running golem::add_shinyappsio_file() I will see the following output and a new app.R file.\n\n\nClick on Code to view the output from golem::add_shinyappsio_file()\n\n\n\nCodegolem::add_shinyappsio_file()\n── Creating _disable_autoload.R ──────────────────────────────────────────────────────\n✔ Created\n✔ Setting active project to '/Users/mjfrigaard/projects/myGolemApp'\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\n✔ Adding '^rsconnect$' to '.Rbuildignore'\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\n✔ File created at /Users/mjfrigaard/projects/myGolemApp/app.R\nTo deploy, run:\n• rsconnect::deployApp()\n\n• Note that you'll need to upload the whole package to ShinyApps.io\n\n\n\n\nThe app.R contents\n\n\nClick on Code to view the contents of app.R\n\n\n\nCode# Launch the ShinyApp (Do not remove this comment)\n# To deploy, run: rsconnect::deployApp()\n# Or use the blue button on top of this file\n\npkgload::load_all(export_all = FALSE, helpers = FALSE, attach_testthat = FALSE)\noptions( \"golem.app.prod\" = TRUE)\nmyGolemApp::run_app() # add parameters here (if any)"
  },
  {
    "objectID": "pages/posts/my-golem-app/my-golem-app.html#build",
    "href": "pages/posts/my-golem-app/my-golem-app.html#build",
    "title": "Shiny frameworks (part 3, golem)",
    "section": "Build",
    "text": "Build\nBuilding an application with golem is very similar to developing an R package. New code files are placed in R/, external resources are placed in inst/, etc. I’ll cover creating modules and utility functions in the next section.\nWriting code\nNew modules and utility functions can be created with golem::add_module() or golem::add_utils()/golem::add_fct()\n\n\nThese functions are added to the R/ folder and include @noRd by default (which must be removed create the .Rd files in the man/ folder)\n\n\n# UI module template -------------------\n#' test UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd\n#'\n#' @importFrom shiny NS tagList\n# server module template ---------------\n#' test Server Functions\n#'\n#' @noRd\n\n\n\n\nUI module functions end with a _ui suffix:\n\nClick on Code to view code in R/mod_plot.R\n\n\n\n#' plot UI Function\n#'\n#' @param id\n#'\n#' @return shiny UI module\n#' @export mod_plot_ui\n#'\n#' @importFrom shiny NS tagList tags\n#' @importFrom shiny plotOutput verbatimTextOutput\nmod_plot_ui <- function(id) {\n  ns <- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\n          \"The code for this application comes from the \",\n          shiny::tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    ),\n    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n\nServer module functions end with a _server suffix:\n\nClick on Code to view code in R/mod_plot.R\n\n\n\nCode#' plot Server Functions\n#'\n#' @param id module id\n#' @param var_inputs inputs from mod_var_input\n#'\n#' @return shiny server module\n#' @export mod_plot_server\n#'\n#' @importFrom shiny NS moduleServer reactive\n#' @importFrom tools toTitleCase\n#' @importFrom shiny renderPlot\n#' @importFrom stringr str_replace_all\n#' @importFrom ggplot2 labs theme_minimal theme\nmod_plot_server <- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    movies <- myGolemApp::movies\n\n    inputs <- shiny::reactive({\n      plot_title <- tools::toTitleCase(var_inputs$plot_title())\n      list(\n        x = var_inputs$x(),\n        y = var_inputs$y(),\n        z = var_inputs$z(),\n        alpha = var_inputs$alpha(),\n        size = var_inputs$size(),\n        plot_title = plot_title\n      )\n    })\n\n    output$scatterplot <- shiny::renderPlot({\n      plot <- point_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n## To be copied in the UI\n# mod_plot_ui(\"plot_1\")\n\n## To be copied in the server\n# mod_plot_server(\"plot_1\")\n\n\n\n\nSee all of the modules I use in this application here on GitHub examples\n\n\n\n\n\n\n\n\n\n\nModule names\n\n\n\n\n\n\nIncluding mod in the name of module scripts and functions makes it easier to separate them from other functions in my package namespace, if I’m using tab-completion, or if I’m searching for a particular file using Ctrl + .:\n\n\n\n\n\nFigure 2: Go to File/Function in RStudio\n\n\n\n\n\n\n\n\nInclude tests for new modules and functions using the with_test = TRUE argument\n\n\ntests/testthat/\n            ├── _snaps\n            ├── test-golem-recommended.R\n            ├── test-golem_utils_server.R\n            ├── test-golem_utils_ui.R\n            ├── test-mod_plot.R\n            ├── test-mod_plot_utils_server.R\n            └── test-mod_var_input.R\n\n2 directories, 6 files\n\n\n\nAdding resources\n\n\nTo include other files (like images), add the image file to inst/app/www/, then add the www/ to the path (see example UI code below)\n\n\n# add icon\nshiny::tags$img(src = \"www/shiny.png\")\n\n\n\n\nIf I wanted to include images in their own folder (like images/), I can use golem::addResourcePath() to add the name of the sub-folder to inst/app/\n\n\n# add icon\ngolem::add_resource_path(\n          prefix = 'images', \n          directoryPath = system.file('app/images', package = 'myGolemApp'))\n\n\n\n\nNow I can add the image file to the inst/app/www/images/ folder and include the following code in the UI:\n\n\n# add icon\nshiny::tags$img(src = \"www/images/golem-hex.png\")\n\n\n\n\nIn R/app_ui.R, the app_ui() function contains the UI layout functions (fluidPage(), sidebarLayout(), etc.), and a call to golem_add_external_resources():\n\nClick on Code to view the updated R/app_ui.R\n\n\n\nCode#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_ui <- function(request) {\n  shiny::tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    shiny::fluidPage(\n      shiny::tags$h1(\"myGolemApp\"),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          # add shiny hex in www/\n          shiny::tags$img(src = \"www/shiny.png\"),\n          mod_plot_ui(\"plot\"),\n          # add golem hex (in www/images/)\n          shiny::fluidRow(\n            shiny::tags$em(shiny::tags$h4(\n              \"Brought to you by: \",\n              shiny::tags$img(src = \"www/images/golem-hex.png\")\n            ))\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n\nClick on Code to view golem_add_external_resources()\n\n\n\nCode# this is also included in the app_ui.R script\ngolem_add_external_resources <- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"myGolemApp\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\n\n\nNow when I run devtools::load_all(), devtools::document(), install/restart, and load the package, I see the images properly rendered with the application:\n\n\n\n\n\n\nFigure 3: Images in myGolemApp\n\n\n\n\n\n\n\n\nUsing the inst/ folder\n\n\n\n\n\n\ngolem takes advantage of the inst/ folder and R package structure to allow users to provide additional ‘assets’ to the application.\nFor example, if we use golems app_sys() function on the local directory ('.'), we see all the folders available to the application at runtime\nfs::dir_tree(path = app_sys('.'))\n/Library/Frameworks/R.framework/Versions/4.2/Resources/library/myGolemApp/\n├── DESCRIPTION\n├── INDEX\n├── LICENSE\n├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R\n│   ├── myGolemApp\n│   ├── myGolemApp.rdb\n│   └── myGolemApp.rdx\n├── WORDLIST\n├── app\n│   └── www\n│       ├── favicon.ico\n│       ├── images\n│       │   └── golem-hex.png\n│       └── shiny.png\n├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata\n│   └── movies.RData\n├── golem-config.yml\n├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── myGolemApp.rdb\n│   ├── myGolemApp.rdx\n│   └── paths.rds\n└── html\n    ├── 00Index.html\n    └── R.css"
  },
  {
    "objectID": "pages/posts/my-golem-app/my-golem-app.html#use",
    "href": "pages/posts/my-golem-app/my-golem-app.html#use",
    "title": "Shiny frameworks (part 3, golem)",
    "section": "Use",
    "text": "Use\nIf you typically build shiny apps in a single app.R file (or in ui.R and server.R files), the golem framework might seem overwhelming. I’ll give a quick overview of some areas I found confusing when I started using goelm:\n\n\ngolem apps are run using the myGolemApp::run_app() function (included in the R/ folder)\n\n\n\n\n\n\nFigure 4: Initial myGolemApp\n\n\n\nWhile developing, golem also comes with a run_dev function that reads the R/run_dev.R file and evaluates the code.\n\n\nClick on Code to view code in dev/run_dev.R\n\n\n\nCode#' Run run_dev.R\n#'\n#' @param file File path to `run_dev.R`. Defaults to `R/run_dev.R`.\n#' @inheritParams add_module\n#'\n#' @export\n#'\n#' @return Used for side-effect\nrun_dev <- function(\n  file = \"dev/run_dev.R\",\n  pkg = get_golem_wd()\n) {\n\n  # We'll look for the run_dev script in the current dir\n  try_dev <- file.path(\n    pkg,\n    file\n  )\n\n  # Stop if it doesn't exists\n  if (file.exists(try_dev)) {\n    run_dev_lines <- readLines(\n      \"dev/run_dev.R\"\n    )\n  } else {\n    stop(\n      \"Unable to locate dev file\"\n    )\n  }\n\n  eval(\n    parse(\n      text = run_dev_lines\n    )\n  )\n}\n\n\n\n\ndev/ contains golem‘s ’guided tour’ scripts (01_start.R, 02_dev.R, 03_deploy.R) and run_dev.R (covered above) - dev/ is also where to place R scripts that aren’t intended to be part of the application package.\nR/: the primary app files for the UI and server are stored in the R/ folder (R/app_ui.R, R/app_server.R, R/run_app.R), as well as the configuration function (R/app_config.R): - Use the R/app_config.R to configure the application to be run on different locations (computers or servers).\ninst/: the inst/ folder holds the golem-config.yml and location of any external app files.\n\nThe golem workflow is similar to building an R package:\n\nwrite functions (modules, helper functions, etc.)\nload, document, check, test, install, etc.\nthen render application (either with myGolemApp::run_app() or golem::run_dev())\n\n\nDeploying the application can be done with a single function: rsconnect::deployApp(), which creates the following output:\n\n\nClick on Code to view the deploy output\n\n\n\nCodePreparing to deploy application...DONE\nUploading bundle for application: 8775458...DONE\nDeploying bundle: 7054081 for application: 8775458 ...\nWaiting for task: 1288644047\n  building: Parsing manifest\n  building: Building image: 8376474\n  building: Installing system dependencies\n  building: Fetching packages\n  building: Building package: covr\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 8376474\n  deploying: Starting instances\n  unstaging: Stopping old instances\nApplication successfully deployed to https://mjfrigaard.shinyapps.io/mygolemapp/"
  },
  {
    "objectID": "pages/posts/my-golem-app/my-golem-app.html#recap",
    "href": "pages/posts/my-golem-app/my-golem-app.html#recap",
    "title": "Shiny frameworks (part 3, golem)",
    "section": "Recap",
    "text": "Recap\nGenerally speaking, golem’s start-up scripts save time and serves as a gentle introduction to some of the functions used in R package development. The golem::add_ functions are an area where (I think) golem really separates itself from standard R packages. Having dedicated shiny development functions (and the app/inst/www folder) reduces the cognitive overhead of mapping the standard R package development functions (i.e., those from usethis and devtools) into shiny-specific development.\n\n\n\n\n\nFigure 5: myGolemApp\n\n\ngolem is a popular framework for a reason–it’s designed to allow developers to build a shiny application and R package simultaneously. Added bonuses include taking advantage of RStudio’s build tools, great documentation, and user-guides.."
  },
  {
    "objectID": "pages/posts/my-pkg-app/my-pkg-app.html",
    "href": "pages/posts/my-pkg-app/my-pkg-app.html",
    "title": "Shiny frameworks (part 2, usethis & devtools)",
    "section": "",
    "text": "This is the second post in my series on shiny application frameworks. In this post, I’ll build a shiny app using two package-development packages (usethis and devtools). The result is myPkgApp, an R package that contains a shiny application."
  },
  {
    "objectID": "pages/posts/my-pkg-app/my-pkg-app.html#start",
    "href": "pages/posts/my-pkg-app/my-pkg-app.html#start",
    "title": "Shiny frameworks (part 2, usethis & devtools)",
    "section": "Start",
    "text": "Start\nTo create a shiny app package, I install devtools (which also installs usethis).\n\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\n\nIf I am creating a package from the console, the function for building a new package is usethis::create_package():\n\n\nusethis::create_package(path = \"myPkgApp\")\n\n\nA new RStudio session will open (and the name of the project–i.e., the name of the .Rproj file–will be identical to the package name).\nIf I am using RStudio’s New Project Wizard to create a new shiny app package, I’d see the following defaults:\n\n\n\n\n\nFigure 1: Default usethis::create_package project setup\n\n\nThe new package built from the console will have the following folder and files:\n\n\nmyPkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── myPkgApp.Rproj\n  \n1 directory, 3 files\n\n\nPackages built from the New Project Wizard will have a few additional folders and files:\n\n\nmyPkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   └── hello.R\n  ├── man/\n  │   └── hello.Rd\n  ├── myRPkg.Rproj\n  └── renv/\n      ├── activate.R\n      ├── sandbox/\n      │   └── R-4.2\n      └── settings.dcf\n\n4 directories, 7 files\n\n\nThese additional files are:\n\n\nhello.R in the R/ folder\n\n\nhello.Rd in the man/ folder\n\na renv/ folder for package management\n\nR/hello.R and man/hello.Rd are boilerplate files and can be deleted, but both package setups have a DESCRIPTION, NAMESPACE, R/ folder, and .Rproj file. These four items can be thought of as the ‘minimal package’ setup required to access RStudio’s Build tools."
  },
  {
    "objectID": "pages/posts/my-pkg-app/my-pkg-app.html#build",
    "href": "pages/posts/my-pkg-app/my-pkg-app.html#build",
    "title": "Shiny frameworks (part 2, usethis & devtools)",
    "section": "Build",
    "text": "Build\n\n\n\n\n\n\nTLDR\n\n\n\n\n\n\nMastering Shiny has a section that shows how to convert a shiny app into an R package. This post is similar, except that it doesn’t assume you’re starting with an application that uses modules.\n\n\n\n\nThe workflow when developing R packages is well documented elsewhere and slightly more involved than working in a single app.R file. However, the additional steps force better habits (and prevent having to rebuild your application entirely from scratch).\nI’ll work through a ’minimum viable product (MVP) using the app code in VanillaApp\nDESCRIPTION\nThe DESCRIPTION file plays an important role in R packages–that’s why creating this file is the first step when converting an existing app (and when creating a new golem apps).\n\n\n\n\n\n\nDESCRIPTION files\n\n\n\n\n\n\n\n\n\n\n‘RStudio and devtools consider any directory containing DESCRIPTION to be a package’ - R Packages\n\n\n\n\nThe initial DESCRIPTION file in myPkgApp is below:\n\n\nPackage: myPkgApp\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R: \n    person(\"First\", \"Last\", , \"first.last@example.com\", \n    role = c(\"aut\", \"cre\"),\n    comment = c(ORCID = \"YOUR-ORCID-ID\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\nThe package name is automatically added, but the remaining fields need to be completed (consult R packages for more information on filling out the DESCRIPTION file).\nThe DESCRIPTION file in the myPkgApp prompts the RStudio IDE to activate the Build tools pane (see below):\n\n\n\n\n\nFigure 2: Package Build tools\n\n\nuse_r()\nI’m going to create myPkgApp using modules to separate the app into the following digestible mental ‘chunks’:\n\nThe app collects the inputs in the shiny::sideBar()\nThese values are then used to create a plot in the shiny::mainPanel()\n\nBased on this functionality, I’ll create one module to collect and return the user-inputs (mod_var_input), and another module to display the plot (mod_display_plot).\nI’ll create these files using usethis::use_r() below:\n\n\nusethis::use_r(\"mod_var_input\")\n\n\n✔ Setting active project to '/Users/mjfrigaard/projects/myPkgApp'\n• Modify 'R/mod_var_input.R'\n• Call `use_test()` to create a matching test file\n\n\nusethis::use_r(\"mod_display_plot\")\n\n\n• Modify 'R/mod_display_plot.R'\n• Call `use_test()` to create a matching test file\n\n\nThe display module also relies on a utility function (plot_points()), so I need to create a script for the utility function, which I put in a file with a name similar to the module it belongs to (i.e., utils_display_plot).\n\n\nusethis::use_r(\"utils_display_plot\")\n\n\n• Modify 'R/utils_display_plot.R'\n• Call `use_test()` to create a matching test file\n\n\nFinally, I’ll place the modules into basic ui and server arguments in a call to shiny::shinyApp():\n\n\nusethis::use_r(\"moviesApp\")\n\n\n• Modify 'R/moviesApp.R'\n• Call `use_test()` to create a matching test file\n\n\nModules consist of two functions; one in the UI (with a _ui suffix), and another in the server (with a _server suffix), but it’s common practice to combine them in a single file.\nBelow is the mod_var_input module:\n\n\nThe ui function is stored in mod_var_input_ui:\n\nClick on Code to view the UI function in R/mod_var_input/R\n\n\n\nCodemod_var_input_ui <- function(id) {\n  ns <- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n\n\nThe server function is stored in mod_var_input_server:\n\nClick on Code to view the server function in R/mod_var_input/R\n\n\n\nCodemod_var_input_server <- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n      list(\n        \"x\" = shiny::reactive({\n          input$x\n        }),\n        \"y\" = shiny::reactive({\n          input$y\n        }),\n        \"z\" = shiny::reactive({\n          input$z\n        }),\n        \"alpha\" = shiny::reactive({\n          input$alpha\n        }),\n        \"size\" = shiny::reactive({\n          input$size\n        }),\n        \"plot_title\" = shiny::reactive({\n          input$plot_title\n        })\n      )\n    )\n  })\n}\n\n\n\n\nView the display module here.\n\n\n\n\nAfter I’ve written the modules and utility functions, I need to add these into the app file, R/moviesApp.R.\n\n\nThis file contains a call to shiny::shinyApp() and includes the module functions (in their relative positions)\n\nNote the ids in each module function pair must match to create the shared namespace.\n\n\n\nmoviesApp <- function() {\n  # call to shinyApp()\n  shiny::shinyApp(\n\n    # UI ----\n    ui = shiny::fluidPage(\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          # UI input module ----\n          mod_var_input_ui(\"vars\")\n        ),\n        # UI display module ----\n        shiny::mainPanel(\n          mod_display_plot_ui(\"plot\")\n        )\n      )\n    ),\n\n    server = function(input, output, session) {\n      # server input module (capturing inputs) ----\n      selected_vars <- mod_var_input_server(\"vars\")\n      # server display module (rendering outputs) ----\n      mod_display_plot_server(\"plot\", \n                              var_inputs = selected_vars)\n    }\n  )\n}\n\n\n\n\nroxygen2\nWhen I’m confident my code works (and the app renders), I want to make sure these functions are properly documented by describing each function with roxygen2 tags. To quickly insert a roxygen2 skeleton, use the RStudio IDE (or the keyboard shortcut: Option + Shift + Command + R)\nThe standard roxygen2 skeleton tags include @param, @return, @export, and @examples\n\n@param lists the existing arguments (or variables) for the function\n@return should be a description of the object/side-effect/thing the function produces (and any warnings or errors if used incorrectly)\n\nThe following roxygen2 tags will be used to update the NAMESPACE file (which you should never edit manually!)\n\n@export will make the function available to other people when they use your package\n\n@importFrom vs. @import\n\nit’s always a good idea to be explicit about the external functions and packages you’re using, so most of the time you should use @importFrom (there’s even a handy helper usethis::use_import_from(\"package\", \"function\"))\n\n\n@import should only be used when “you make such heavy use of so many functions from another package that you want to import its entire namespace. This should be relatively rare.”\n\n\n\n\nroxygen2 imports and exports are covered in more depth in R packages..\nYou can see the full code for point_plot() below (or follow this link to view all the modules in the R/ folder):\n\nClick on Code to view\n\n\n\nCode#' Plot points (shiny)\n#'\n#' @param df input dataset (tibble or data.frame)\n#' @param x_var x variable\n#' @param y_var y variable\n#' @param col_var color variable\n#' @param alpha_var alpha value\n#' @param size_var size value\n#'\n#' @return plot object\n#' @export point_plot\n#'\n#' @importFrom ggplot2 ggplot aes geom_point\n#'\n#' @examples\n#' require(myPkgApp)\n#' movies <- myPkgApp::movies\n#' point_plot(df = movies,\n#'   x_var = \"critics_score\",\n#'   y_var = \"imdb_rating\",\n#'   col_var = \"critics_rating\",\n#'   alpha_var = 1/3,\n#'   size_var = 2)\n#' }\npoint_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\n\n\n\n\nTip: roxygen2 skeleton\n\n\n\n\n\n\nAs well as generating .Rd files, roxygen will also create a NAMESPACE for you, and will manage the Collate field in DESCRIPTION\n\n\n\n\n\nFigure 3: Standard roxygen2 skeleton\n\n\n\n\n\n\nload_all()\nAfter documenting everything with roxygen2, I want to make sure none of the functions are in my Environment (remove with rm() if necessary) and load the functions with devtools::load_all().\n\n\ndevtools::load_all()\n\n\nℹ Loading myPkgApp\n\n\ndocument()\nThe devtools::document() function will create the .Rd files in the man/ folder.\n\n\ndevtools::document()\n\n\nℹ Updating myPkgApp documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\nℹ Loading myPkgApp\nWriting NAMESPACE\nWriting mod_plot_ui.Rd\nWriting mod_plot_server.Rd\nWriting point_plot.Rd\nWriting mod_var_input_ui.Rd\nWriting mod_var_input_server.Rd\nWriting moviesApp.Rd\n\n\nIt’s important to understand that the roxygen2 tags are used to create the .Rd files in the man/ folder, and update the NAMESPACE, but devtools::document() does not update the Imports: section in the DESCRIPTION.\nTo add packages dependencies to the DESCRIPTION, you’ll need to use the usethis::use_package() function. Read more on this topic in Confusion about Imports.\nThe table below shows the connection between roxygen2 tags, the resulting NAMESPACE entry, and what should be listed in the DESCRIPTION.\n\n\n\n\n\n\n\nroxygen2, NAMESPACE & DESCRPTION\n\n\n\n\n\n\n\n\n\n\nroxygen2 tag\n\n\nNAMESPACE directive\n\n\nDESCRIPTION\n\n\n\n\n\n@importFrom\n\n\nimportFrom() : import selected object from another NAMESPACE\n\n\nImports:\n\n\n\n\n@import\n\n\nimport(): import all objects from another package’s NAMESPACE.\n\n\nImports:\n\n\n\n\n@export\n\n\nexport() : export the function, method, generic, or class so it’s available outside of the package (in the NAMESPACE)\n\n\nNothing\n\n\n\n\n\n\n\n\n\ninstall()\nNow I want to make sure I can install the package with devtools::install()\n\n\ndevtools::install()\n\n\n── R CMD build ────────────────────────────────────────────────────────────────\n✔  checking for file ‘/Users/mjfrigaard/projects/myPkgApp/DESCRIPTION’ ...\n─  preparing ‘myPkgApp’: (1.8s)\n✔  checking DESCRIPTION meta-information\n─  checking for LF line-endings in source and make files and shell scripts (520ms)\n─  checking for empty or unneeded directories\n   Omitted ‘LazyData’ from DESCRIPTION\n─  building ‘myPkgApp_0.1.0.tar.gz’\n   \nRunning /Library/Frameworks/R.framework/Resources/bin/R CMD INSTALL \n  --install-tests \n* installing to library ...\n* installing *source* package ‘myPkgApp’ ...\n** using staged installation ...\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (myPkgApp)\n\n   Restarting R session...\n\n* Project '~/projects/myPkgApp' loaded. [renv 0.16.0]\nlibrary(myPkgApp)\n\n\nI can also use RStudio’s Build tools:\n\n\n\n\n\nFigure 4: Build install package\n\n\nThe Install icon in the Build pane is great, because installs the package, restarts the R session, and loads the package all with one click!\n\n\n\n\n\nFigure 5: Build restart and load\n\n\n\n\n\n\n\n\nTip: RStudio Development Tools\n\n\n\n\n\n\nPackage development workflow functions are also available as keyboard shortcuts:\n\nLoad = Ctrl + Shift + L/Shift + Cmd + L\nDocument = Ctrl + Shift + D/Shift + Cmd + D\nInstall & restart = Ctrl + Shift + B/Cmd + Shift + B\n\n\n\n\n\nThe sequence I’ve demonstrated above (create .R file, write function, document with roxygen2, load, document, install) is a ‘minimal version’ of the full development workflow. If possible, you should strive to adopt all of the steps. But I’ve found writing and documenting the modules and utility functions (and getting them working within a call to shinyApp()) is an acceptable trade-off to get an initial app up and running.\nOnce this ‘beta’ version of the app is deployed, I will come back to the app to refactor, write tests, and make sure all the items in devtools::check() pass.\nRecap: the R/ folder\nStoring the application’s code in the R/ folder and (using RStudio’s build tools) keeps files organized, well documented, and self-contained:\n\nAll the code is stored in the R/ folder\nI’ve separated my code into smaller pieces (modules) that can be tested independently (more on this later)\n\nMy dependencies are being managed by roxygen2 and devtools::document(), which will update the NAMESPACE with any functions tagged with @importFrom (or @import)\n\nI can also access functions I’ve written outside by adding @export\n\n\n\n\n\n\n\n\n\nFigure 6: Function documentation in man/ folder\n\n\nNow that I have the R version/package management being tracked and stored with renv/ & renv.lock, function documentation in the .Rd files, the DESCRIPTION and NAMESPACE, I can move onto adding and using data in a shiny app package.\nuse_data_raw()\nusethis::use_data() or usethis::use_data_raw() make it simple to add data to the application package:\n\n\nusethis::use_data_raw(\"movies\")\n\n\n✔ Creating 'data-raw/'\n✔ Writing 'data-raw/movies.R'\n• Modify 'data-raw/movies.R'\n• Finish the data preparation script in 'data-raw/movies.R'\n• Use `usethis::use_data()` to add prepared data to package\n\n\nIn the data-raw/movies.R script, I want to import the movies.RData file, but where should I import it from? It depends. In R packages, data is stored in either data/ or data-raw/. To access a copy of the movies dataset in myPkgApp (i.e., with myPkgApp::movies), I can place the movies.RData file in data-raw/ and import it by adding the following to data-raw/movies.R:\n\n\n## code to prepare `movies` dataset goes here\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n\n\nNote data-raw/movies.R includes a call to usethis::use_data(), and when it’s executed, I can see a data/ folder is created and movies is saved as movies.rda:\n\n\nload(\"data-raw/movies.RData\")\nusethis::use_data(movies, overwrite = TRUE)\n\n\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\n\n\n\n\n\n\n\n\nExternal data\n\n\n\n\n\n\nIf I want to test functions in myPkgApp using movies.RData (or another dataset), those should be placed in inst/extdata/:\nmyPkgApp/\n    └──inst/\n         └── extdata/\n                └── movies.RData\n\n2 directories, 1 file\n\n\n\n\n\ninst/\nThe neat thing about the inst/ folder is that after we’ve loaded and installed our package, we can access the files in inst/extdata/ with the system.file() function:\n\n\nfs::dir_tree( # wrap this in a folder tree\n  system.file(\"extdata\", package = \"myPkgApp\"))\n\n\n/Users/mjfrigaard/Library/Caches/R/renv/library/myPkgApp-1687e31a/R-4.2/x86_64-apple-darwin17.0/myPkgApp/extdata\n                                                  └── movies.RData\n\n\nThe system.file() function will show me the path to the locally installed version of the package (hence the /Users/mjfrigaard/Library/ at the beginning of the path). The inst/exdata/ folder comes in handy for adding example data, but it’s also useful for application development (more on that later).\n\n\n\n\n\n\nTip: inst/ folder\n\n\n\n\n\n\nTake a look at the inst/extdata/ folder for readr and the accompanying readr_example() function to understand more about how this works.\n\n\n\n\nRecap: App data\nR Packages have a consistent and standardized way of storing data, and have designated locations for internal and external data.\n\n\n\n\n\nFigure 7: Package data folders\n\n\nuse_readme_rmd()\nFunction documentation is handled with the R/ folder and roxygen2 comments/tags, but myPkgApp needs a README file, and a place for long-form documentation. Fortuntely, RMarkdown handles each of these well:\n\n\nI can create a README file using usethis::use_readme_md() or usethis::use_readme_rmd()\n\nI prefer the .Rmd file because it comes with executable code chunks.\n\n\n\nusethis::use_readme_rmd()\n\n\n✔ Setting active project to '/Users/mjfrigaard/projects/myPkgApp'\n✔ Writing 'README.Rmd'\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n• Modify 'README.Rmd'\n• Update 'README.Rmd' to include installation instructions.\n✔ Writing '.git/hooks/pre-commit'\n\n\n\nWhen I knit README.Rmd, it automatically generates the README.md for the package.\n\n\nuse_vignette()\nFor long-form documentation I can use vignettes.\n\n\nVignettes can be created with usethis::use_vignette()\n\n\nusethis::use_vignette(\"myPkgApp\")\n\n\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Setting VignetteBuilder field in DESCRIPTION to 'knitr'\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Writing 'vignettes/myPkgApp.Rmd'\n• Modify 'vignettes/myPkgApp.Rmd'\n\n\n\n\nVignettes are also written in RMarkdown and rendered whenever the package is built/installed.\n\n\nmyPkgApp/\n    └── vignettes/\n            └── myPkgApp.Rmd\n\n1 directory, 1 file\n\n\nBy combining rmarkdown and knitr, R packages have a documentation framework that has the added benefit of being somewhat fool-proof: vignettes have to successfully render for the package to be installed.\n\n\n\n\n\nFigure 8: Package vignettes\n\n\n\n\n\n\n\n\nVignette figures\n\n\n\n\n\n\nImages in vignettes are kept in man/figures/\nmyPkgApp/\n  ├── vignettes/\n  │       └── myPkgApp.Rmd\n  └── man/\n      └── figures/\n          └── myPkgApp-img-1.png\n\n\n\n\n\nRecap: documentation\nThe vignettes folder will long-form documentation about how the application works, use cases, and features (and roxygen2 will document each function).\n\n\n\n\n\nFigure 9: Documentation in README and vignettes/\n\n\nuse_testthat()\nTesting is an important part of any package, and apps tend to require additional tests (especially when they’re moving from ‘development’ into ‘production’ environments).\nTo apply the testing framework provided by the testthat package. package, I’ll use usethis::use_testthat():\n\n\nusethis::use_testthat()\n\n\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Setting Config/testthat/edition field in DESCRIPTION to '3'\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\n• Call `use_test()` to initialize a basic test file and open it for editing.\n\n\nThis creates a new tests/ folder, with a testthat/ sub-folder and script.\n\n\nmyPkgApp/\n    └── tests/\n          ├── testthat/\n          └── testthat.R\n        \n2 directories, 1 file\n\n\nWriting tests\ntestthat is designed for unit tests (i.e., testing each functional ‘unit’ in the code), but for shiny apps, we need to think beyond standard unit testing. We need to confirm the functions work and return predictable results, but we also need to make sure they play well with each other (integration tests), and that the application can be deployed (system tests).\nRecap: testing\nTesting is well described in the shiny documentation and in Mastering Shiny. Generally speaking, unit tests are performed with testthat, and module testing can be done with shiny::testServer(). To test the full application (or a specific behavior) use the shinytest2 package.\n\n\n\n\n\nFigure 10: Testing framework from testthat"
  },
  {
    "objectID": "pages/posts/my-pkg-app/my-pkg-app.html#use",
    "href": "pages/posts/my-pkg-app/my-pkg-app.html#use",
    "title": "Shiny frameworks (part 2, usethis & devtools)",
    "section": "Use",
    "text": "Use\nUsing an app built as a package is similar to using any R function we’ve loaded from a package. After successfully loading, documenting, and installing the package, I can run the app by loading the myPkgApp (with library(myPkgApp)) and moviesApp():\n\n\n\n\n\nFigure 11: myPkgApp::moviesApp()"
  },
  {
    "objectID": "pages/posts/my-pkg-app/my-pkg-app.html#recap",
    "href": "pages/posts/my-pkg-app/my-pkg-app.html#recap",
    "title": "Shiny frameworks (part 2, usethis & devtools)",
    "section": "Recap",
    "text": "Recap\nI’ve skipped over some development steps covered in R packages (license, using Git/GitHub, code coverage, NEWS, etc.), but hopefully you’ve seen that by building shiny apps as R packages unlocks a suite of developer tools (and a common structure).\nmyPkgApp the package holds the code, data, documentation, and includes explicit information on the dependencies and requirements (in the DESCRIPTION and NAMESPACE).\nmyPkgApp is a substantial improvement over VanillaApp. Next I’ll cover setting up a shiny application with golem."
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html",
    "href": "pages/posts/purrr101/purrr101.html",
    "title": "purrr updates (v1.0.0)",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis post is currently under development. Thank you for your patience.\nThis post is going to cover the recent updates to the purrr package. The release of version 1.0.0 (and dev version v1.0.1) had some breaking changes, which I will cover below. But first, I’ll dive into some attributes of R’s functions and objects that make purrr particularly useful, and I’ll work through iteration problems I’ve encountered (and solved with purrr)."
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#generic-functions-s3-objects",
    "href": "pages/posts/purrr101/purrr101.html#generic-functions-s3-objects",
    "title": "purrr updates (v1.0.0)",
    "section": "Generic functions & S3 objects",
    "text": "Generic functions & S3 objects\nR’s syntax avoids explicit iteration by allowing certain generic functions to be used across different types (or objects). For example, the base plot() and summary() functions are S3 generic function:\n\n\nsloop::ftype(plot)\n\n[1] \"S3\"      \"generic\"\n\nsloop::ftype(summary)\n\n[1] \"S3\"      \"generic\"\n\n\n\nWhich means plot() can be applied to S3 objects, like time-series (ts) and rectangular datasets (data.frame):\n\n\nsloop::otype(datasets::LakeHuron)\n## [1] \"S3\"\nclass(datasets::LakeHuron)\n## [1] \"ts\"\nsloop::otype(datasets::chickwts)\n## [1] \"S3\"\nclass(datasets::chickwts)\n## [1] \"data.frame\"\n\n\nsummary(datasets::LakeHuron)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   576.0   578.1   579.1   579.0   579.9   581.9\nsummary(datasets::chickwts)\n##      weight             feed   \n##  Min.   :108.0   casein   :12  \n##  1st Qu.:204.5   horsebean:10  \n##  Median :258.0   linseed  :12  \n##  Mean   :261.3   meatmeal :11  \n##  3rd Qu.:323.5   soybean  :14  \n##  Max.   :423.0   sunflower:12\n\n\nplot(datasets::LakeHuron)\nplot(datasets::chickwts)\n\n\n\n\n\nTime-series plot\n\n\n\n\n\n\nScatter Plot\n\n\n\n\n\n\n\nsummary() is a particularly versatile function, because it can be used on data.frames, a single column in a data.frame, model outputs, and more.\n\nClick Code below to view an example using summary()\n\n\n\nCode# get summary of columns ----------------------------------------------------\nsummary(mtcars$hp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    52.0    96.5   123.0   146.7   180.0   335.0\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n\n# store model output  -------------------------------------------------------\nlm_mod <- lm(formula = mpg ~ hp, data = mtcars)\nlm_mod\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Coefficients:\n## (Intercept)           hp  \n##    30.09886     -0.06823\n\n# get summary of model output -----------------------------------------------\nsummary(lm_mod)\n## \n## Call:\n## lm(formula = mpg ~ hp, data = mtcars)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept) 30.09886    1.63392  18.421  < 2e-16 ***\n## hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 3.863 on 30 degrees of freedom\n## Multiple R-squared:  0.6024, Adjusted R-squared:  0.5892 \n## F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n# pass the output from one S3 generic to another S3 generic -----------------\ncoef(summary(lm_mod))\n##                Estimate Std. Error   t value     Pr(>|t|)\n## (Intercept) 30.09886054  1.6339210 18.421246 6.642736e-18\n## hp          -0.06822828  0.0101193 -6.742389 1.787835e-07"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#fp-oop",
    "href": "pages/posts/purrr101/purrr101.html#fp-oop",
    "title": "purrr updates (v1.0.0)",
    "section": "FP + OOP",
    "text": "FP + OOP\nplot() and summary() are parametric polymorphic (generic) functions, which means we see slightly different behaviors based on the object we pass into it.\nAs you can see, generic functions are flexible and efficient because we’re not having to define a new function for each object–the output from the function depends (in part) on the structure of the object.\n\nFunctional programming is complementary to object-oriented programming, which has been the dominant programming paradigm for the last several decades. - Advanced R, 2nd edition\n\nThe relationship between functions and objects is what makes purrr (and other tools for iteration) extremely helpful for solving common problems programmers encounter when working with data. Similar to generic functions, these functions allow us to express iterative behavior using a complete and consistent set of tools."
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#iteration-problems",
    "href": "pages/posts/purrr101/purrr101.html#iteration-problems",
    "title": "purrr updates (v1.0.0)",
    "section": "Iteration problems",
    "text": "Iteration problems\nIn programming, iteration refers to defining an input and applying an operation over every part of it. Some examples of problems that iteration can solve include:\n\nYou have a list of objects and you’d like to apply a function (or a series of functions) over the elements in the list\nYou have a folder full of files you’d like to rename or copy to a new directory\nYou’d like to download a collection of files from separate URLS\nYou have several years of data, and each year is contained in separate file. You’d like to read these data into R, combine them into a single dataset\nYou have a non-rectangular (i.e., list) of datasets you’d like to split into individual data.frames, then export these into separate file paths.\n\nThese are all problems I’ve personally encountered that required a variety of iteration tools to tackle. I’ll start with the first example because the principles remain the same (regardless of the size/scope of the problem):"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#lapply",
    "href": "pages/posts/purrr101/purrr101.html#lapply",
    "title": "purrr updates (v1.0.0)",
    "section": "lapply()",
    "text": "lapply()\nSticking with the my_list and tolower() example, the apply function I want is lapply() (pronounced ‘l-apply’), and the l stands for list.\nlapply() has only two required arguments:\n\nX the object we want to iterate over\nFUN being the function we want iterated\n\n\n\nlapply(X = my_list, FUN = tolower)\n\n$words\n[1] \"separate\" \"print\"    \"fit\"      \"many\"     \"match\"   \n\n$sentences\n[1] \"to reach the end he needs much courage.\"       \n[2] \"the soft cushion broke the man's fall.\"        \n[3] \"the cloud moved in a stately way and was gone.\"\n\n$letters\n [1] \"g\" \"n\" \"d\" \"k\" \"z\" \"b\" \"x\" \"j\" \"e\" \"r\""
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#sapply",
    "href": "pages/posts/purrr101/purrr101.html#sapply",
    "title": "purrr updates (v1.0.0)",
    "section": "sapply()",
    "text": "sapply()\nsapply() attempts to simplify the result depending on the X argument. If X is a list containing vectors where every element has the same length (and it’s greater than 1), then sapply() returns a matrix:\n\n\nstr(my_list[1])\n\nList of 1\n $ words: chr [1:5] \"SepaRAtE\" \"PRInt\" \"fIT\" \"manY\" ...\n\nsapply(X = my_list[1], FUN = tolower)\n\n     words     \n[1,] \"separate\"\n[2,] \"print\"   \n[3,] \"fit\"     \n[4,] \"many\"    \n[5,] \"match\"   \n\n\n\nIf a vector is passed to X where every element is length 1, then a vector is returned:\n\n\nstr(my_list[[1]])\n\n chr [1:5] \"SepaRAtE\" \"PRInt\" \"fIT\" \"manY\" \"MaTCH\"\n\nsapply(X = my_list[[1]], FUN = tolower) \n\n  SepaRAtE      PRInt        fIT       manY      MaTCH \n\"separate\"    \"print\"      \"fit\"     \"many\"    \"match\" \n\n\n\nFinally, if X is a list where elements have a length greater than 1, then a list is returned (making it identical to lapply()\n\n\nwaldo::compare(\n  x = sapply(X = my_list, FUN = tolower), \n  y = lapply(X = my_list, FUN = tolower)\n)\n\n✔ No differences\n\n\n\nThis is because sapply is a wrapper around lapply, but has simplify and USE.NAMES set to FALSE (see what happens below when I change them to TRUE)\n\n\nwaldo::compare(\n  \n  x = lapply(X = my_list[[1]], FUN = tolower), \n  \n  y = sapply(X = my_list[[1]], FUN = tolower, \n              simplify = TRUE, USE.NAMES = TRUE)\n  \n  )\n\n`old` is a list\n`new` is a character vector ('separate', 'print', 'fit', 'many', 'match')"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#anonmymous-functions",
    "href": "pages/posts/purrr101/purrr101.html#anonmymous-functions",
    "title": "purrr updates (v1.0.0)",
    "section": "Anonmymous functions",
    "text": "Anonmymous functions\nThe FUN argument can also take anonymous (undefined) functions. For example, if I wanted to access the second elements in my_list, I could pass an anonymous function the FUN (with the index):\n\n\nlapply(X = my_list, FUN = function(x) x[[2]])\n\n$words\n[1] \"PRInt\"\n\n$sentences\n[1] \"the sOft cusHIoN brOKE The MaN's faLL.\"\n\n$letters\n[1] \"N\""
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#vapply",
    "href": "pages/posts/purrr101/purrr101.html#vapply",
    "title": "purrr updates (v1.0.0)",
    "section": "vapply()",
    "text": "vapply()\nFinally vapply() is unique in that it always simplifies the returned output. If we repeat the example above, we see the returned value is character vector:\n\n\nvapply(X = my_list, \n  FUN = function(x) x[[2]], \n  FUN.VALUE = character(1))\n\n                                   words \n                                 \"PRInt\" \n                               sentences \n\"the sOft cusHIoN brOKE The MaN's faLL.\" \n                                 letters \n                                     \"N\" \n\n\n\nThe apply functions get us much further than writing for loops because we can 1) iterate over vectors and lists, 2) control the output objects, and 3) write less code. Unlike generic functions, apply functions are designed to work with specific object types, and return values depending on these objects.\nOne downside of apply functions is they don’t play well with data.frames or tibbles. However, we can control their return values (and manually supply these to tibble::tibble() or data.frame()\n\n\nCodetibble::tibble(\n  words = vapply(X = my_list[[1]][1:3], \n                FUN = `[`, \n                FUN.VALUE = character(1)),\n  sentences = vapply(X = my_list[[2]][1:3], \n                    FUN = `[`, \n                    FUN.VALUE = character(1)),\n  letters = vapply(X = my_list[[3]][1:3], \n                  FUN = `[`, \n                  FUN.VALUE = character(1)))\n\n\n\nAnother downside of the apply functions is they’re not very uniform. Each function has slight variations in their arguments and rules for return values. This is where purrr comes in…"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#do-it-for-one-element",
    "href": "pages/posts/purrr101/purrr101.html#do-it-for-one-element",
    "title": "purrr updates (v1.0.0)",
    "section": "1. Do it for one element",
    "text": "1. Do it for one element\nThe goal with the first step is to get a minimal working example with a single element from the object I want to iterate over (with the function I want to iterate with).\nFor this example, I need to subset my_list for a single element at position [[1]], [[2]], or [[3]] (or using one of the vector names).\nI’ll then pass this element to tolower() and make sure it’s the desired behavior:\n\n# subset an element from the list\n? <- my_list[[?]]\n# apply a function to extracted element\ntolower(?)\n\n\n? <- my_list[[?]] = subset element from the list (my_list)\ntolower(?) = apply operation (i.e., function) to extracted element.\n\n\n\nmy_words <- my_list[['words']]\ntolower(my_words)\n\n[1] \"separate\" \"print\"    \"fit\"      \"many\"     \"match\"   \n\n\n\nNow that I have a working example for one element, in the next step I’ll abstract these parts into the function arguments."
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#turn-it-into-a-recipe",
    "href": "pages/posts/purrr101/purrr101.html#turn-it-into-a-recipe",
    "title": "purrr updates (v1.0.0)",
    "section": "2. Turn it into a recipe",
    "text": "2. Turn it into a recipe\nA standard purrr recipe defines .x (the object) and .f (the function), followed by any additional function arguments.\n\n.x = a list or atomic vector\n.f = the function we want to apply over every element in .x\n\n\n.x = my_list, .f = tolower"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#map-it-across-all-elements",
    "href": "pages/posts/purrr101/purrr101.html#map-it-across-all-elements",
    "title": "purrr updates (v1.0.0)",
    "section": "3. map() it across all elements",
    "text": "3. map() it across all elements\nIn purrr::map(), the .x argument is the object (list or atomic vector) I want to iterate over, and .f is the function (i.e., operation) I want applied to every element of .x\nIf I want to convert the case of every element in my_list to lowercase with tolower() I would use the following standard purrr::map() format:\n\n\npurrr::map(.x = my_list, .f = tolower)\n\n$words\n[1] \"separate\" \"print\"    \"fit\"      \"many\"     \"match\"   \n\n$sentences\n[1] \"to reach the end he needs much courage.\"       \n[2] \"the soft cushion broke the man's fall.\"        \n[3] \"the cloud moved in a stately way and was gone.\"\n\n$letters\n [1] \"g\" \"n\" \"d\" \"k\" \"z\" \"b\" \"x\" \"j\" \"e\" \"r\"\n\n\n\nAnd there you have it! map() is the core function and workhorse of the purrr package. It’s important to note that purrr::map() always returns a list, regardless of the object supplied to .x."
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#map-updates",
    "href": "pages/posts/purrr101/purrr101.html#map-updates",
    "title": "purrr updates (v1.0.0)",
    "section": "\nmap() updates",
    "text": "map() updates\nAs noted above, by default purrr::map() returns a list. If I’d like to return a vector, I can use one of the map_ variations (there’s one for each vector type).\n\n\nBy mapping the is.<type>() functions the elements in mixed_list, I can test which elements in mixed_list return TRUE:\n\n\nmap_lgl(): returns a logical vector\n\n\n\nmixed_list |> purrr::map_lgl(\\(x) is.logical(x))\n\nbooleans integers  doubles  strings    dates \n    TRUE    FALSE    FALSE    FALSE    FALSE \n\n\n\n\n\nmap_int(): returns an integer vector\n\n\n\nmixed_list |> purrr::map_int(\\(x) is.integer(x))\n\nbooleans integers  doubles  strings    dates \n       0        1        0        0        0 \n\n\n\n\n\nmap_dbl(): returns a double vector\n\n\n\nmixed_list |> purrr::map_dbl(\\(x) is.double(x))\n\nbooleans integers  doubles  strings    dates \n       0        0        1        0        1 \n\n\n\n\n\nmap_chr(): returns a character vector\n\n\n\nmixed_list |> purrr::map_chr(\\(x) is.character(x))\n\nWarning: Automatic coercion from logical to character was deprecated in purrr 1.0.0.\nℹ Please use an explicit call to `as.character()` within `map_chr()` instead.\n\n\nbooleans integers  doubles  strings    dates \n \"FALSE\"  \"FALSE\"  \"FALSE\"   \"TRUE\"  \"FALSE\" \n\n\n\n\n\nWhen we test for characters in mixed_list, we see the following warning:\n\n\nWarning: Automatic coercion from logical to character was deprecated in purrr 1.0.0. Please use an explicit call to as.character() within map_chr() instead\n\n\nAs we can see from the output above, the logical return values from is.character() are coerced to characters (this behavior is now deprecated).\nmap_vec()\n\nHowever, the previous purrr::map_raw() function has been replaced with purrr::map_vec(), which “simplifies to the common type of the output.” I’ll demonstrate below with the characters in mixed_list:\n\n\nmixed_list |> purrr::map_vec(\\(x) is.character(x))\n\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE     TRUE    FALSE \n\n\n\nNotice the difference in output? The results are the same as above, but output is not commented (##). The same is true when I test the dates in mixed_list using lubridate::is.Date():\n\n\nmixed_list |> purrr::map_vec(\\(x) lubridate::is.Date(x))\n\nbooleans integers  doubles  strings    dates \n   FALSE    FALSE    FALSE    FALSE     TRUE"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#anonymous-functions",
    "href": "pages/posts/purrr101/purrr101.html#anonymous-functions",
    "title": "purrr updates (v1.0.0)",
    "section": "Anonymous functions",
    "text": "Anonymous functions\nR introduced the shorthand anonymous function syntax in version 4.1.0:\n\n“\\(x) x + 1 is parsed as function(x) x + 1.”\n\nBelow is a comparison of an anonymous (unnamed) function and the updated shorthand syntax:\n\n\nStandard anonymous function\n\n\n(function(x) tolower(x))(\"pIrAtES Ship\")\n\n[1] \"pirates ship\"\n\n\n\n\n\nThe updated anonymous syntax is below:\n\n\n(\\(x) tolower(x))(\"pIrAtES Ship\")\n\n[1] \"pirates ship\"\n\n\n\n\n\nWriting the code above using an anonymous function would look like this:\n\n\nmy_list |> purrr::map(\\(x) tolower(x))\n\n$words\n[1] \"separate\" \"print\"    \"fit\"      \"many\"     \"match\"   \n\n$sentences\n[1] \"to reach the end he needs much courage.\"       \n[2] \"the soft cushion broke the man's fall.\"        \n[3] \"the cloud moved in a stately way and was gone.\"\n\n$letters\n [1] \"g\" \"n\" \"d\" \"k\" \"z\" \"b\" \"x\" \"j\" \"e\" \"r\"\n\n\n\nAnonymous functions make it easier to understand which arguments belong to which function and will tend to yield better error messages.\nI’ll confirm the outputs from both methods are identical using waldo::compare():\n\n\nwaldo::compare(\n  x = purrr::map(.x = my_list, .f = tolower), \n  y = my_list |> purrr::map(\\(x) tolower(x)))\n\n✔ No differences\n\n\n\n\n\n\n\n\n\nThe formula (~ .x + 1)\n\n\n\n\n\nPrior to purrr v1.0.0, I could also use the formula syntax, but now it’s “only recommended if you require backward compatibility with older versions of R.” I’ll cover the formula syntax briefly because you’re likely to encounter it.\n\n\nThe formula syntax is typically used with pipes, so the contents of purrr::map() become the right-hand side of the formula, with the function we want to iterate (<FUNCTION>) and a placeholder (.x) in the appropriate argument.\n\n\n<OBJECT> |> purrr::map(~ <FUNCTION>(.x))\n\n\nFor the example above, my_list is ‘piped’ to purrr::map(), where the formula maps the tolower() function (using the .x placeholder).\n\n\n# written as normal expression\n my_list |> purrr::map(~ tolower(.x))\n\n\nJenny Bryan offers a great description on her purrr tutorial,\n\n“[formula syntax] should start with the ~ symbol and then look like a typical top-level expression, as you might write in a script. Use .x to refer to the input, i.e. an individual element of the primary vector or list.”\n\nI can double-check to see that the output from two variations are identical using waldo::compare().\n\n\n\nwaldo::compare(\n  x = my_list |> purrr::map(\\(x) tolower(x)), \n  y = my_list |> purrr::map(~ tolower(.x)))\n\n✔ No differences"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#downloading-files",
    "href": "pages/posts/purrr101/purrr101.html#downloading-files",
    "title": "purrr updates (v1.0.0)",
    "section": "Downloading files",
    "text": "Downloading files\n\nYou’d like to download a collection of files from separate URLS\n\nI have a collection of 30 .csv files from Doing Data Science by Cathy O’Neil and Rachel Schutt (O’Reilly Media) in a GitHub repo. Let’s assume I want to download all of these files into my RStudio session (and not clone the repo).\nI’ll navigate to the raw url for the first data file (nyt1.csv), then paste this into a character vector:\n\n\nnyt_url <- \"https://raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n\n\nKnowing that all of the files on GitHub with have a similar root or dir, I can use nyt_url to generate urls for each of the 31 files.\n\nFirst I get the folder of the files on GitHub with fs::path_dir()\n\nI create a vector with the 31 file names\n\nI combine the directory portion of the url with file name in nyt_file_urls\n\n\n\n\n# create file urls \nnyt_dir_url <- fs::path_dir(nyt_url)\nnyt_dir_url\n\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main\"\n\n# add numbers to name\nnyt_file_nms <- paste0(\"nyt\", 1:31, \".csv\")\n# combine\nnyt_file_urls <- paste(nyt_dir_url, nyt_file_nms, sep = \"/\")\nhead(nyt_file_urls)\n\n[1] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv\"\n[2] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt2.csv\"\n[3] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt3.csv\"\n[4] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt4.csv\"\n[5] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt5.csv\"\n[6] \"https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt6.csv\"\n\n\n\nI’ll need another vector of destination file names on my local machine, which I can do by combining the file names (nyt_file_nms) with the local destination folder (dds-nyt).\n\n\nnyt_local_pths <- paste(\"dds-nyt\", nyt_file_nms, sep = \"/\")\nhead(nyt_local_pths)\n\n[1] \"dds-nyt/nyt1.csv\" \"dds-nyt/nyt2.csv\" \"dds-nyt/nyt3.csv\" \"dds-nyt/nyt4.csv\"\n[5] \"dds-nyt/nyt5.csv\" \"dds-nyt/nyt6.csv\"\n\n\n\nAfter creating the destination folder, I’ll use the download.file() function to test downloading a single .csv files into my local folder (dds-nyt/). download.file() has a progress bar which tells me if the file downloaded successfully.\n\n# do it for one\nfs::dir_create(\"dds-nyt\")\ndownload.file(url = nyt_file_urls[1], destfile = nyt_local_pths[1])\ntrying URL 'https:/raw.githubusercontent.com/mjfrigaard/dds-data/main/nyt1.csv'\nContent type 'text/plain; charset=utf-8' length 4920381 bytes (4.7 MB)\n==================================================\ndownloaded 4.7 MB\n\nThe function I’m using to download the files takes two inputs (url and destfile), which changes the recipe a bit, because I need a purrr function with the following:\n\n.x the input vector of existing url paths\n.y the output vector of destination file paths\nAdditional arguments passed from download.file() (like quiet = TRUE)\n\nIn this case, I don’t need purrr to return value–I just need the purrr function to iterate over the items and write them to the new location.\nwalk() is ideal for this circumstance:\n\n“walk() returns the input .x (invisibly)” and “The return value of .f() is ignored”\n\nWhat does ‘return .x invisibly’ and ‘the side-effect of .f’\nReturn invisibly\nThe previous purrr functions I covered varied in the kinds of values they returned (lists vs. vectors), but for some operations I won’t need a return value. If I’m ever curious about whether I should be using map() or walk(), I’ll ask myself, “would it make sense to assign the output from this function to an object?”\nIf the answer is no, then I probably need to be thinking walk() instead of map()\nSide-effects\nIn the help documentation walk()’s description states, “calls .f for its side-effect”\n(i.e., there’s nothing to assign the output from that function to).\nDownloading files performs\nI’ll use walk2() below and add .progress = TRUE to view the purrr progress bar (and quiet = TRUE to silence the download.file() progress bar).\n\n\nwalk2(.x = nyt_file_urls, .y = nyt_local_pths, .f =  download.file, \n  .progress = TRUE, quiet = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nI can confirm the download using fs::dir_tree()\n\n\nfs::dir_tree(\"dds-nyt\")\n\ndds-nyt\n├── nyt1.csv\n├── nyt10.csv\n├── nyt11.csv\n├── nyt12.csv\n├── nyt13.csv\n├── nyt14.csv\n├── nyt15.csv\n├── nyt16.csv\n├── nyt17.csv\n├── nyt18.csv\n├── nyt19.csv\n├── nyt2.csv\n├── nyt20.csv\n├── nyt21.csv\n├── nyt22.csv\n├── nyt23.csv\n├── nyt24.csv\n├── nyt25.csv\n├── nyt26.csv\n├── nyt27.csv\n├── nyt28.csv\n├── nyt29.csv\n├── nyt3.csv\n├── nyt30.csv\n├── nyt31.csv\n├── nyt4.csv\n├── nyt5.csv\n├── nyt6.csv\n├── nyt7.csv\n├── nyt8.csv\n└── nyt9.csv"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#copying-a-directory-of-files",
    "href": "pages/posts/purrr101/purrr101.html#copying-a-directory-of-files",
    "title": "purrr updates (v1.0.0)",
    "section": "Copying a directory of files",
    "text": "Copying a directory of files\n\nYou have a folder of files you’d like to rename or copy to a new directory\n\nThe collection of 31 .csv files from Doing Data Science by Cathy O’Neil and Rachel Schutt (O’Reilly Media) are now in the dds-nyt/ folder.\nAs with any project, I don’t want to alter the raw data, so I’m going to copy these files into dds-nyt-raw/ and dds-nyt-processed/. I also want the processed file names to have a date stamp prefix.\n\n\nfile_pths <- list.files(\"dds-nyt\", full.names = TRUE, pattern = \".csv$\")\nhead(file_pths)\n\n[1] \"dds-nyt/nyt1.csv\"  \"dds-nyt/nyt10.csv\" \"dds-nyt/nyt11.csv\"\n[4] \"dds-nyt/nyt12.csv\" \"dds-nyt/nyt13.csv\" \"dds-nyt/nyt14.csv\"\n\n\n\nI’ll start with the raw data folder. I need to create a vector of the new raw file paths and names: raw_file_pths (the raw data paths will have the original file names)\n\n\n# do it for one\ngsub(pattern = \"^dds-nyt\",\n  replacement = \"dds-nyt/raw\",\n  x = file_pths[1])\n## [1] \"dds-nyt/raw/nyt1.csv\"\n\n# write the recipe\nfile_pths |> purrr::map_chr(\\(x) gsub(x, \n                                pattern = \"^dds-nyt\", \n                                replacement = \"dds-nyt/raw\")) |> head()\n## [1] \"dds-nyt/raw/nyt1.csv\"  \"dds-nyt/raw/nyt10.csv\" \"dds-nyt/raw/nyt11.csv\"\n## [4] \"dds-nyt/raw/nyt12.csv\" \"dds-nyt/raw/nyt13.csv\" \"dds-nyt/raw/nyt14.csv\"\n\n# map it across all\nraw_file_pths <- file_pths |> \n                  purrr::map_chr(\\(x) gsub(x, \n                                        pattern = \"^dds-nyt\", \n                                        replacement = \"dds-nyt/raw\"))\n\n\nBefore copying the files, I need to create the destination folder for the raw data (dds-nyt/raw). Then, I’ll make sure I can copy the first element from file_pths into the path in the first element of raw_file_pths:\n\n\nfs::dir_create(\"dds-nyt/raw\")\n# do it for one\nfs::file_copy(\n  path = file_pths[1], \n  new_path = raw_file_pths[1], \n  overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n\ndds-nyt/raw\n└── nyt1.csv\n\n\n\n\n\nwalk2(.x = file_pths, .y = raw_file_pths, .f = fs::file_copy, \n      .progress = TRUE, overwrite = TRUE)\nfs::dir_tree(\"dds-nyt/raw\", type = \"any\")\n\ndds-nyt/raw\n├── nyt1.csv\n├── nyt10.csv\n├── nyt11.csv\n├── nyt12.csv\n├── nyt13.csv\n├── nyt14.csv\n├── nyt15.csv\n├── nyt16.csv\n├── nyt17.csv\n├── nyt18.csv\n├── nyt19.csv\n├── nyt2.csv\n├── nyt20.csv\n├── nyt21.csv\n├── nyt22.csv\n├── nyt23.csv\n├── nyt24.csv\n├── nyt25.csv\n├── nyt26.csv\n├── nyt27.csv\n├── nyt28.csv\n├── nyt29.csv\n├── nyt3.csv\n├── nyt30.csv\n├── nyt31.csv\n├── nyt4.csv\n├── nyt5.csv\n├── nyt6.csv\n├── nyt7.csv\n├── nyt8.csv\n└── nyt9.csv\n\n\n\nNow that I’ve copied the files into their respective folders, I’ll need to remove the files from their original location in the parent dds-nyt folder.\nFortunately, I have a vector of these files in file_pths, and I can test removal with fs::file_delete():\n\n\nfs::file_delete(file_pths[1])\n\n\nGreat! Now that I know this will work, I’ll use walk() because I want .x returned invisibly and the side-effect of .f\n\n\nwalk(.x = file_pths, .f = fs::file_delete)\n\nError in `map()`:\nℹ In index: 1.\nCaused by error:\n! [ENOENT] Failed to remove 'dds-nyt/nyt1.csv': no such file or directory\n\n\n\nWhy does this throw an error? Well–I’ve just deleted the first element in file_pths, so when fs::file_delete() when looking for that file, it found nothing and returned an error. I can protect against this by supplying the output from list.files() directly to walk2(), but include a pattern so it only matches the .csv files.\n\n\nwalk(# list CURRENT files \n    .x = list.files(\n      path = \"dds-nyt\",\n      pattern = \".csv$\",\n      full.names = TRUE),\n    # map function\n    .f = fs::file_delete)\n\n\nAnd confirm the new folder contents and structure\n\n\nfs::dir_tree(\"dds-nyt\", type = \"any\", recurse = TRUE)\n\ndds-nyt\n└── raw\n    ├── nyt1.csv\n    ├── nyt10.csv\n    ├── nyt11.csv\n    ├── nyt12.csv\n    ├── nyt13.csv\n    ├── nyt14.csv\n    ├── nyt15.csv\n    ├── nyt16.csv\n    ├── nyt17.csv\n    ├── nyt18.csv\n    ├── nyt19.csv\n    ├── nyt2.csv\n    ├── nyt20.csv\n    ├── nyt21.csv\n    ├── nyt22.csv\n    ├── nyt23.csv\n    ├── nyt24.csv\n    ├── nyt25.csv\n    ├── nyt26.csv\n    ├── nyt27.csv\n    ├── nyt28.csv\n    ├── nyt29.csv\n    ├── nyt3.csv\n    ├── nyt30.csv\n    ├── nyt31.csv\n    ├── nyt4.csv\n    ├── nyt5.csv\n    ├── nyt6.csv\n    ├── nyt7.csv\n    ├── nyt8.csv\n    └── nyt9.csv"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#import-multiple-datasets",
    "href": "pages/posts/purrr101/purrr101.html#import-multiple-datasets",
    "title": "purrr updates (v1.0.0)",
    "section": "Import multiple datasets",
    "text": "Import multiple datasets\n\nYou have several days of data, and each day is contained in separate file. You’d like to read these data into R, and combine them into a single dataset\n\nNow that I have separate raw and processed folders, I can import the NYT data into R. Below I’ve imported a single file from the raw data folder to examine it’s contents:\n\n\nnyt1 <- vroom::vroom(\n  \"dds-nyt/raw/nyt1.csv\", \n  delim = \",\", \n  show_col_types = FALSE)\nstr(nyt1)\n\nspc_tbl_ [458,441 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n $ Gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n $ Impressions: num [1:458441] 3 3 3 3 11 11 7 5 3 4 ...\n $ Clicks     : num [1:458441] 0 0 0 0 0 1 1 0 0 0 ...\n $ Signed_In  : num [1:458441] 1 1 1 1 1 1 0 1 1 1 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Age = col_double(),\n  ..   Gender = col_double(),\n  ..   Impressions = col_double(),\n  ..   Clicks = col_double(),\n  ..   Signed_In = col_double(),\n  ..   .delim = \",\"\n  .. )\n - attr(*, \"problems\")=<externalptr> \n\n\n\nEach nyt file contains daily ads shown and clicks recorded on the New York Times home page. The rows represent users, and the variables are: Age, Gender (0 = female, 1 = male), Impressions (number impressions), Clicks (number clicks), and a binary indicator for signed in or not Signed_in.\nI’ll add some hypothetical wrangling steps to make this example more realistic.\n\nCreate age_group, an ordered factor which contains six levels of Age (“<18”, “18-24”, “25-34”, “35-44”, “45-54”, “55-64”, and “65+”)\nCreate ctr_rate or click-through rate, calculated as the number of clicks / the number of impressions. Round it to 3 digits.\nCreate female, a factor version of Gender, where when Gender = 0, then female = \"yes\", and when Gender = 1, then female = \"no\"\nCreate signed_in, a factor variable with levels \"no\" and \"yes\" from the Signed_In = 0 and 1\n\nI’ve bundled all of these steps into a function (nyt_data_processing()) that I can pass each dataset through:\n\n\nCodenyt_data_processing <- function(nyt_csv) {\n  orig_nms <- c(\"Age\", \"Gender\", \"Impressions\", \"Clicks\", \"Signed_In\")\n  nyt_nms <- names(nyt_csv)\n  if (isFALSE(identical(x = orig_nms, y = nyt_nms))) {\n    cli::cli_abort(\"these data don't have the correct columns!\")\n  } else {\n    nyt_proc <- nyt_csv |> \n      dplyr::mutate(\n        # create age_group variable\n          age_group = case_when( \n              Age < 18 ~ \"<18\",\n              Age >= 18 & Age < 25 ~ \"18-24\",\n              Age >= 25 & Age < 35 ~ \"25-34\",\n              Age >= 35 & Age < 45 ~ \"35-44\",\n              Age >= 45 & Age < 55 ~ \"45-54\",\n              Age >= 55 & Age < 65 ~ \"55-64\",\n              Age >= 65 ~ \"65+\"), \n        # factor age_group (ordered)\n          age_group = factor(age_group, \n            levels = c(\"<18\", \"18-24\", \"25-34\",\n              \"35-44\", \"45-54\", \"55-64\", \"65+\"), \n            ordered = TRUE),\n        # create CTR variable\n          ctr_rate = round(x = Clicks/Impressions, digits = 3),\n        # create new Female variable\n          female = case_when( \n              Gender == 0 ~ \"yes\", \n              Gender == 1 ~ \"no\",\n              TRUE ~ NA_character_),\n        # factor female (un-ordered)\n          female = factor(female, \n            levels = c(\"no\", \"yes\")),\n          signed_in = case_when( \n              Signed_In == 0 ~ \"no\", \n              Signed_In == 1 ~ \"yes\",\n              TRUE ~ NA_character_),\n        # factor signed_in (un-ordered)\n          signed_in = factor(signed_in, \n            levels = c(\"no\", \"yes\"))) |> \n    # remove Signed_in\n    dplyr::select(-c(Signed_In)) |> \n    # format columns\n    janitor::clean_names() \n  \n  }\n  return(nyt_proc)\n}\n\n\n\nI’ll do some quick checks to make sure it only works with the raw data columns:\n\n\nnyt1_proc <- nyt_data_processing(nyt1)\nstr(nyt1_proc)\n\nspc_tbl_ [458,441 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n $ gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n $ impressions: num [1:458441] 3 3 3 3 11 11 7 5 3 4 ...\n $ clicks     : num [1:458441] 0 0 0 0 0 1 1 0 0 0 ...\n $ age_group  : Ord.factor w/ 7 levels \"<18\"<\"18-24\"<..: 4 7 3 5 5 5 1 5 1 5 ...\n $ ctr_rate   : num [1:458441] 0 0 0 0 0 0.091 0.143 0 0 0 ...\n $ female     : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 1 1 2 2 2 2 2 ...\n $ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 2 2 2 2 2 1 2 2 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Age = col_double(),\n  ..   Gender = col_double(),\n  ..   Impressions = col_double(),\n  ..   Clicks = col_double(),\n  ..   Signed_In = col_double(),\n  ..   .delim = \",\"\n  .. )\n - attr(*, \"problems\")=<externalptr> \n\n\n\n\n\nnyt_data_processing(nyt1_proc)\n\nError in `nyt_data_processing()`:\n! these data don't have the correct columns!\n\n\n\nNow I’m ready to write the import step. First I’ll store the raw file paths in raw_data_pths, then take a subset to test with (test_raw_data_pths).\n\n\nraw_data_pths <- list.files(path = \"dds-nyt/raw\", pattern = \".csv$\", full.names = TRUE)\ntest_raw_data_pths <- raw_data_pths[1:2]\ntest_raw_data_pths\n\n[1] \"dds-nyt/raw/nyt1.csv\"  \"dds-nyt/raw/nyt10.csv\"\n\n\n\nWe’ll test purrr::map() and vroom::vroom() to import the .csv files in test_raw_data_pths into a list. I also add str(list.len = 2) to limit the output.\n\n\ntest_raw_data_pths |> \n  # import\n  purrr::map(\n    vroom::vroom, \n        delim = \",\", show_col_types = FALSE) |> \n  str(list.len = 2)\n\nList of 2\n $ : spc_tbl_ [458,441 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n  ..$ Gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n $ : spc_tbl_ [452,766 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n  ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n\n\n\nThis returns a list, but you may have noticed I don’t have a great way for keeping track of the data files in the list–this is where purrr::set_names() comes in handy.\npurrr::set_names() works a lot like names(), but purrr::set_names() will automatically set the names of x to as.character(x) is no names are provided to nm. See below:\n\n\ntest_raw_data_pths |> purrr::set_names()\n\n   dds-nyt/raw/nyt1.csv   dds-nyt/raw/nyt10.csv \n \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt10.csv\" \n\n\n\nNow the imported file will have their file path and name associated with the dataset:\n\n\ntest_raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import  \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  str(list.len = 2)\n\nList of 2\n $ dds-nyt/raw/nyt1.csv : spc_tbl_ [458,441 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n  ..$ Gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ Age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n  ..$ Gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n\n\n\nTo add the wrangling function, I can pipe in another call to purrr::map(), and add the custom wrangling function.\n\n\ntest_raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  str(list.len = 2)\n\nList of 2\n $ dds-nyt/raw/nyt1.csv : spc_tbl_ [458,441 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ age        : num [1:458441] 36 73 30 49 47 47 0 46 16 52 ...\n  ..$ gender     : num [1:458441] 0 1 0 1 1 0 0 0 0 0 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n $ dds-nyt/raw/nyt10.csv: spc_tbl_ [452,766 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n  ..$ age        : num [1:452766] 59 0 19 44 30 33 41 41 0 23 ...\n  ..$ gender     : num [1:452766] 1 0 0 1 1 1 0 0 0 1 ...\n  .. [list output truncated]\n  ..- attr(*, \"spec\")=\n  .. .. cols(\n  .. ..   Age = col_double(),\n  .. ..   Gender = col_double(),\n  .. ..   Impressions = col_double(),\n  .. ..   Clicks = col_double(),\n  .. ..   Signed_In = col_double(),\n  .. ..   .delim = \",\"\n  .. .. )\n  ..- attr(*, \"problems\")=<externalptr> \n\n\n\nFor the final step, I’ll bind all the data into a data.frame with the updated purrr::list_rbind() function (set names_to = \"id\").\n\n\ntest_raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") |> \n  str()\n\ntibble [911,207 × 9] (S3: tbl_df/tbl/data.frame)\n $ id         : chr [1:911207] \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt1.csv\" \"dds-nyt/raw/nyt1.csv\" ...\n $ age        : num [1:911207] 36 73 30 49 47 47 0 46 16 52 ...\n $ gender     : num [1:911207] 0 1 0 1 1 0 0 0 0 0 ...\n $ impressions: num [1:911207] 3 3 3 3 11 11 7 5 3 4 ...\n $ clicks     : num [1:911207] 0 0 0 0 0 1 1 0 0 0 ...\n $ age_group  : Ord.factor w/ 7 levels \"<18\"<\"18-24\"<..: 4 7 3 5 5 5 1 5 1 5 ...\n $ ctr_rate   : num [1:911207] 0 0 0 0 0 0.091 0.143 0 0 0 ...\n $ female     : Factor w/ 2 levels \"no\",\"yes\": 2 1 2 1 1 2 2 2 2 2 ...\n $ signed_in  : Factor w/ 2 levels \"no\",\"yes\": 2 2 2 2 2 2 1 2 2 2 ...\n\n\n\nNow that we have a complete recipe, so all I do is swap out test vector with the full list of file paths and store the result in nyt_data_proc. I can also confirm all files were imported and wrangled by checking the count() of id.\n\n\nnyt_data_proc <- raw_data_pths |> \n  # names \n  purrr::set_names() |> \n  # import \n    purrr::map(\n      vroom::vroom, \n          delim = \",\", show_col_types = FALSE) |> \n  # wrangle \n  purrr::map(.f = nyt_data_processing) |> \n  # bind\n  purrr::list_rbind(names_to = \"id\") \n\n\ndplyr::glimpse(nyt_data_proc)\n\nRows: 14,905,865\nColumns: 9\n$ id          <chr> \"dds-nyt/raw/nyt1.csv\", \"dds-nyt/raw/nyt1.csv\", \"dds-nyt/r…\n$ age         <dbl> 36, 73, 30, 49, 47, 47, 0, 46, 16, 52, 0, 21, 0, 57, 31, 0…\n$ gender      <dbl> 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0…\n$ impressions <dbl> 3, 3, 3, 3, 11, 11, 7, 5, 3, 4, 8, 3, 4, 6, 5, 6, 3, 5, 4,…\n$ clicks      <dbl> 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ age_group   <ord> 35-44, 65+, 25-34, 45-54, 45-54, 45-54, <18, 45-54, <18, 4…\n$ ctr_rate    <dbl> 0.000, 0.000, 0.000, 0.000, 0.000, 0.091, 0.143, 0.000, 0.…\n$ female      <fct> yes, no, yes, no, no, yes, yes, yes, yes, yes, yes, yes, y…\n$ signed_in   <fct> yes, yes, yes, yes, yes, yes, no, yes, yes, yes, no, yes, …\n\n\n\nnyt_data_proc |> \n  dplyr::count(id)\n\n# A tibble: 31 × 2\n   id                         n\n   <chr>                  <int>\n 1 dds-nyt/raw/nyt1.csv  458441\n 2 dds-nyt/raw/nyt10.csv 452766\n 3 dds-nyt/raw/nyt11.csv 478066\n 4 dds-nyt/raw/nyt12.csv 396308\n 5 dds-nyt/raw/nyt13.csv 786044\n 6 dds-nyt/raw/nyt14.csv 440338\n 7 dds-nyt/raw/nyt15.csv 437567\n 8 dds-nyt/raw/nyt16.csv 448917\n 9 dds-nyt/raw/nyt17.csv 445228\n10 dds-nyt/raw/nyt18.csv 451763\n# ℹ 21 more rows"
  },
  {
    "objectID": "pages/posts/purrr101/purrr101.html#export-multiple-datasets",
    "href": "pages/posts/purrr101/purrr101.html#export-multiple-datasets",
    "title": "purrr updates (v1.0.0)",
    "section": "Export multiple datasets",
    "text": "Export multiple datasets\n\nYou have a non-rectangular (i.e., list) of datasets you’d like to split into individual data.frames, then export these into separate file paths\n\nNow I have a processed dataset, and I want to export this into a dds-nyt/processed/ folder.\nCreating a vector of processed data file paths is a little more involved because I wanted to add a date prefix to the exported files, and because I want to add this path as a variable in the nyt_data_proc dataset.\nI do this below in proc_file_pth:\n\n\n# create file names \nnyt_data_proc <- dplyr::mutate(.data = nyt_data_proc,\n        file_nm = tools::file_path_sans_ext(base::basename(id)),\n        proc_file_pth = paste0(\"dds-nyt/processed/\", \n                        as.character(Sys.Date()), \"-\", \n                        file_nm))\nnyt_data_proc |> dplyr::count(proc_file_pth)\n## # A tibble: 31 × 2\n##    proc_file_pth                           n\n##    <chr>                               <int>\n##  1 dds-nyt/processed/2023-04-08-nyt1  458441\n##  2 dds-nyt/processed/2023-04-08-nyt10 452766\n##  3 dds-nyt/processed/2023-04-08-nyt11 478066\n##  4 dds-nyt/processed/2023-04-08-nyt12 396308\n##  5 dds-nyt/processed/2023-04-08-nyt13 786044\n##  6 dds-nyt/processed/2023-04-08-nyt14 440338\n##  7 dds-nyt/processed/2023-04-08-nyt15 437567\n##  8 dds-nyt/processed/2023-04-08-nyt16 448917\n##  9 dds-nyt/processed/2023-04-08-nyt17 445228\n## 10 dds-nyt/processed/2023-04-08-nyt18 451763\n## # ℹ 21 more rows\n\n\nNote that I don’t include the file extension in proc_file_pth, because I might want to use different file types when I’m exporting.\nI’ll cover two methods for exporting datasets from a list. I’ll demo these on a sample from nyt_data_proc:\n\n\nsamp_nyt_proc <- nyt_data_proc |> \n  dplyr::slice_sample(prop = 0.001, replace = FALSE)\nglimpse(samp_nyt_proc)\n## Rows: 14,905\n## Columns: 11\n## $ id            <chr> \"dds-nyt/raw/nyt20.csv\", \"dds-nyt/raw/nyt15.csv\", \"dds-n…\n## $ age           <dbl> 16, 66, 0, 0, 31, 22, 0, 22, 0, 53, 35, 0, 78, 44, 41, 5…\n## $ gender        <dbl> 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ impressions   <dbl> 2, 8, 6, 4, 5, 3, 8, 3, 3, 6, 6, 3, 7, 7, 6, 5, 4, 1, 2,…\n## $ clicks        <dbl> 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ age_group     <ord> <18, 65+, <18, <18, 25-34, 18-24, <18, 18-24, <18, 45-54…\n## $ ctr_rate      <dbl> 0.000, 0.250, 0.167, 0.000, 0.000, 0.000, 0.000, 0.000, …\n## $ female        <fct> no, no, yes, yes, no, no, yes, no, yes, no, yes, yes, ye…\n## $ signed_in     <fct> yes, yes, no, no, yes, yes, no, yes, no, yes, yes, no, y…\n## $ file_nm       <chr> \"nyt20\", \"nyt15\", \"nyt24\", \"nyt11\", \"nyt12\", \"nyt17\", \"n…\n## $ proc_file_pth <chr> \"dds-nyt/processed/2023-04-08-nyt20\", \"dds-nyt/processed…\n\n\nIn this first method, I’ll use the base::split function to split samp_nyt_proc by the proc_file_pth variable into a list of data frames. I’ll also use utils::head(), purrr::walk(), and dplyr::glimpse() to view the output.\n\n\nsplit(x = samp_nyt_proc, f = samp_nyt_proc$proc_file_pth) |>\n  utils::head(3) |> \n  purrr::walk(.f = glimpse)\n## Rows: 472\n## Columns: 11\n## $ id            <chr> \"dds-nyt/raw/nyt1.csv\", \"dds-nyt/raw/nyt1.csv\", \"dds-nyt…\n## $ age           <dbl> 52, 29, 37, 54, 49, 0, 0, 62, 61, 0, 40, 0, 24, 56, 0, 2…\n## $ gender        <dbl> 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1,…\n## $ impressions   <dbl> 5, 2, 5, 4, 7, 7, 4, 6, 3, 4, 6, 7, 7, 6, 5, 7, 4, 4, 6,…\n## $ clicks        <dbl> 0, 0, 0, 0, 0, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,…\n## $ age_group     <ord> 45-54, 25-34, 35-44, 45-54, 45-54, <18, <18, 55-64, 55-6…\n## $ ctr_rate      <dbl> 0.000, 0.000, 0.000, 0.000, 0.000, 0.286, 0.250, 0.000, …\n## $ female        <fct> yes, yes, no, yes, yes, yes, yes, yes, yes, yes, yes, ye…\n## $ signed_in     <fct> yes, yes, yes, yes, yes, no, no, yes, yes, no, yes, no, …\n## $ file_nm       <chr> \"nyt1\", \"nyt1\", \"nyt1\", \"nyt1\", \"nyt1\", \"nyt1\", \"nyt1\", …\n## $ proc_file_pth <chr> \"dds-nyt/processed/2023-04-08-nyt1\", \"dds-nyt/processed/…\n## Rows: 419\n## Columns: 11\n## $ id            <chr> \"dds-nyt/raw/nyt10.csv\", \"dds-nyt/raw/nyt10.csv\", \"dds-n…\n## $ age           <dbl> 12, 29, 0, 39, 14, 0, 0, 0, 30, 0, 0, 51, 68, 51, 59, 0,…\n## $ gender        <dbl> 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1,…\n## $ impressions   <dbl> 4, 4, 5, 7, 8, 5, 2, 0, 6, 3, 2, 7, 9, 3, 6, 5, 9, 8, 4,…\n## $ clicks        <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ age_group     <ord> <18, 25-34, <18, 35-44, <18, <18, <18, <18, 25-34, <18, …\n## $ ctr_rate      <dbl> 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, NaN, 0.…\n## $ female        <fct> no, yes, yes, yes, no, yes, yes, yes, no, yes, yes, no, …\n## $ signed_in     <fct> yes, yes, no, yes, yes, no, no, no, yes, no, no, yes, ye…\n## $ file_nm       <chr> \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"nyt10\", \"n…\n## $ proc_file_pth <chr> \"dds-nyt/processed/2023-04-08-nyt10\", \"dds-nyt/processed…\n## Rows: 433\n## Columns: 11\n## $ id            <chr> \"dds-nyt/raw/nyt11.csv\", \"dds-nyt/raw/nyt11.csv\", \"dds-n…\n## $ age           <dbl> 0, 42, 59, 0, 36, 81, 51, 42, 50, 20, 0, 0, 38, 41, 27, …\n## $ gender        <dbl> 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0,…\n## $ impressions   <dbl> 4, 8, 2, 2, 4, 3, 3, 6, 6, 4, 5, 2, 5, 2, 7, 3, 4, 2, 3,…\n## $ clicks        <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ age_group     <ord> <18, 35-44, 55-64, <18, 35-44, 65+, 45-54, 35-44, 45-54,…\n## $ ctr_rate      <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ female        <fct> yes, no, no, yes, yes, yes, no, yes, yes, no, yes, yes, …\n## $ signed_in     <fct> no, yes, yes, no, yes, yes, yes, yes, yes, yes, no, no, …\n## $ file_nm       <chr> \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"nyt11\", \"n…\n## $ proc_file_pth <chr> \"dds-nyt/processed/2023-04-08-nyt11\", \"dds-nyt/processed…\n\n\nI can see this is returning a list of data frames as expected, so now I need to pass this list into purrr::walk2() so I can iterate vroom::vroom_write() over the processed data paths in proc_file_pth.\n\nFirst I create the processed data folder (dds-nyt/processed/)\n\nSecond, I create the .x argument, which is the split list of samp_nyt_proc by proc_file_pth\n\nThird, I get the unique processed data paths in the proc_file_pth column and store it as a vector for the .y\n\n\n\n\nfs::dir_create(\"dds-nyt/processed/\")\n# split samp_nyt_proc (.x)\nby_proc_pths <- samp_nyt_proc |> \n  split(samp_nyt_proc$proc_file_pth)\n# get unique processed paths in samp_nyt_proc (.y) with .csv extension\nproc_pths <- paste0(unique(samp_nyt_proc$proc_file_pth), \".csv\")\n# iterate with .f\nwalk2(.x = by_proc_pths, .y = proc_pths, .f = vroom::vroom_write, delim = \",\")\n# or as an anonymous function \nsamp_nyt_proc |> \n  split(samp_nyt_proc$proc_file_pth) |> \n  walk2(.y = proc_pths, \n    \\(x, y)\n    vroom::vroom_write(x = x, \n      file = y,  delim = \",\"))\n\n\nI’ll want to perform a sanity check on this output with the first exported item in dds-nyt/processed and check it against the nyt1_proc data to evaluate the differences.\n\n\nnyt1_proc_check_01 <- vroom::vroom(\n  list.files(path = \"dds-nyt/processed\", \n                    pattern = \".csv$\", \n        full.names = TRUE)[[1]], # grab the first file\n   delim = \",\", show_col_types = FALSE\n  )\nglimpse(nyt1_proc_check_01)\n## Rows: 777\n## Columns: 11\n## $ id            <chr> \"dds-nyt/raw/nyt20.csv\", \"dds-nyt/raw/nyt20.csv\", \"dds-n…\n## $ age           <dbl> 16, 35, 35, 15, 0, 56, 21, 0, 37, 0, 38, 0, 0, 0, 44, 18…\n## $ gender        <dbl> 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1,…\n## $ impressions   <dbl> 2, 6, 7, 2, 2, 4, 3, 8, 3, 1, 5, 9, 8, 6, 4, 4, 8, 2, 4,…\n## $ clicks        <dbl> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ age_group     <chr> \"<18\", \"35-44\", \"35-44\", \"<18\", \"<18\", \"55-64\", \"18-24\",…\n## $ ctr_rate      <dbl> 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.125, …\n## $ female        <chr> \"no\", \"yes\", \"yes\", \"yes\", \"yes\", \"yes\", \"yes\", \"yes\", \"…\n## $ signed_in     <chr> \"yes\", \"yes\", \"yes\", \"yes\", \"no\", \"yes\", \"yes\", \"no\", \"y…\n## $ file_nm       <chr> \"nyt20\", \"nyt20\", \"nyt20\", \"nyt20\", \"nyt20\", \"nyt20\", \"n…\n## $ proc_file_pth <chr> \"dds-nyt/processed/2023-04-08-nyt20\", \"dds-nyt/processed…\nglimpse(nyt1_proc)\n## Rows: 458,441\n## Columns: 8\n## $ age         <dbl> 36, 73, 30, 49, 47, 47, 0, 46, 16, 52, 0, 21, 0, 57, 31, 0…\n## $ gender      <dbl> 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0…\n## $ impressions <dbl> 3, 3, 3, 3, 11, 11, 7, 5, 3, 4, 8, 3, 4, 6, 5, 6, 3, 5, 4,…\n## $ clicks      <dbl> 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n## $ age_group   <ord> 35-44, 65+, 25-34, 45-54, 45-54, 45-54, <18, 45-54, <18, 4…\n## $ ctr_rate    <dbl> 0.000, 0.000, 0.000, 0.000, 0.000, 0.091, 0.143, 0.000, 0.…\n## $ female      <fct> yes, no, yes, no, no, yes, yes, yes, yes, yes, yes, yes, y…\n## $ signed_in   <fct> yes, yes, yes, yes, yes, yes, no, yes, yes, yes, no, yes, …\n\n\nThese are what I’d expect, given the two data frames will have slightly different columns and column format.\nAnother option involves the group_walk() function from dplyr (WARNING: this is experimental).\n\n\nnyt_data_proc |> \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk( ~vroom::vroom_write(x = .x, \n                          file = paste0(.y$proc_file_pth, \".csv\"),\n                          delim = \",\"))\n\n\nRe-written as an anonymous function, this would look like:\n\n\n# remove the processed folder so we're not confusing ourselves\nwalk(.x = list.files(path = \"dds-nyt/processed\", \n                     full.names = TRUE, \n                     pattern = \".csv$\"),\n    .f = fs::file_delete)\n# now re-create\nfs::dir_create(\"dds-nyt/processed/\")\nnyt_data_proc |> \n  dplyr::group_by(proc_file_pth) |>   \n  dplyr::group_walk(\\(x, y) \n    vroom::vroom_write(\n    x = x, \n    file = paste0(y$proc_file_pth, \".csv\"),\n    delim = \", \")\n    )\n# check\nfs::dir_tree(\"dds-nyt/processed/\", pattern = \"csv$\")\n## dds-nyt/processed/\n## ├── 2023-04-08-nyt1.csv\n## ├── 2023-04-08-nyt10.csv\n## ├── 2023-04-08-nyt11.csv\n## ├── 2023-04-08-nyt12.csv\n## ├── 2023-04-08-nyt13.csv\n## ├── 2023-04-08-nyt14.csv\n## ├── 2023-04-08-nyt15.csv\n## ├── 2023-04-08-nyt16.csv\n## ├── 2023-04-08-nyt17.csv\n## ├── 2023-04-08-nyt18.csv\n## ├── 2023-04-08-nyt19.csv\n## ├── 2023-04-08-nyt2.csv\n## ├── 2023-04-08-nyt20.csv\n## ├── 2023-04-08-nyt21.csv\n## ├── 2023-04-08-nyt22.csv\n## ├── 2023-04-08-nyt23.csv\n## ├── 2023-04-08-nyt24.csv\n## ├── 2023-04-08-nyt25.csv\n## ├── 2023-04-08-nyt26.csv\n## ├── 2023-04-08-nyt27.csv\n## ├── 2023-04-08-nyt28.csv\n## ├── 2023-04-08-nyt29.csv\n## ├── 2023-04-08-nyt3.csv\n## ├── 2023-04-08-nyt30.csv\n## ├── 2023-04-08-nyt31.csv\n## ├── 2023-04-08-nyt4.csv\n## ├── 2023-04-08-nyt5.csv\n## ├── 2023-04-08-nyt6.csv\n## ├── 2023-04-08-nyt7.csv\n## ├── 2023-04-08-nyt8.csv\n## └── 2023-04-08-nyt9.csv\n\n\nOnce again, I’ll import the first file in the new processed data folder and check it against the columns nyt1_proc_check_01 data to evaluate the differences.\n\n\nnyt1_proc_check_02 <- vroom::vroom(\n  list.files(path = \"dds-nyt/processed\", \n                    pattern = \".csv$\", \n        full.names = TRUE)[[1]], # grab the first file\n   delim = \",\", show_col_types = FALSE\n  )\n\n\n\n\nwaldo::compare(\n  x = names(nyt1_proc_check_01),\n  y = names(nyt1_proc_check_02))\n\n`old[8:11]`: \"female\" \"signed_in\" \"file_nm\" \"proc_file_pth\"\n`new[8:10]`: \"female\" \"signed_in\" \"file_nm\"                \n\n\n\n\n\n\n\n\n\n\n\n\nREACP: purrr syntax variations\n\n\n\n\nStandard\n\n\n# define .x and .f\npurrr::map(.x = my_list, .f = tolower)\n\n\nAnonymous function\n\n\n# anonymous shorthand notation\nmy_list |> purrr::map(\\(x) tolower(x))\n\n\nFormula (deprecated)\n\n\n# written as normal expression\nmy_list |> purrr::map(~ tolower(.x))\n\n\n\nFor more information check out the iteration chapter in R for Data Science."
  },
  {
    "objectID": "listings.html",
    "href": "listings.html",
    "title": "Posts",
    "section": "",
    "text": "These are posts on R packages we're currently using\n\n\n  \n    \n      \n        Box write modular code\n      \n      \n        \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        purrr v1.0.0 purrr refresher\n      \n      \n        \n      \n    \n    \n      \n    \n  \n\n\nA series exploring shiny frameworks. \n\n\n  \n    \n      \n        vanilla shiny minimal shiny\n      \n      \n        \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        myPkgApp devtools & shiny\n      \n      \n        \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        myGolemApp golem & shiny\n      \n      \n        \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        myLeprechaunApp leprechaun & shiny\n      \n      \n        \n      \n    \n    \n      \n    \n  \n  \n    \n      \n        myRhinoApp rhino & shiny\n      \n      \n        \n      \n    \n    \n      \n    \n  \n\n\nNo matching items"
  }
]